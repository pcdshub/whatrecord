{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"whatrecord","text":""},{"location":"#what-is-this","title":"What is this?","text":"<p>whatrecord provides a variety of independent tools that work together as part of a larger web-facing application for gathering information about EPICS IOCs and related files.</p>"},{"location":"#lark-grammar-based-parsers","title":"Lark grammar-based parsers","text":"<p>Lark-based grammars allow for parsing any of the following into easy-to-use Python dataclasses:</p> <ul> <li>EPICS access security files (.acf)</li> <li>EPICS autosave save files (.sav)</li> <li>EPICS V3 database files</li> <li>EPICS V4 database files</li> <li>EPICS msi-style template/substitutions files (.template/.substitutions)</li> <li>EPICS gateway configuration (.pvlist)</li> <li>EPICS sequencer state notation language programs (.st)</li> <li>EPICS StreamDevice protocols (.proto)</li> </ul> <p>All of the above can be easily serialized to JSON for interoperability.</p>"},{"location":"#pseudo-ioc-shell-interpreter","title":"Pseudo-IOC shell interpreter","text":"<ul> <li>Reads st.cmd files as if whatrecord were the IOC process</li> <li>Loads and lints record files (and other supported formats above)</li> <li>Builds inter- and intra- IOC PV relationship graphs</li> <li>Stores context information about where each record/field/etc came from</li> </ul>"},{"location":"#api-server","title":"API server","text":"<ul> <li>IOC finder (LCLS IOC manager, list of files, or external script)</li> <li>Provides access to all parsed information above</li> <li>Preliminary asyncio-based client to talk with the server</li> </ul>"},{"location":"#frontend","title":"Frontend","text":"<p>This is a user-friendly vue.js v3 frontend that communicates with API server.</p> <p>It contains interfaces for:</p> <ul> <li>Searching for records</li> <li>Record relationships (processing and links, cross-IOC links)</li> <li>IOC information</li> <li>Gateway configuration overview</li> <li>Duplicate records</li> <li>Optional plugins</li> <li>API server logs</li> </ul>"},{"location":"#plugins","title":"Plugins","text":"<ul> <li>happi devices</li> <li>Simple LDAP search (LCLS hosts, \"netconfig\")</li> <li>LCLS-specific epicsArch / logbook DAQ PVs</li> <li>TwinCAT PLC source code (pytmc)</li> </ul>"},{"location":"#makefile-build-system-information","title":"Makefile / build system information","text":"<ul> <li>Determine build dependencies from a <code>Makefile</code></li> <li>Recursively inspect sub-dependencies</li> <li>Graph IOC dependency information or output it as JSON</li> </ul>"},{"location":"#command-line-tools","title":"Command-line tools","text":"<ul> <li><code>whatrecord lint</code> - lint a database</li> <li><code>whatrecord parse</code> - parse supported formats to JSON</li> <li><code>whatrecord server</code> - start the API server</li> <li><code>whatrecord graph</code> - graph PV relationships, SNL diagrams, IOC dependencies</li> <li>Plugins can similarly be executed to provide parsed information in JSON</li> </ul>"},{"location":"#installing","title":"Installing","text":"<pre><code>$ pip install whatrecord\n</code></pre>"},{"location":"#starting-the-server","title":"Starting the server","text":"<p>See Server / client for more information.</p>"},{"location":"#fair-warning","title":"Fair warning","text":"<ul> <li>whatrecord isn\u2019t error or bug-free</li> <li>whatrecord aims to be as compliant as possible when parsing the formats it   supports, but there may be discrepancies.<ul> <li>If you find a case where it parses something incorrectly (or doesn't parse   it at all) please create an issue.</li> </ul> </li> <li>whatrecord isn\u2019t a good example of how to store relational data.  The initial   goals were breadth-first feature support:<ul> <li>Parse and interpret everything: in-memory dataclasses storing all   information</li> <li>Get it to be displayed in a friendly way</li> <li>Efficient storage can be tackled later!</li> </ul> </li> <li>Database-backed information along with and corresponding backend/frontend   changes will need to be pursued</li> </ul>"},{"location":"#background","title":"Background","text":"<p>This started out as a project where I thought I'd reuse as much of epics-base as possible to generate information about IOCs for easy indexing, and all the while learn about some modern web development practices.</p> <p>In no particular order, the project has gone through some transformations:</p> <p>I ended up writing a bunch of Lark grammars which effectively replaced the need for epics-pypdb and other miscellaneous core stuff in epics-base.</p> <p>the possibilities for such a tool became more clear to me, specifically targetting EPICS IOC record debugging.</p> <p>I was curious if we were using pva2pva at all. So now the grammars will load up pvAccess Q:group tags.  But it's likely not 100% correct, and certainly not complete.</p> <p>I had other thoughts about what could be integrated (gateway, happi, pytmc, IOC dependencies, versions, ...)</p> <p>It's likely this hasn't finished morphing just yet.  I definitely need to circle back and clean up the initial prototype mess.</p>"},{"location":"cli/","title":"CLI","text":"<p>Top-level options:</p> <pre><code>usage: whatrecord [-h] [--version] [--log LOG_LEVEL]\n                  {info,iocmanager-loader,lint,parse,server} ...\n\n`whatrecord` is the top-level command for accessing various subcommands.\n\nTry::\n\n    $ whatrecord info --help\n    $ whatrecord iocmanager-loader --help\n    $ whatrecord lint --help\n    $ whatrecord parse --help\n    $ whatrecord server --help\n\npositional arguments:\n  {info,iocmanager-loader,lint,parse,server}\n                        Possible subcommands\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --version, -V         Show the whatrec version number and exit.\n  --log LOG_LEVEL, -l LOG_LEVEL\n                        Python logging level (e.g. DEBUG, INFO, WARNING)\n</code></pre>"},{"location":"cli/#lint","title":"lint","text":"<p><code>whatrecord lint</code> is used to lint a startup script or database file. See if there are errors in your database file, startup script contents, etc.</p> <pre><code>usage: whatrecord lint [-h] [--dbd DBD] [--standin-directory [STANDIN_DIRECTORY ...]] [--json] [-v] [--use-gdb] filename\n\n\"whatrecord lint\" is used to lint a startup script or database file.\n\npositional arguments:\n  filename              Startup script filename\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --dbd DBD             The dbd file, if parsing a database\n  --standin-directory [STANDIN_DIRECTORY ...]\n                        Map a \"stand-in\" directory to another on disk\n  --json\n  -v, --verbose         Increase verbosity\n  --use-gdb             Use metadata derived from the script binary\n</code></pre>"},{"location":"cli/#parse","title":"parse","text":"<p>\"whatrecord parse\" is used to parse and interpret any of whatrecord's supported file formats, dumping the results to the console (standard output) in JSON format, by default.</p> <pre><code>usage: whatrecord parse [-h] [--format FORMAT] [--dbd DBD]\n                        [--standin-directory [STANDIN_DIRECTORY ...]] [--macros MACROS]\n                        [--friendly] [--friendly-format FRIENDLY_FORMAT] [--use-gdb] [--expand]\n                        filename\n\n\"whatrecord parse\" is used to parse and interpret any of whatrecord's supported\nfile formats, dumping the results to the console (standard output) in JSON\nformat, by default.\n\npositional arguments:\n  filename              Startup script filename\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --format FORMAT       The file format.  For files that lack a recognized\n                        extension or are otherwise misidentified by whatrecord.\n  --dbd DBD             The dbd file, if parsing a database\n  --standin-directory [STANDIN_DIRECTORY ...]\n                        Map a \"stand-in\" directory to another on disk\n  --macros MACROS       Macro to add, in the usual form ``macro=value,...``\n  --friendly            Output Python object representation instead of JSON\n  --friendly-format FRIENDLY_FORMAT\n                        Output Python object representation instead of JSON\n  --use-gdb             Use metadata derived from the script binary\n  --expand              Expand a substitutions file, as in the msi tool\n</code></pre>"},{"location":"cli/#server","title":"server","text":"<p>This is how to start the API server.</p> <pre><code>usage: whatrecord server [-h] [--scripts [SCRIPTS ...]] [--script-loader [SCRIPT_LOADER ...]]\n                         [--archive-management-url ARCHIVE_MANAGEMENT_URL]\n                         [--gateway-config GATEWAY_CONFIG]\n                         [--standin-directory [STANDIN_DIRECTORY ...]] [--port PORT]\n                         [--tracemalloc]\n\n\"whatrecord server\" is used to start an aiohttp-backed web server which hosts\nstartup script and record information.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --scripts [SCRIPTS ...]\n                        Startup script filename(s)\n  --script-loader [SCRIPT_LOADER ...]\n                        Run an external script to get IOC configuration information\n  --archive-management-url ARCHIVE_MANAGEMENT_URL\n                        Archiver management URL for finding archived PVs.\n  --gateway-config GATEWAY_CONFIG\n                        Gateway configuration file or directory\n  --standin-directory [STANDIN_DIRECTORY ...]\n                        Map a \"stand-in\" directory to another on disk\n  --port PORT           Web server TCP port\n  --tracemalloc         [Debug] Use tracemalloc to debug server memory usage\n</code></pre>"},{"location":"cli/#info","title":"info","text":"<p><code>whatrecord info</code> talks to the API server to get information about a record.</p> <pre><code>usage: whatrecord info [-h] [--json] records [records ...]\n\n\"whatrecord info\" is used to get PV information from the whatrecord server.\n\npositional arguments:\n  records     Record name(s)\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --json      Output raw JSON\n</code></pre>"},{"location":"cli/#api","title":"API","text":""},{"location":"cli/#whatrecord.bin","title":"<code>whatrecord.bin</code>","text":""},{"location":"cli/#whatrecord.bin.main","title":"<code>whatrecord.bin.main</code>","text":"<p><code>whatrecord</code> is the top-level command for accessing various subcommands.</p> <p>Try::</p>"},{"location":"cli/#whatrecord.bin.lint","title":"<code>whatrecord.bin.lint</code>","text":"<p>\"whatrecord lint\" is used to lint a startup script or database file.</p>"},{"location":"cli/#whatrecord.bin.lint-classes","title":"Classes","text":""},{"location":"cli/#whatrecord.bin.lint-functions","title":"Functions","text":""},{"location":"cli/#whatrecord.bin.lint.lint","title":"<code>whatrecord.bin.lint.lint(obj: Union[Database, LoadedIoc], *, verbosity: int = 0, file: IO[str] = sys.stdout, fmt: FormatContext = None) -&gt; Union[Database, LoadedIoc]</code>","text":"<p>Lint a startup script or a database file.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[Database, LoadedIoc]</code> <p>The object to lint.</p> required Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/bin/lint.py</code> <pre><code>def lint(\n    obj: Union[Database, LoadedIoc],\n    *,\n    verbosity: int = 0,\n    file: IO[str] = sys.stdout,\n    fmt: FormatContext = None,\n) -&gt; Union[Database, LoadedIoc]:\n\"\"\"\n    Lint a startup script or a database file.\n\n    Parameters\n    ----------\n    obj :\n        The object to lint.\n    \"\"\"\n    fmt = fmt or FormatContext()\n    if isinstance(obj, LoadedIoc):\n        commands = obj.metadata.commands\n        # variables = obj.metadata.variables\n        for line in obj.script.lines:\n            if line.line or verbosity &gt; 2:\n                if line.error or verbosity &gt; 1:\n                    print(fmt.render_object(line).rstrip(), file=file)\n                if commands and line.argv:\n                    command_info = commands.get(line.argv[0], None)\n                    lint_command(command_info=command_info, argv=line.argv, file=file, fmt=fmt)\n</code></pre>"},{"location":"cli/#whatrecord.bin.lint.lint_command","title":"<code>whatrecord.bin.lint.lint_command(command_info: IocshCommand, argv: List[str], file: IO[str] = sys.stdout, fmt: FormatContext = None)</code>","text":"<p>Lint a command given its argument information.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/bin/lint.py</code> <pre><code>def lint_command(\n    command_info: IocshCommand,\n    argv: List[str],\n    file: IO[str] = sys.stdout,\n    fmt: FormatContext = None,\n):\n\"\"\"Lint a command given its argument information.\"\"\"\n    if not command_info:\n        print(f\"  ! Warning: Unknown command: {argv[0]}\")\n        return\n\n    expected_args = command_info.args\n    actual_args = argv[1:]\n    arg_names = [arg.name for arg in expected_args]\n    if len(actual_args) == len(expected_args):\n        return\n\n    if len(actual_args) &lt; len(expected_args):\n        arg_names = [arg.name for arg in expected_args]\n        arg_values = list(actual_args) + [\"?\"] * (len(expected_args) - len(actual_args))\n        print(\"  ! Warning: may be too few arguments\", file=file)\n    else:\n        print(\"  ! Warning: too many arguments\", file=file)\n        arg_names = [\n            arg.name for arg in expected_args\n        ] + [\"?\"] * (len(actual_args) - len(expected_args))\n        arg_values = actual_args\n\n    for idx, (arg_name, value) in enumerate(zip(arg_names, arg_values), 1):\n        print(f\"    {idx}. {arg_name} = {value}\", file=file)\n    print(file=file)\n</code></pre>"},{"location":"cli/#whatrecord.bin.parse","title":"<code>whatrecord.bin.parse</code>","text":"<p>\"whatrecord parse\" is used to parse and interpret any of whatrecord's supported file formats, dumping the results to the console (standard output) in JSON format, by default.</p> <p>Unless <code>--disable-macros</code> is specified, all text will go through the macro context as if the files were being loaded in an IOC shell.</p>"},{"location":"cli/#whatrecord.bin.parse-classes","title":"Classes","text":""},{"location":"cli/#whatrecord.bin.parse-functions","title":"Functions","text":""},{"location":"cli/#whatrecord.bin.parse.parse_from_cli_args","title":"<code>whatrecord.bin.parse.parse_from_cli_args(filename: AnyPath, dbd: Optional[str] = None, standin_directory: Optional[List[str]] = None, macros: Optional[str] = None, disable_macros: bool = False, use_gdb: bool = False, format: Optional[str] = None, expand: bool = False, v3: bool = False) -&gt; ParseResult</code>","text":"<p>Generically parse either a startup script or a database file.</p> <p>This variant uses the raw CLI arguments, mapping them on to those that <code>parse</code> expects.  For programmatic usage, please use <code>parse()</code> directly.</p> <p>Unless <code>disable_macros</code> is set, all text will go through the macro context as if the files were being loaded in an IOC shell.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>The filename to parse.</p> required <p>dbd : str or pathlib.Path, optional     The associated database definition file, if parsing a database file.</p> <p>standin_directories : list, optional     A list of substitute directories of the form <code>DirectoryA=DirectoryB</code>.</p> <p>macros : str, optional     Macro string to use when parsing the file.  Ignored if     <code>disable_macros</code> is set.</p> <p>disable_macros : bool, optional     Disable macro handling, leaving unexpanded macros in the output.</p> <p>expand : bool, optional     Expand a substitutions file.</p> <p>v3 : bool, optional     Use V3 database grammar where applicable.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/bin/parse.py</code> <pre><code>def parse_from_cli_args(\n    filename: AnyPath,\n    dbd: Optional[str] = None,\n    standin_directory: Optional[List[str]] = None,\n    macros: Optional[str] = None,\n    disable_macros: bool = False,\n    use_gdb: bool = False,\n    format: Optional[str] = None,\n    expand: bool = False,\n    v3: bool = False,\n) -&gt; ParseResult:\n\"\"\"\n    Generically parse either a startup script or a database file.\n\n    This variant uses the raw CLI arguments, mapping them on to those that\n    `parse` expects.  For programmatic usage, please use ``parse()`` directly.\n\n    Unless ``disable_macros`` is set, all text will go through the macro\n    context as if the files were being loaded in an IOC shell.\n\n    Parameters\n    ----------\n    filename : str or pathlib.Path\n        The filename to parse.\n\n    dbd : str or pathlib.Path, optional\n        The associated database definition file, if parsing a database file.\n\n    standin_directories : list, optional\n        A list of substitute directories of the form ``DirectoryA=DirectoryB``.\n\n    macros : str, optional\n        Macro string to use when parsing the file.  Ignored if\n        ``disable_macros`` is set.\n\n    disable_macros : bool, optional\n        Disable macro handling, leaving unexpanded macros in the output.\n\n    expand : bool, optional\n        Expand a substitutions file.\n\n    v3 : bool, optional\n        Use V3 database grammar where applicable.\n    \"\"\"\n    standin_directories = dict(\n        path.split(\"=\", 1) for path in standin_directory or \"\"\n    )\n\n    if isinstance(filename, str) and filename.startswith(\"{\"):   # }\n        # TODO - argparse fixup?\n        ioc_metadata = IocMetadata.from_dict(json.loads(filename))\n        # TODO macros, use_gdb, ...\n        # ioc_metadata.macros = macros\n        return LoadedIoc.from_metadata(\n            ioc_metadata\n        )\n\n    try:\n        format = FileFormat(format) if format is not None else None\n    except ValueError:\n        options = [fmt.name for fmt in list(FileFormat)]\n        raise ValueError(\n            f\"{format!r} is not a valid FileFormat. Options include: \"\n            f\"{options}\"\n        )\n\n    return parse(\n        filename,\n        dbd=dbd,\n        standin_directories=standin_directories,\n        macros=macros,\n        disable_macros=disable_macros,\n        use_gdb=use_gdb,\n        format=format,\n        expand=expand,\n        v3=v3,\n    )\n</code></pre>"},{"location":"cli/#whatrecord.bin.server","title":"<code>whatrecord.bin.server</code>","text":"<p>\"whatrecord server\" is used to start an aiohttp-backed web server which hosts startup script and record information.</p>"},{"location":"iocsh/","title":"IOC Shell-Related","text":""},{"location":"iocsh/#api","title":"API","text":""},{"location":"iocsh/#whatrecord.asyn","title":"<code>whatrecord.asyn</code>","text":""},{"location":"iocsh/#whatrecord.asyn-classes","title":"Classes","text":""},{"location":"iocsh/#whatrecord.asyn.AsynState","title":"<code>whatrecord.asyn.AsynState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ShellStateHandler</code></p> <p>Asyn IOC shell state handler / container.</p> <p>Contains hooks for asyn-related commands and state information.</p> <p>Attributes:</p> Name Type Description <code>ports</code> <code>Dict[str, AsynPortBase]</code> <p>Asyn ports defined by name.</p>"},{"location":"iocsh/#whatrecord.asyn.AsynState-functions","title":"Functions","text":"<code>whatrecord.asyn.AsynState.get_port_from_record(inst: RecordInstance) -&gt; Optional[AsynPort]</code> <p>Given a record, return its related asyn port.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/asyn.py</code> <pre><code>def get_port_from_record(self, inst: RecordInstance) -&gt; Optional[AsynPort]:\n\"\"\"Given a record, return its related asyn port.\"\"\"\n    if inst.is_pva:\n        return\n\n    rec_field: Optional[RecordField]\n    rec_field = inst.fields.get(\"INP\", inst.fields.get(\"OUT\", None))\n    if rec_field is None:\n        return\n\n    if not isinstance(rec_field.value, str):\n        # No PVAccess links just yet\n        return\n\n    value = rec_field.value.strip()\n    if value.startswith(\"@asyn\"):\n        try:\n            asyn_args = value.split(\"@asyn\")[1].strip(\" ()\")\n            asyn_port, *_ = asyn_args.split(\",\")\n            return self.ports.get(asyn_port.strip(), None)\n        except Exception:\n            logger.debug(\"Failed to parse asyn string\", exc_info=True)\n</code></pre>"},{"location":"iocsh/#whatrecord.iocsh","title":"<code>whatrecord.iocsh</code>","text":""},{"location":"iocsh/#whatrecord.iocsh-classes","title":"Classes","text":""},{"location":"iocsh/#whatrecord.iocsh-functions","title":"Functions","text":""},{"location":"iocsh/#whatrecord.iocsh.parse_iocsh_line","title":"<code>whatrecord.iocsh.parse_iocsh_line(line: str, *, context: Optional[LoadContext] = None, prompt: str = 'epics&gt;', macro_context: Optional[MacroContext] = None, string_encoding: str = 'latin-1') -&gt; IocshResult</code>","text":"<p>Parse an IOC shell line into an IocshResult.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The line to parse.</p> required <p>context : LoadContext, optional    The load context to populate the result with.</p> <p>prompt : str, optional    Replicating the EPICS source code, specify the state of the prompt    here.  Defaults to \"epics&gt;\".  If unset as in prior to IOC init,    lines that do not start with \"#-\" will be eched.</p> <p>Returns:</p> Type Description <code>IocshResult</code> <p>A partially filled IocshResult, ready for interpreting by a higher-level function.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/iocsh.py</code> <pre><code>def parse_iocsh_line(\n    line: str, *,\n    context: Optional[LoadContext] = None,\n    prompt: str = \"epics&gt;\",\n    macro_context: Optional[MacroContext] = None,\n    string_encoding: str = \"latin-1\",\n) -&gt; IocshResult:\n\"\"\"\n    Parse an IOC shell line into an IocshResult.\n\n    Parameters\n    ----------\n    line : str\n       The line to parse.\n\n    context : LoadContext, optional\n       The load context to populate the result with.\n\n    prompt : str, optional\n       Replicating the EPICS source code, specify the state of the prompt\n       here.  Defaults to \"epics&gt;\".  If unset as in prior to IOC init,\n       lines that do not start with \"#-\" will be eched.\n\n    Returns\n    -------\n    IocshResult\n       A partially filled IocshResult, ready for interpreting by a\n       higher-level function.\n    \"\"\"\n    result = IocshResult(context=context, line=line)\n    # Skip leading whitespace\n    line = line.lstrip()\n\n    if not line.startswith(\"#-\"):\n        result.outputs.append(line)\n\n    if line.startswith('#'):\n        # Echo non-empty lines read from a script.\n        # Comments delineated with '#-' aren't echoed.\n        return result\n\n    if macro_context is not None:\n        line = macro_context.expand(line)\n\n    # * Skip leading white-space coming from a macro\n    line = line.lstrip()\n\n    # * Echo non-empty lines read from a script.\n    # * Comments delineated with '#-' aren't echoed.\n    if not prompt:\n        if not line.startswith('#-'):\n            result.outputs.append(line)\n\n    # * Ignore lines that became a comment or empty after macro expansion\n    if not line or line.startswith('#'):\n        return result\n\n    split = split_iocsh_line(line, string_encoding=string_encoding)\n    result.argv = split.argv\n\n    # Only set the following if necessary; apischema can skip serialization\n    # otherwise.\n    if split.redirects:\n        result.redirects = list(split.redirects.values())\n\n    if split.error:\n        result.error = split.error\n\n    return result\n</code></pre>"},{"location":"iocsh/#whatrecord.motor","title":"<code>whatrecord.motor</code>","text":""},{"location":"iocsh/#whatrecord.motor-classes","title":"Classes","text":""},{"location":"iocsh/#whatrecord.motor.MotorState","title":"<code>whatrecord.motor.MotorState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ShellStateHandler</code></p> <p>Motor record support IOC shell state handler / container.</p>"},{"location":"iocsh/#whatrecord.motor.MotorState-attributes","title":"Attributes","text":"<code>whatrecord.motor.MotorState.asyn: asyn.AsynState</code> <code>property</code> <p>Asyn instance.</p> <code>whatrecord.motor.MotorState.ports: Dict[str, AsynPortBase]</code> <code>property</code> <p>Asyn ports.</p>"},{"location":"iocsh/#whatrecord.shell","title":"<code>whatrecord.shell</code>","text":""},{"location":"iocsh/#whatrecord.shell-classes","title":"Classes","text":""},{"location":"iocsh/#whatrecord.shell.LoadedIoc","title":"<code>whatrecord.shell.LoadedIoc</code>  <code>dataclass</code>","text":""},{"location":"iocsh/#whatrecord.shell.LoadedIoc-functions","title":"Functions","text":"<code>whatrecord.shell.LoadedIoc.from_cache(md: IocMetadata) -&gt; Optional[LoadedIoc]</code> <code>classmethod</code> <p>If available, load the cached data about the provided IOC.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>IocMetadata</code> <p>The metadata that identifies the IOC.</p> required <p>Returns:</p> Type Description <code>LoadedIoc or None</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>@classmethod\ndef from_cache(cls, md: IocMetadata) -&gt; Optional[LoadedIoc]:\n\"\"\"\n    If available, load the cached data about the provided IOC.\n\n    Parameters\n    ----------\n    md : IocMetadata\n        The metadata that identifies the IOC.\n\n    Returns\n    -------\n    LoadedIoc or None\n    \"\"\"\n    json_dict = cls._json_from_cache(md)\n    if json_dict is not None:\n        return apischema.deserialize(cls, json_dict)\n</code></pre> <code>whatrecord.shell.LoadedIoc.from_errored_load(md: IocMetadata, load_failure: IocLoadFailure) -&gt; LoadedIoc</code> <code>classmethod</code> <p>Create a LoadedIoc from a failed load, as indicated by IocLoadFailure.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>IocMetadata</code> <p>The metadata that was used to load the IOC.</p> required <code>load_failure</code> <code>IocLoadFailure</code> <p>The load failure information.</p> required <p>Returns:</p> Type Description <code>LoadedIoc</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>@classmethod\ndef from_errored_load(\n    cls, md: IocMetadata, load_failure: IocLoadFailure\n) -&gt; LoadedIoc:\n\"\"\"\n    Create a LoadedIoc from a failed load, as indicated by IocLoadFailure.\n\n    Parameters\n    ----------\n    md : IocMetadata\n        The metadata that was used to load the IOC.\n    load_failure : IocLoadFailure\n        The load failure information.\n\n    Returns\n    -------\n    LoadedIoc\n    \"\"\"\n    exception_line = f\"{load_failure.ex_class}: {load_failure.ex_message}\"\n    error_lines = [exception_line] + load_failure.traceback.splitlines()\n    script = IocshScript(\n        path=str(md.script),\n        lines=tuple(\n            IocshResult(line=line, context=(LoadContext(\"error\", lineno),))\n            for lineno, line in enumerate(error_lines, 1)\n        ),\n    )\n    md.metadata[\"exception_class\"] = load_failure.ex_class\n    md.metadata[\"exception_message\"] = load_failure.ex_message\n    md.metadata[\"traceback\"] = load_failure.traceback\n    md.metadata[\"load_failure\"] = True\n    return cls(\n        name=md.name,\n        path=md.script,\n        metadata=md,\n        shell_state=ShellState(),\n        script=script,\n        load_failure=True,\n    )\n</code></pre> <code>whatrecord.shell.LoadedIoc.from_metadata(md: IocMetadata) -&gt; LoadedIoc</code> <code>classmethod</code> <p>Generate a LoadedIoc by interpreting the startup script.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>IocMetadata</code> <p>The metadata from the IOC.</p> required <p>Returns:</p> Type Description <code>LoadedIoc</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>@classmethod\ndef from_metadata(cls, md: IocMetadata) -&gt; LoadedIoc:\n\"\"\"\n    Generate a LoadedIoc by interpreting the startup script.\n\n    Parameters\n    ----------\n    md : IocMetadata\n        The metadata from the IOC.\n\n    Returns\n    -------\n    LoadedIoc\n    \"\"\"\n    sh = ShellState(ioc_info=md)\n    sh.working_directory = md.startup_directory\n    sh.macro_context.define(**md.macros)\n    sh.standin_directories = md.standin_directories or {}\n\n    # It's not enough to chdir, as we can rely on the environment variable\n    # in shell scripts:\n    os.environ[\"PWD\"] = str(md.startup_directory)\n\n    script = IocshScript.from_metadata(md, sh=sh)\n    return cls(\n        name=md.name,\n        path=md.script,\n        metadata=md,\n        shell_state=sh,\n        script=script,\n        pv_relations=graph.build_database_relations(sh.database),\n    )\n</code></pre> <code>whatrecord.shell.LoadedIoc.save_to_cache() -&gt; bool</code> <p>Save this instance to the application cache.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def save_to_cache(self) -&gt; bool:\n\"\"\"Save this instance to the application cache.\"\"\"\n    if not settings.CACHE_PATH:\n        return False\n\n    with open(self.metadata.ioc_cache_filename, \"wt\") as fp:\n        json.dump(apischema.serialize(self), fp=fp)\n    return True\n</code></pre> <code>whatrecord.shell.LoadedIoc.whatrec(rec: str, field: Optional[str] = None, include_pva: bool = True) -&gt; Optional[WhatRecord]</code> <p>Get record information, optionally including PVAccess results.</p> <p>Parameters:</p> Name Type Description Default <code>rec</code> <code>str</code> <p>The record name (excluding any field).</p> required <code>field</code> <code>Optional[str]</code> <p>An optional field name, such as <code>DESC</code>.  Currently unused.</p> <code>None</code> <code>include_pva</code> <code>bool</code> <p>Include PVAccess results in the query.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[WhatRecord]</code> <p>Information about the provided record, if available.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def whatrec(\n    self, rec: str, field: Optional[str] = None, include_pva: bool = True\n) -&gt; Optional[WhatRecord]:\n\"\"\"\n    Get record information, optionally including PVAccess results.\n\n    Parameters\n    ----------\n    rec : str\n        The record name (excluding any field).\n    field : Optional[str], optional\n        An optional field name, such as ``DESC``.  Currently unused.\n    include_pva : bool, optional\n        Include PVAccess results in the query.\n\n    Returns\n    -------\n    Optional[WhatRecord]\n        Information about the provided record, if available.\n    \"\"\"\n    state = self.shell_state\n    v3_inst = state.database.get(state.aliases.get(rec, rec), None)\n    pva_inst = state.pva_database.get(rec, None) if include_pva else None\n    if not v3_inst and not pva_inst:\n        return\n\n    what = WhatRecord(\n        name=rec,\n        ioc=self.metadata,\n        record=None,\n        pva_group=None,\n    )\n    if v3_inst is not None:\n        if not state.database_definition:\n            defn = None\n        else:\n            defn = state.database_definition.record_types.get(\n                v3_inst.record_type, None\n            )\n            what.menus = state.database_definition.menus\n            # but what about device types and such?\n\n        v3_inst.metadata.update(state.annotate_record(v3_inst))\n        what.record = RecordDefinitionAndInstance(defn, v3_inst)\n\n    if pva_inst is not None:\n        what.pva_group = pva_inst\n\n    return what\n</code></pre>"},{"location":"iocsh/#whatrecord.shell.ScriptContainer","title":"<code>whatrecord.shell.ScriptContainer</code>  <code>dataclass</code>","text":"<p>Aggregate container for any number of LoadedIoc instances.</p> <p>Combines databases, sets of loaded files ease of querying.</p>"},{"location":"iocsh/#whatrecord.shell.ShellState","title":"<code>whatrecord.shell.ShellState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ShellStateHandler</code></p> <p>IOC shell state container.</p> <p>Contains hooks for commands and state information.</p> <p>This base state handler should only handle epics base-defined IOC shell commands, including: paths, variables, database loading, and IOC initialization.</p> <p>It is the top-level state container, which sub handlers should rely on for things like loading files and other core state information.</p> <p>Attributes:</p> Name Type Description <code>prompt</code> <code>str</code> <p>The prompt - PS1 - as in \"epics&gt;\".</p> <code>variables</code> <code>dict</code> <p>Shell variables (not environment variables).</p> <code>string_encoding</code> <code>str</code> <p>String encoding for byte strings and files.</p> <code>macro_context</code> <code>MacroContext</code> <p>Macro context for commands that are evaluated.</p> <code>standin_directories</code> <code>dict</code> <p>Rewrite hard-coded directory prefixes by setting::</p> <pre><code>standin_directories = {\"/replace_this/\": \"/with/this\"}\n</code></pre> <code>loaded_files</code> <code>Dict[str, str]</code> <p>Files loaded, mapped to a hash of their contents.</p> <code>working_directory</code> <code>Path</code> <p>Current working directory.</p> <code>database_definition</code> <code>Database</code> <p>Loaded database definition (dbd).</p> <code>database</code> <code>Dict[str, RecordInstance]</code> <p>The IOC database of records.</p> <code>pva_database</code> <code>Dict[str, RecordInstance]</code> <p>The IOC database of PVAccess groups.</p> <code>aliases</code> <code>Dict[str, str]</code> <p>Alias name to record name.</p> <code>load_context</code> <code>List[MutableLoadContext]</code> <p>Current loading context stack (e.g., <code>st.cmd</code> then <code>common_startup.cmd</code>).  Modified in place as scripts are evaluated.</p>"},{"location":"iocsh/#whatrecord.shell.ShellState-attributes","title":"Attributes","text":"<code>whatrecord.shell.ShellState.db_include_paths: List[pathlib.Path]</code> <code>property</code> <p>Database include paths (EPICS_DB_INCLUDE_PATH).</p> <code>whatrecord.shell.ShellState.sub_handlers: List[ShellStateHandler]</code> <code>property</code> <p>Handlers which contain their own state.</p>"},{"location":"iocsh/#whatrecord.shell.ShellState-functions","title":"Functions","text":"<code>whatrecord.shell.ShellState.annotate_record(record: RecordInstance) -&gt; Dict[str, Any]</code> <p>Hook to annotate a record after being loaded.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def annotate_record(self, record: RecordInstance) -&gt; Dict[str, Any]:\n\"\"\"Hook to annotate a record after being loaded.\"\"\"\n    result = {}\n    for handler in self.sub_handlers:\n        try:\n            annotation = handler.annotate_record(record)\n        except Exception:\n            logger.exception(\n                \"Record annotation failed for %s with handler %s\",\n                record.name, type(handler).__name__\n            )\n        else:\n            if annotation is not None:\n                # record.metadata[handler.metadata_key] = annotation\n                result[handler.metadata_key] = annotation\n\n    return result\n</code></pre> <code>whatrecord.shell.ShellState.get_load_context() -&gt; FullLoadContext</code> <p>Get a FullLoadContext tuple representing where we are now.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def get_load_context(self) -&gt; FullLoadContext:\n\"\"\"Get a FullLoadContext tuple representing where we are now.\"\"\"\n    if not self.load_context:\n        return tuple()\n    return tuple(ctx.to_load_context() for ctx in self.load_context)\n</code></pre> <code>whatrecord.shell.ShellState.handle_NDPvaConfigure(portName: str, queueSize: int = 0, blockingCallbacks: str = '', NDArrayPort: str = '', NDArrayAddr: str = '', pvName: str = '', maxBuffers: int = 0, maxMemory: int = 0, priority: int = 0, stackSize: int = 0)</code> <p>Implicitly creates a PVA group named <code>pvName</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>@_handler\ndef handle_NDPvaConfigure(\n    self,\n    portName: str,\n    queueSize: int = 0,\n    blockingCallbacks: str = \"\",\n    NDArrayPort: str = \"\",\n    NDArrayAddr: str = \"\",\n    pvName: str = \"\",\n    maxBuffers: int = 0,\n    maxMemory: int = 0,\n    priority: int = 0,\n    stackSize: int = 0,\n):\n\"\"\"Implicitly creates a PVA group named ``pvName``.\"\"\"\n    metadata = {\n        \"portName\": portName or \"\",\n        \"queueSize\": queueSize or \"\",\n        \"blockingCallbacks\": blockingCallbacks or \"\",\n        \"NDArrayPort\": NDArrayPort or \"\",\n        \"NDArrayAddr\": NDArrayAddr or \"\",\n        \"pvName\": pvName or \"\",\n        \"maxBuffers\": maxBuffers or \"\",\n        \"maxMemory\": maxMemory or \"\",\n        \"priority\": priority or \"\",\n        \"stackSize\": stackSize or \"\",\n    }\n    self.pva_database[pvName] = RecordInstance(\n        context=self.get_load_context(),\n        name=pvName,\n        record_type=\"PVA\",\n        fields={},\n        is_pva=True,\n        metadata={\"areaDetector\": metadata},\n    )\n    return metadata\n</code></pre> <code>whatrecord.shell.ShellState.interpret_shell_line(line, recurse = True, raise_on_error = False)</code> <p>Interpret a single shell script line.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def interpret_shell_line(self, line, recurse=True, raise_on_error=False):\n\"\"\"Interpret a single shell script line.\"\"\"\n    shresult = parse_iocsh_line(\n        line,\n        context=self.get_load_context(),\n        prompt=self.prompt,\n        macro_context=self.macro_context,\n        string_encoding=self.string_encoding,\n    )\n    input_redirects = [redir for redir in shresult.redirects if redir.mode == \"r\"]\n    if shresult.error:\n        yield shresult\n    elif input_redirects:\n        if recurse:\n            yield from self._handle_input_redirect(\n                input_redirects[0],\n                shresult,\n                recurse=recurse,\n                raise_on_error=raise_on_error,\n            )\n    elif shresult.argv:\n        try:\n            result = self._handle_command(*shresult.argv)\n            if result:\n                # Only set if not-None to speed up serialization\n                shresult.result = result\n        except Exception as ex:\n            if raise_on_error:\n                raise\n            ex_details = traceback.format_exc()\n            shresult.error = f\"Failed to execute: {ex}:\\n{ex_details}\"\n\n        yield shresult\n        if isinstance(shresult.result, IocshCmdArgs):\n            yield from self.interpret_shell_line(\n                shresult.result.command, recurse=recurse\n            )\n    else:\n        # Otherwise, nothing to do\n        yield shresult\n</code></pre> <code>whatrecord.shell.ShellState.interpret_shell_script(filename: Union[pathlib.Path, str], recurse: bool = True, raise_on_error: bool = False) -&gt; Generator[IocshResult, None, None]</code> <p>Load and interpret a shell script named <code>filename</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def interpret_shell_script(\n    self,\n    filename: Union[pathlib.Path, str],\n    recurse: bool = True,\n    raise_on_error: bool = False,\n) -&gt; Generator[IocshResult, None, None]:\n\"\"\"Load and interpret a shell script named ``filename``.\"\"\"\n    filename, contents = self.load_file(filename)\n    yield from self.interpret_shell_script_text(\n        contents.splitlines(),\n        name=str(filename),\n        recurse=recurse,\n        raise_on_error=raise_on_error,\n    )\n</code></pre> <code>whatrecord.shell.ShellState.interpret_shell_script_text(lines: Iterable[str], name: str = 'unknown', recurse: bool = True, raise_on_error: bool = False) -&gt; Generator[IocshResult, None, None]</code> <p>Interpret a shell script named <code>name</code> with <code>lines</code> of text.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def interpret_shell_script_text(\n    self,\n    lines: Iterable[str],\n    name: str = \"unknown\",\n    recurse: bool = True,\n    raise_on_error: bool = False,\n) -&gt; Generator[IocshResult, None, None]:\n\"\"\"Interpret a shell script named ``name`` with ``lines`` of text.\"\"\"\n    load_ctx = MutableLoadContext(str(name), 0)\n    try:\n        self.load_context.append(load_ctx)\n        for lineno, line in enumerate(lines, 1):\n            load_ctx.line = lineno\n            yield from self.interpret_shell_line(\n                line,\n                recurse=recurse,\n                raise_on_error=raise_on_error,\n            )\n    finally:\n        self.load_context.remove(load_ctx)\n</code></pre> <code>whatrecord.shell.ShellState.load_file(filename: AnyPath) -&gt; Tuple[pathlib.Path, str]</code> <p>Load a file, record its hash, and return its contents.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def load_file(self, filename: AnyPath) -&gt; Tuple[pathlib.Path, str]:\n\"\"\"Load a file, record its hash, and return its contents.\"\"\"\n    filename = self._fix_path(filename)\n    filename = filename.resolve()\n    shasum, contents = util.read_text_file_with_hash(\n        filename, encoding=self.string_encoding\n    )\n    self.loaded_files[str(filename)] = shasum\n    self.ioc_info.loaded_files[str(filename)] = shasum\n    return filename, contents\n</code></pre> <code>whatrecord.shell.ShellState.paths_from_env_var(env_var: str, *, default: Optional[str] = None) -&gt; List[pathlib.Path]</code> <p>Paths from an environment variable (or macro).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def paths_from_env_var(\n    self,\n    env_var: str,\n    *,\n    default: Optional[str] = None\n) -&gt; List[pathlib.Path]:\n\"\"\"Paths from an environment variable (or macro).\"\"\"\n    env_var = self.macro_context.get(env_var, default) or \"\"\n    return [\n        (self.working_directory / pathlib.Path(path)).resolve()\n        # TODO: this is actually OS-dependent (: on linux, ; on Windows)\n        for path in env_var.split(\":\")\n    ]\n</code></pre>"},{"location":"iocsh/#whatrecord.shell-functions","title":"Functions","text":""},{"location":"iocsh/#whatrecord.shell.async_load_ioc","title":"<code>whatrecord.shell.async_load_ioc(identifier: Union[int, str], md: IocMetadata, standin_directories: IocMetadata, use_gdb: bool = True, use_cache: bool = True) -&gt; IocLoadResult</code>  <code>async</code>","text":"<p>Helper function for loading an IOC in a subprocess and relying on the cache.</p> <p>Parameters:</p> Name Type Description Default <code>standin_directories</code> <p>Stand-in directories to use when loading the IOC.</p> required <code>identifier</code> <code>Union[int, str]</code> <p>The IOC identifier.</p> required <code>md</code> <code>IocMetadata</code> <p>Metadata tied to the IOC.</p> required <code>use_gdb</code> <code>bool</code> <p>Use GDB to analyze the IOC binary for linting of shell script commands.</p> <code>True</code> <code>use_cache</code> <code>bool</code> <p>Load from the cache for IOCs which have been cached.</p> <code>True</code> <p>Returns:</p> Type Description <code>IocLoadResult</code> <p>The result of loading, including an identifier which can be used by the caller to load the item from disk (as it's faster than using multiprocessing).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>async def async_load_ioc(\n    identifier: Union[int, str],\n    md: IocMetadata,\n    standin_directories,\n    use_gdb: bool = True,\n    use_cache: bool = True,\n) -&gt; IocLoadResult:\n\"\"\"\n    Helper function for loading an IOC in a subprocess and relying on the cache.\n\n    Parameters\n    ----------\n    standin_directories :\n        Stand-in directories to use when loading the IOC.\n    identifier : Union[int, str]\n        The IOC identifier.\n    md : IocMetadata\n        Metadata tied to the IOC.\n    use_gdb : bool, optional\n        Use GDB to analyze the IOC binary for linting of shell script commands.\n    use_cache : bool, optional\n        Load from the cache for IOCs which have been cached.\n\n    Returns\n    -------\n    IocLoadResult\n        The result of loading, including an identifier which can be used by the\n        caller to load the item from disk (as it's faster than using\n        multiprocessing).\n    \"\"\"\n    if not settings.CACHE_PATH:\n        use_cache = False\n    with time_context() as ctx:\n        try:\n            md.standin_directories.update(standin_directories)\n            if use_cache:\n                cached_ioc = load_cached_ioc(md)\n                if cached_ioc:\n                    return IocLoadResult(\n                        identifier=identifier,\n                        load_time=ctx(),\n                        cache_hit=True,\n                        result=\"use_cache\"\n                    )\n\n            loaded = LoadedIoc.from_metadata(md)\n            if use_gdb:\n                await md.get_binary_information()\n\n            if use_cache:\n                loaded.metadata.save_to_cache()\n                loaded.save_to_cache()\n                # Avoid pickling massive JSON blob; instruct server to load\n                # from cache with token 'use_cache'\n                serialized = \"use_cache\"\n            else:\n                serialized = apischema.serialize(loaded)\n        except Exception as ex:\n            return IocLoadResult(\n                identifier=identifier,\n                load_time=ctx(),\n                cache_hit=False,\n                result=IocLoadFailure(\n                    ex_class=type(ex).__name__,\n                    ex_message=str(ex),\n                    traceback=traceback.format_exc(),\n                ),\n            )\n\n        return IocLoadResult(\n            identifier=identifier,\n            load_time=ctx(),\n            cache_hit=False,\n            result=serialized,\n        )\n</code></pre>"},{"location":"iocsh/#whatrecord.shell.load_cached_ioc","title":"<code>whatrecord.shell.load_cached_ioc(md: IocMetadata, allow_failed_load: bool = False) -&gt; Optional[LoadedIoc]</code>","text":"<p>Load an IOC from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>IocMetadata</code> <p>The metadata from the IOC, which determines its cache key.</p> required <code>allow_failed_load</code> <code>bool</code> <p>A previous load of the provided IOC may have been marked as a failure. If set, <code>load_cached_ioc</code> will return the results of the failed load. If unset, <code>load_cached_ioc</code> will return <code>None</code> and allow the caller to treat this as a cache miss and potentially reload it from disk.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[LoadedIoc]</code> <p>The cached LoadedIoc instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>def load_cached_ioc(\n    md: IocMetadata,\n    allow_failed_load: bool = False,\n) -&gt; Optional[LoadedIoc]:\n\"\"\"\n    Load an IOC from the cache.\n\n    Parameters\n    ----------\n    md : IocMetadata\n        The metadata from the IOC, which determines its cache key.\n    allow_failed_load : bool, optional\n        A previous load of the provided IOC may have been marked as a failure.\n        If set, ``load_cached_ioc`` will return the results of the failed load.\n        If unset, ``load_cached_ioc`` will return ``None`` and allow the caller\n        to treat this as a cache miss and potentially reload it from disk.\n\n    Returns\n    -------\n    Optional[LoadedIoc]\n        The cached LoadedIoc instance.\n    \"\"\"\n    cached_md = md.from_cache()\n    if cached_md is None:\n        logger.debug(\"Cached metadata unavailable %s\", md.name)\n        return None\n\n    if md._cache_key != cached_md._cache_key:\n        logger.error(\"Cache key mismatch?! %s %s\", md._cache_key, cached_md._cache_key)\n        return None\n\n    if allow_failed_load and (\n        cached_md.metadata.get(\"load_failure\") or md.looks_like_sh\n    ):\n        logger.debug(\n            \"%s allow_failed_load=True; %s, md.looks_like_sh=%s\",\n            md.name,\n            cached_md.metadata.get(\"load_failure\"),\n            md.looks_like_sh,\n        )\n    elif not cached_md.is_up_to_date():\n        logger.debug(\"%s is not up-to-date\", md.name)\n        return\n\n    try:\n        logger.debug(\"%s is up-to-date; load from cache\", md.name)\n        return LoadedIoc._json_from_cache(cached_md)\n    except FileNotFoundError:\n        logger.error(\"%s is noted as up-to-date; but cache file missing\", md.name)\n\n    return None\n</code></pre>"},{"location":"iocsh/#whatrecord.shell.load_startup_scripts_with_metadata","title":"<code>whatrecord.shell.load_startup_scripts_with_metadata(*md_items, standin_directories = None, processes: int = 8, use_gdb: bool = True) -&gt; ScriptContainer</code>  <code>async</code>","text":"<p>Load all given startup scripts into a shared ScriptContainer.</p> <p>Parameters:</p> Name Type Description Default <code>*md_items</code> <code>list of IocMetadata</code> <p>List of IOC metadata.</p> <code>()</code> <code>standin_directories</code> <code>dict</code> <p>Stand-in/substitute directory mapping.</p> <code>None</code> <code>processes</code> <code>int</code> <p>The number of processes to use when loading.</p> <code>8</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/shell.py</code> <pre><code>async def load_startup_scripts_with_metadata(\n    *md_items,\n    standin_directories=None,\n    processes: int = 8,\n    use_gdb: bool = True,\n) -&gt; ScriptContainer:\n\"\"\"\n    Load all given startup scripts into a shared ScriptContainer.\n\n    Parameters\n    ----------\n    *md_items : list of IocMetadata\n        List of IOC metadata.\n    standin_directories : dict\n        Stand-in/substitute directory mapping.\n    processes : int\n        The number of processes to use when loading.\n    \"\"\"\n    total_files = len(md_items)\n    total_child_load_time = 0.0\n\n    with time_context() as total_time, ProcessPoolExecutor(\n        max_workers=processes, initializer=_process_init\n    ) as executor:\n        coros = [\n            asyncio.wrap_future(\n                executor.submit(\n                    _load_ioc, identifier=idx, md=md,\n                    standin_directories=standin_directories, use_gdb=use_gdb\n                )\n            )\n            for idx, md in enumerate(md_items)\n        ]\n\n        for coro in asyncio.as_completed(coros):\n            try:\n                load_result = await coro\n                md = md_items[load_result.identifier]\n            except Exception as ex:\n                logger.exception(\n                    \"Internal error while loading: %s: %s [server %.1f s]\",\n                    type(ex).__name__,\n                    ex,\n                    total_time(),\n                )\n                continue\n\n            use_cache = load_result.result == \"use_cache\"\n            if not use_cache:\n                loaded = load_result.result\n            else:\n                try:\n                    loaded = load_cached_ioc(md, allow_failed_load=True)\n                    if loaded is None:\n                        raise ValueError(\"Cache entry is empty?\")\n                except Exception as ex:\n                    logger.exception(\n                        \"Internal error while loading cached IOC from disk: \"\n                        \"%s: %s [server %.1f s]\",\n                        type(ex).__name__,\n                        ex,\n                        total_time(),\n                    )\n                    continue\n\n            total_child_load_time += load_result.load_time\n\n            if isinstance(loaded, IocLoadFailure):\n                failure_result: IocLoadFailure = loaded\n                logger.error(\n                    \"Failed to load %s in subprocess: %s \"\n                    \"[%.1f s; server %.1f]: %s\\n%s\",\n                    md.name or md.script,\n                    failure_result.ex_class,\n                    load_result.load_time,\n                    total_time(),\n                    failure_result.ex_message,\n                    (\n                        failure_result.traceback\n                        if failure_result.ex_class != \"FileNotFoundError\"\n                        else \"\"\n                    ),\n                )\n                if md.base_version == settings.DEFAULT_BASE_VERSION:\n                    md.base_version = \"unknown\"\n                yield md, LoadedIoc.from_errored_load(md, loaded)\n                continue\n\n            with time_context() as ctx:\n                loaded_ioc = apischema.deserialize(LoadedIoc, loaded)\n                logger.info(\n                    \"Child loaded %s%s in %.1f s, server deserialized in %.1f s\",\n                    md.name or md.script,\n                    \" from cache\" if load_result.cache_hit else \"\",\n                    load_result.load_time,\n                    ctx(),\n                )\n                yield md, loaded_ioc\n\n    logger.info(\n        \"Loaded %d startup scripts in %.1f s (wall time) with %d process(es)\",\n        total_files,\n        total_time(),\n        processes,\n    )\n    logger.info(\n        \"Child processes reported taking a total of %.1f \"\n        \"sec, the total time on %d process(es)\",\n        total_child_load_time,\n        processes,\n    )\n</code></pre>"},{"location":"lcls/","title":"LCLS","text":"<p>LCLS-specific whatrecord plugins and helpers.</p>"},{"location":"lcls/#whatrecord.iocmanager","title":"<code>whatrecord.iocmanager</code>","text":"<p>SLAC PCDS IocManager configuration file loading support.</p>"},{"location":"lcls/#whatrecord.iocmanager-functions","title":"Functions","text":""},{"location":"lcls/#whatrecord.iocmanager.find_stcmd","title":"<code>whatrecord.iocmanager.find_stcmd(directory: str, ioc_id: str) -&gt; str</code>","text":"<p>Find the startup script st.cmd for a given IOC.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/iocmanager.py</code> <pre><code>def find_stcmd(directory: str, ioc_id: str) -&gt; str:\n\"\"\"Find the startup script st.cmd for a given IOC.\"\"\"\n    if directory.startswith(\"ioc\"):\n        directory = os.path.join(EPICS_SITE_TOP, directory)\n\n    suffix = (\"iocBoot\", ioc_id, \"st.cmd\")\n    # Templated IOCs are... different:\n    options = [\n        os.path.join(directory, \"children\", \"build\", *suffix),\n        os.path.join(directory, \"build\", *suffix),\n        os.path.join(directory, *suffix),\n        os.path.join(directory, \"st.cmd\"),\n    ]\n\n    for option in options:\n        if os.path.exists(option):\n            return option\n\n    # Guess at what's correct:\n    return options[-1]\n</code></pre>"},{"location":"lcls/#whatrecord.iocmanager.get_iocs_from_configs","title":"<code>whatrecord.iocmanager.get_iocs_from_configs(configs: List[Union[str, pathlib.Path]], sorter: Optional[Callable[[IocInfoDict], Any]] = None) -&gt; List[IocInfoDict]</code>","text":"<p>Get IOC information in a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>list[str or Path]</code> <p>Configuration filenames to load.</p> required <code>sorter</code> <code>callable</code> <p>Sort IOCs with this, defaults to sorting by host name and then IOC name.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ioc_info</code> <code>list of IOC info dictionaries</code> <p>List of IOC info</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/iocmanager.py</code> <pre><code>def get_iocs_from_configs(\n    configs: List[Union[str, pathlib.Path]],\n    sorter: Optional[Callable[[IocInfoDict], Any]] = None\n) -&gt; List[IocInfoDict]:\n\"\"\"\n    Get IOC information in a list of dictionaries.\n\n    Parameters\n    ----------\n    configs : list[str or pathlib.Path]\n        Configuration filenames to load.\n    sorter : callable, optional\n        Sort IOCs with this, defaults to sorting by host name and then IOC name.\n\n    Returns\n    -------\n    ioc_info : list of IOC info dictionaries\n        List of IOC info\n    \"\"\"\n    configs = [\n        pathlib.Path(config).resolve()\n        for config in configs or []\n    ]\n\n    def default_sorter(ioc):\n        return (ioc[\"host\"], ioc[\"name\"])\n\n    iocs = (\n        ioc\n        for fn in set(configs)\n        for ioc in load_config_file(fn)\n    )\n\n    return list(sorted(iocs, key=sorter or default_sorter))\n</code></pre>"},{"location":"lcls/#whatrecord.iocmanager.load_config_file","title":"<code>whatrecord.iocmanager.load_config_file(fn: Union[str, pathlib.Path]) -&gt; List[IocInfoDict]</code>","text":"<p>Load a configuration file and return the IOCs it contains.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>str or Path</code> <p>The configuration filename</p> required <p>Returns:</p> Name Type Description <code>ioc_info</code> <code>list of IOC info dictionaries</code> <p>List of IOC info</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/iocmanager.py</code> <pre><code>def load_config_file(fn: Union[str, pathlib.Path]) -&gt; List[IocInfoDict]:\n\"\"\"\n    Load a configuration file and return the IOCs it contains.\n\n    Parameters\n    ----------\n    fn : str or pathlib.Path\n        The configuration filename\n\n    Returns\n    -------\n    ioc_info : list of IOC info dictionaries\n        List of IOC info\n    \"\"\"\n    with open(fn, \"rt\") as f:\n        lines = f.read().splitlines()\n\n    iocs = parse_config(lines)\n\n    for ioc in list(iocs):\n        # For now, assume old database syntax by specifying 3.15:\n        ioc[\"base_version\"] = \"3.15\"\n        if not validate_config_keys(ioc):\n            iocs.remove(ioc)\n        else:\n            # Add \"config_file\" and rename some keys:\n            ioc[\"config_file\"] = str(fn)\n            ioc[\"name\"] = ioc.pop(\"id\")\n            ioc[\"script\"] = find_stcmd(ioc[\"dir\"], ioc[\"name\"])\n            ioc[\"binary\"] = find_binary_from_hashbang(ioc[\"script\"])\n\n    return iocs\n</code></pre>"},{"location":"lcls/#whatrecord.iocmanager.parse_config","title":"<code>whatrecord.iocmanager.parse_config(lines: List[str]) -&gt; List[IocInfoDict]</code>","text":"<p>Parse an IOC manager config to get its IOCs.</p> <p>The parsing here is a bit weak when it comes to syntax errors. This is generally not a problem as these files are almost entirely written out by the IOC Manager GUI / CLI tools.  Occasionally, a user may edit the file manually and introduce syntax errors on certain lines, and this will attempt to skip it as best it can.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list of str</code> <p>List of raw configuration file lines.</p> required <p>Returns:</p> Name Type Description <code>ioc_info</code> <code>list of IOC info dictionaries</code> <p>List of IOC info</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/iocmanager.py</code> <pre><code>def parse_config(lines: List[str]) -&gt; List[IocInfoDict]:\n\"\"\"\n    Parse an IOC manager config to get its IOCs.\n\n    The parsing here is a bit weak when it comes to syntax errors. This is\n    generally not a problem as these files are almost entirely written out by\n    the IOC Manager GUI / CLI tools.  Occasionally, a user may edit the file\n    manually and introduce syntax errors on certain lines, and this will\n    attempt to skip it as best it can.\n\n    Parameters\n    ----------\n    lines : list of str\n        List of raw configuration file lines.\n\n    Returns\n    -------\n    ioc_info : list of IOC info dictionaries\n        List of IOC info\n    \"\"\"\n    entries = []\n    loading = False\n    entry = None\n\n    for line in lines:\n        if \"procmgr_config\" in line:\n            loading = True\n            continue\n        if not loading:\n            continue\n        if line.lstrip().startswith(\"#\"):\n            continue\n        if \"id:\" in line:\n            if \"}\" in line:\n                # {id: ... } in a single line\n                entries.append(line)\n            else:\n                # {id: ...\n                #  ... }\n                entry = line\n        elif entry is not None:\n            entry += line\n            if \"}\" in entry:\n                # {id: ...\n                #  ... }   &lt;-- closing line\n                entries.append(entry)\n                entry = None\n\n    def fix_entry(entry):\n        return ast.literal_eval(KEY_RE.sub(r'\"\\1\":', entry.strip(\", \\t\")))\n\n    result = []\n    for entry in entries:\n        try:\n            result.append(fix_entry(entry))\n        except Exception:\n            logger.error(\"Failed to fix up IOC manager entry: %s\", entry)\n\n    return result\n</code></pre>"},{"location":"lcls/#whatrecord.iocmanager.validate_config_keys","title":"<code>whatrecord.iocmanager.validate_config_keys(cfg: IocInfoDict) -&gt; bool</code>","text":"<p>Validate that a configuration has all required keys.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/iocmanager.py</code> <pre><code>def validate_config_keys(cfg: IocInfoDict) -&gt; bool:\n\"\"\"Validate that a configuration has all required keys.\"\"\"\n    return all(key in cfg and cfg[key] for key in REQUIRED_KEYS)\n</code></pre>"},{"location":"lcls/#whatrecord-iocmanager-loader","title":"<code>whatrecord iocmanager-loader</code>","text":"<p><code>whatrecord iocmanager-loader</code> is used to import IOC configuration information from SLAC PCDS IocManager-format configuration files.</p> <pre><code>usage: whatrecord iocmanager-loader [-h] configs [configs ...]\n\n\"whatrec iocmanager_loader\" is used to import IOC configuration information\nfrom SLAC PCDS IocManager-format configuration files.\n\npositional arguments:\n  configs     Configuration file location(s)\n\noptional arguments:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"lcls/#whatrecord.bin.iocmanager_loader","title":"<code>whatrecord.bin.iocmanager_loader</code>","text":"<p>\"whatrecord iocmanager-loader\" is used to import IOC configuration information from SLAC PCDS IocManager-format configuration files.</p>"},{"location":"lcls/#whatrecord.bin.iocmanager_loader-functions","title":"Functions","text":""},{"location":"lcls/#api","title":"API","text":""},{"location":"lcls/#whatrecord.plugins.epicsarch","title":"<code>whatrecord.plugins.epicsarch</code>","text":"<p>LCLS-specific epicsArch.txt plugin.</p>"},{"location":"lcls/#whatrecord.plugins.epicsarch-classes","title":"Classes","text":""},{"location":"lcls/#whatrecord.plugins.epicsarch.DaqPV","title":"<code>whatrecord.plugins.epicsarch.DaqPV</code>  <code>dataclass</code>","text":"<p>A single PV configured for storage in the DAQ/logbook.</p>"},{"location":"lcls/#whatrecord.plugins.epicsarch.LclsEpicsArchFile","title":"<code>whatrecord.plugins.epicsarch.LclsEpicsArchFile</code>  <code>dataclass</code>","text":"<p>Representation of an LCLS-specific DAQ recording epicsArch.txt file.</p>"},{"location":"lcls/#whatrecord.plugins.epicsarch.LclsEpicsArchFile-functions","title":"Functions","text":"<code>whatrecord.plugins.epicsarch.LclsEpicsArchFile.from_file(fn: AnyPath, context: Optional[FullLoadContext] = None) -&gt; LclsEpicsArchFile</code> <code>classmethod</code> <p>Load an epicsArch.txt file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path or str</code> <p>The filename.</p> required <p>Returns:</p> Name Type Description <code>file</code> <code>LclsEpicsArchFile</code> <p>The parsed file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/epicsarch.py</code> <pre><code>@classmethod\ndef from_file(\n    cls, fn: AnyPath,\n    context: Optional[FullLoadContext] = None,\n) -&gt; LclsEpicsArchFile:\n\"\"\"\n    Load an epicsArch.txt file.\n\n    Parameters\n    ----------\n    filename : pathlib.Path or str\n        The filename.\n\n    Returns\n    -------\n    file : LclsEpicsArchFile\n        The parsed file.\n    \"\"\"\n    with open(fn, \"rt\") as fp:\n        return cls.from_string(fp.read(), filename=fn, context=context)\n</code></pre> <code>whatrecord.plugins.epicsarch.LclsEpicsArchFile.from_file_obj(fp, filename: Optional[AnyPath] = None, context: Optional[FullLoadContext] = None) -&gt; LclsEpicsArchFile</code> <code>classmethod</code> <p>Load an epicsArch.txt file from a file object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/epicsarch.py</code> <pre><code>@classmethod\ndef from_file_obj(\n    cls, fp, filename: Optional[AnyPath] = None,\n    context: Optional[FullLoadContext] = None,\n) -&gt; LclsEpicsArchFile:\n\"\"\"Load an epicsArch.txt file from a file object.\"\"\"\n    return cls.from_string(\n        fp.read(),\n        filename=getattr(fp, \"name\", filename),\n        context=context,\n    )\n</code></pre> <code>whatrecord.plugins.epicsarch.LclsEpicsArchFile.from_string(contents: str, filename: Optional[AnyPath] = None, debug: bool = False, context: Optional[FullLoadContext] = None) -&gt; LclsEpicsArchFile</code> <code>classmethod</code> <p>Load an epicsArch.txt file given its string contents.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/epicsarch.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    contents: str,\n    filename: Optional[AnyPath] = None,\n    debug: bool = False,\n    context: Optional[FullLoadContext] = None,\n) -&gt; LclsEpicsArchFile:\n\"\"\"Load an epicsArch.txt file given its string contents.\"\"\"\n    if filename:\n        filename = pathlib.Path(filename).resolve()\n\n    grammar = lark.Lark.open_from_package(\n        \"whatrecord\",\n        \"lcls_epicsarch.lark\",\n        search_paths=(\"grammar\",),\n        parser=\"earley\",\n        propagate_positions=True,\n        debug=debug,\n    )\n\n    transformer_ = _EpicsArchTransformer(\n        cls, filename, contents, grammar, context=context\n    )\n    return transformer_.transform(grammar.parse(contents + \"\\n\"))\n</code></pre>"},{"location":"lcls/#whatrecord.plugins.epicsarch.Warning","title":"<code>whatrecord.plugins.epicsarch.Warning</code>  <code>dataclass</code>","text":"<p>epicsArch-format warning.</p>"},{"location":"lcls/#whatrecord.plugins.epicsarch-functions","title":"Functions","text":""},{"location":"lcls/#whatrecord.plugins.twincat_pytmc","title":"<code>whatrecord.plugins.twincat_pytmc</code>","text":"<p>TwinCAT / pytmc / blark whatrecord plugin</p> <p>Match your TwinCAT project symbols to EPICS records.</p> <p>Set <code>project</code> to generate metadata for one particular PLC project.</p> <p>Alternatively, the plugin will query WHATRECORD_SERVER for all IOCs and attempt to find ads-ioc-based IOCs with associated TwinCAT projects.</p> <p>To annotate library-level information in dependencies (i.e., to let users \"go to the source code of dependency-library-sourced symbols\"), be sure to set <code>BLARK_TWINCAT_ROOT</code> per blark's documentation.</p>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc-classes","title":"Classes","text":""},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.NCAxes","title":"<code>whatrecord.plugins.twincat_pytmc.NCAxes</code>  <code>dataclass</code>","text":"<p>Top-level NC axis information.</p>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.NCAxes-functions","title":"Functions","text":"<code>whatrecord.plugins.twincat_pytmc.NCAxes.from_project_filename(filename: pathlib.Path, loaded_files: Optional[Dict[str, str]] = None) -&gt; Optional[NCAxes]</code> <code>classmethod</code> <p>Create an NCAxes instance from a project filename.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>@classmethod\ndef from_project_filename(\n    cls,\n    filename: pathlib.Path,\n    loaded_files: Optional[Dict[str, str]] = None,\n) -&gt; Optional[NCAxes]:\n\"\"\"Create an NCAxes instance from a project filename.\"\"\"\n    project = pytmc.parser.parse(filename)\n    return cls.from_pytmc(project, loaded_files)\n</code></pre> <code>whatrecord.plugins.twincat_pytmc.NCAxes.from_pytmc(project: pytmc.parser.TwincatItem, loaded_files: Optional[Dict[str, str]] = None) -&gt; Optional[NCAxes]</code> <code>classmethod</code> <p>Create an NCAxes instance from a project filename.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>@classmethod\ndef from_pytmc(\n    cls,\n    project: pytmc.parser.TwincatItem,\n    loaded_files: Optional[Dict[str, str]] = None,\n) -&gt; Optional[NCAxes]:\n\"\"\"Create an NCAxes instance from a project filename.\"\"\"\n    try:\n        nc: pytmc.parser.NC = next(project.root.find(pytmc.parser.NC))\n    except StopIteration:\n        return None\n\n    nc_filename = _stringify_path(nc.filename)\n    nc = cls(\n        context=(LoadContext(nc_filename, 0), ),\n        filename=nc.filename,\n        hash=get_file_sha256(nc_filename),\n        axes=[NCAxis.from_pytmc(axis) for axis in nc.axes],\n    )\n\n    if loaded_files is not None:\n        loaded_files[_stringify_path(nc.filename)] = nc.hash\n        for axis in nc.axes:\n            loaded_files[_stringify_path(axis.filename)] = axis.hash\n\n    return nc\n</code></pre>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.NCAxis","title":"<code>whatrecord.plugins.twincat_pytmc.NCAxis</code>  <code>dataclass</code>","text":"<p>A single NC axis.</p>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.PlcMetadata","title":"<code>whatrecord.plugins.twincat_pytmc.PlcMetadata</code>  <code>dataclass</code>","text":"<p>             Bases: <code>InlineCached</code>, <code>PlcMetadataCacheKey</code></p> <p>This metadata is keyed on PlcMetadataCacheKey.</p>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.PlcMetadata-functions","title":"Functions","text":"<code>whatrecord.plugins.twincat_pytmc.PlcMetadata.from_blark(blark_md: blark.dependency_store.PlcProjectMetadata, tsproj: blark.solution.Project, include_dependencies: bool = True, use_cache: bool = True) -&gt; PlcMetadata</code> <code>classmethod</code> <p>Create a PlcMetadata instance from a pytmc-parsed one.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>@classmethod\ndef from_blark(\n    cls,\n    blark_md: blark.dependency_store.PlcProjectMetadata,\n    tsproj: blark.solution.Project,\n    include_dependencies: bool = True,\n    use_cache: bool = True,\n) -&gt; PlcMetadata:\n\"\"\"Create a PlcMetadata instance from a pytmc-parsed one.\"\"\"\n    loaded_files = {\n        _stringify_path(path): hash_\n        for path, hash_ in blark_md.loaded_files.items()\n    }\n\n    pytmc_md = PytmcMetadata.from_tsproj(\n        tsproj,\n        plc_name=blark_md.name,\n        loaded_files=loaded_files,\n    )\n\n    # TODO: blark - not capturing tsproj\n    if tsproj.local_path is not None:\n        loaded_files[_stringify_path(tsproj.local_path)] = get_file_sha256(\n            tsproj.local_path\n        )\n\n    plc_fn = _stringify_path(blark_md.filename)\n    if blark_md.plc is None or pytmc_md.tmc is None:\n        logger.debug(\n            \"%s (%s): No TMC file for symbols; skipping...\",\n            plc_fn,\n            blark_md.name,\n        )\n        return cls(\n            name=blark_md.name,\n            filename=plc_fn,\n            include_dependencies=include_dependencies,\n            context=(LoadContext(plc_fn, 0), ),\n            dependencies=blark_md.dependencies,\n            symbols={},\n            record_to_symbol={},\n            nc=None,\n            loaded_files=loaded_files,\n            tsproj=tsproj,\n            blark_md=blark_md,\n        )\n\n    if use_cache:\n        key = PlcMetadataCacheKey(\n            name=blark_md.name,\n            filename=plc_fn,\n            include_dependencies=include_dependencies,\n        )\n        cached = cls.from_cache(key)\n        if cached is not None:\n            if util.check_files_up_to_date(cached.loaded_files):\n                return cached\n\n    loaded_files[plc_fn] = util.get_file_sha256(plc_fn)\n\n    md = cls(\n        name=blark_md.plc.name or blark_md.name,\n        filename=plc_fn,\n        include_dependencies=include_dependencies,\n        context=(LoadContext(plc_fn, 0), ),\n        symbols={},\n        record_to_symbol={},\n        dependencies=blark_md.dependencies,\n        loaded_files=loaded_files,\n        nc=pytmc_md.nc,\n        tsproj=tsproj,\n        blark_md=blark_md,\n    )\n\n    def by_name(symbol):\n        return symbol.name\n\n    tmc = pytmc_md.tmc\n    for symbol in sorted(pytmc.pragmas.find_pytmc_symbols(tmc), key=by_name):\n        for symbol_md in get_symbol_metadata(blark_md, symbol):\n            md.symbols[symbol_md.name] = symbol_md\n            for record in symbol_md.records:\n                md.record_to_symbol[record] = symbol_md.name\n\n    logger.debug(\n        \"PLC %s: Found %d symbols which generated metadata -&gt; %d records\",\n        blark_md.plc.name,\n        len(md.symbols),\n        len(md.record_to_symbol),\n    )\n    if use_cache:\n        md.save_to_cache()\n\n    return md\n</code></pre> <code>whatrecord.plugins.twincat_pytmc.PlcMetadata.from_project_filename(project: AnyPath, include_dependencies: bool = True, plc_whitelist: Optional[List[str]] = None, loaded_files: Optional[Dict[str, str]] = None, use_cache: bool = True) -&gt; Generator[PlcMetadata, None, None]</code> <code>classmethod</code> <p>Given a project/solution filename, get all PlcMetadata.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>@classmethod\ndef from_project_filename(\n    cls,\n    project: AnyPath,\n    include_dependencies: bool = True,\n    plc_whitelist: Optional[List[str]] = None,\n    loaded_files: Optional[Dict[str, str]] = None,\n    use_cache: bool = True,\n) -&gt; Generator[PlcMetadata, None, None]:\n\"\"\"Given a project/solution filename, get all PlcMetadata.\"\"\"\n    if loaded_files is None:\n        loaded_files = {}\n    solution = blark.solution.make_solution_from_files(project)\n    logger.debug(\n        \"Solution path %s projects %s\", solution.filename, solution.projects\n    )\n    for tsproj_project in solution.projects:\n        logger.debug(\"Found tsproj %s\", tsproj_project.name)\n        try:\n            parsed_tsproj = tsproj_project.load()\n        except Exception:\n            logger.exception(\"Failed to load project %s\", tsproj_project.name)\n            continue\n\n        for plc_name, plc in parsed_tsproj.plcs_by_name.items():\n            if plc_whitelist and plc_name not in plc_whitelist:\n                continue\n\n            logger.debug(\"Found PLC project %s\", plc_name)\n            plc_md = blark.dependency_store.PlcProjectMetadata.from_plcproject(\n                plc,\n                include_dependencies=include_dependencies,\n            )\n            if plc_md is None:\n                continue\n\n            logger.debug(\n                \"tsproj %s: Found plc project %s from %s\",\n                tsproj_project.name,\n                plc_md.name,\n                plc_md.filename,\n            )\n            yield cls.from_blark(\n                blark_md=plc_md,\n                tsproj=tsproj_project,\n                include_dependencies=include_dependencies,\n                use_cache=use_cache,\n            )\n</code></pre>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.PlcMetadataCacheKey","title":"<code>whatrecord.plugins.twincat_pytmc.PlcMetadataCacheKey</code>  <code>dataclass</code>","text":"<p>             Bases: <code>CacheKey</code></p> <p>These attributes define a PlcMetadata cache item.</p> <p>The PLC name and filename will be used as a cache key; however, additional checks will be made to see that the files have not changed on disk since the last save.</p>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc-functions","title":"Functions","text":""},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.get_ioc_makefile","title":"<code>whatrecord.plugins.twincat_pytmc.get_ioc_makefile(md: IocMetadata) -&gt; Tuple[str, str, pathlib.Path]</code>","text":"<p>Get the IOC Makefile contents, if available.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>def get_ioc_makefile(md: IocMetadata) -&gt; Tuple[str, str, pathlib.Path]:\n\"\"\"Get the IOC Makefile contents, if available.\"\"\"\n    makefile_path = (md.script.parent / \"Makefile\").resolve()\n    sha, contents = read_text_file_with_hash(makefile_path)\n    return sha, contents, makefile_path\n</code></pre>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.get_project_from_ioc","title":"<code>whatrecord.plugins.twincat_pytmc.get_project_from_ioc(md: IocMetadata, makefile: str) -&gt; Optional[Tuple[pathlib.Path, str]]</code>","text":"<p>Get the TwinCAT Project from a provided ads-ioc IocMetadata and Makefile contents.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>def get_project_from_ioc(md: IocMetadata, makefile: str) -&gt; Optional[Tuple[pathlib.Path, str]]:\n\"\"\"Get the TwinCAT Project from a provided ads-ioc IocMetadata and Makefile contents.\"\"\"\n    variables = dict(MAKEFILE_VAR_RE.findall(makefile))\n    logger.debug(\"IOC: %s Makefile variables: %s\", md.name, variables)\n    try:\n        plc_name = variables[\"PLC\"]\n        project_path = variables[\"PROJECT_PATH\"]\n    except KeyError:\n        return None\n\n    project_path = (md.script.parent / project_path).resolve()\n    if not project_path.exists():\n        logger.debug(\"Project path doesn't exist: %s\", project_path)\n        return\n\n    return project_path, plc_name\n</code></pre>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.get_symbol_metadata","title":"<code>whatrecord.plugins.twincat_pytmc.get_symbol_metadata(blark_md: blark.dependency_store.PlcMetadata, symbol: pytmc.parser.Symbol, require_records: bool = True, add_project_prefix: bool = True) -&gt; Generator[PlcSymbolMetadata, None, None]</code>","text":"<p>Get symbol metadata given a pytmc Symbol.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>def get_symbol_metadata(\n    blark_md: blark.dependency_store.PlcMetadata,\n    symbol: pytmc.parser.Symbol,\n    require_records: bool = True,\n    add_project_prefix: bool = True,\n) -&gt; Generator[PlcSymbolMetadata, None, None]:\n\"\"\"Get symbol metadata given a pytmc Symbol.\"\"\"\n    symbol_type_name = symbol.data_type.qualified_type_name\n    for pkg in pytmc.pragmas.record_packages_from_symbol(\n        symbol,\n        yield_exceptions=True,\n        allow_no_pragma=False,\n    ):\n        if isinstance(pkg, Exception):\n            # Eat these up rather than raising\n            continue\n        # context = get_symbol_context(symbol.data_type.name, pkg.tcname)\n        path = blark_md.summary.find_path(pkg.tcname)\n        if not path:\n            # Can't find the declaration in the code, somehow\n            continue\n\n        records = [record.pvname for record in pkg.records]\n        if records or not require_records:\n            annotated_name = pkg.tcname\n            if add_project_prefix:\n                annotated_name = f\"{blark_md.name}:{annotated_name}\"\n\n            try:\n                chain_type_name = pkg.chain.data_type.qualified_type_name\n            except AttributeError:\n                chain_type_name = \"unknown\"\n\n            if symbol_type_name == chain_type_name:\n                type_name = symbol_type_name\n            else:\n                type_name = f\"{chain_type_name} ({symbol_type_name})\"\n\n            yield PlcSymbolMetadata(\n                context=load_context_from_path(path),\n                name=annotated_name,\n                records=records,\n                type=type_name,\n            )\n</code></pre>"},{"location":"lcls/#whatrecord.plugins.twincat_pytmc.load_context_from_path","title":"<code>whatrecord.plugins.twincat_pytmc.load_context_from_path(path: List[blark.summary.Summary]) -&gt; FullLoadContext</code>","text":"<p>Get a FullLoadContext from a blark variable path.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/twincat_pytmc.py</code> <pre><code>def load_context_from_path(path: List[blark.summary.Summary]) -&gt; FullLoadContext:\n\"\"\"Get a FullLoadContext from a blark variable path.\"\"\"\n    result = []\n    saw_files = set()\n    for file, line in reversed(blark.summary.path_to_file_and_line(path)):\n        file = str(file)\n        if file not in saw_files:\n            result.append(LoadContext(str(file), line))\n            saw_files.add(file)\n\n    return tuple(result[::-1])\n</code></pre>"},{"location":"parsers/","title":"Parsers","text":""},{"location":"parsers/#usage","title":"Usage","text":"<p>For each of the parser classes:</p> <ul> <li>AccessSecurityConfig</li> <li>Database</li> <li>GatewayPVList</li> <li>LclsEpicsArchFile</li> <li>SequencerProgram</li> <li>StreamProtocol</li> <li>TemplateSubstitution</li> </ul> <p>Data can be loaded from a file, file object, or string. Filename information will be automatically added to the load context information when available, but may be specified separately in the latter case.</p> <p>Taking AccessSecurityConfig for example:</p> <pre><code>from whatrecord import AccessSecurityConfig\n\n# 1. Load from a file directly\nconfig = AccessSecurityConfig.from_file(\"filename.acf\")\n\n# 2. Load from a file object\nwith open(\"filename.acf\", \"rt\") as fp:\n    config = AccessSecurityConfig.from_file_obj(fp)\n\n# 3. Load from a string:\nwith open(\"filename.acf\", \"rt\") as fp:\n    contents = fp.read()\n\nconfig = AccessSecurityConfig.from_string(contents, filename=\"filename.acf\")\n</code></pre>"},{"location":"parsers/#api","title":"API","text":""},{"location":"parsers/#whatrecord.access_security","title":"<code>whatrecord.access_security</code>","text":"<p>V3 Access Security file parsing.</p> <p>Documentation from the application developer's guide are interspersed here and in the classes below.</p> <pre><code>A brief summary of the Functional Requirements is:\n    * Each field of each record type is assigned an access security level.\n    * Each record instance is assigned to a unique access security group.\n    * Each user is assigned to one or more user access groups.\n    * Each node is assigned to a host access group.\n\nFor each access security group a set of access rules can be defined. Each rule\nspecifies:\n    -  Access security level\n    -  READ or READ/WRITE access.\n    -  An optional list of User Access Groups or * meaning anyone.\n    -  An optional list of Host Access Groups or * meaning anywhere.\n    -  Conditions based on values of process variables\n</code></pre>"},{"location":"parsers/#whatrecord.access_security-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.access_security.AccessSecurityConfig","title":"<code>whatrecord.access_security.AccessSecurityConfig</code>  <code>dataclass</code>","text":"<p>An Access Security Configuration file (ACF) container.</p>"},{"location":"parsers/#whatrecord.access_security.AccessSecurityConfig-functions","title":"Functions","text":"<code>whatrecord.access_security.AccessSecurityConfig.from_file(fn: Union[str, pathlib.Path]) -&gt; AccessSecurityConfig</code> <code>classmethod</code> <p>Load an ACF file from a filename.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/access_security.py</code> <pre><code>@classmethod\ndef from_file(cls, fn: Union[str, pathlib.Path]) -&gt; AccessSecurityConfig:\n\"\"\"Load an ACF file from a filename.\"\"\"\n    with open(fn, \"rt\") as fp:\n        return cls.from_file_obj(fp, filename=str(fn))\n</code></pre> <code>whatrecord.access_security.AccessSecurityConfig.from_file_obj(fp, filename: Optional[str] = None) -&gt; AccessSecurityConfig</code> <code>classmethod</code> <p>Load an ACF file from a file object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/access_security.py</code> <pre><code>@classmethod\ndef from_file_obj(cls, fp, filename: Optional[str] = None) -&gt; AccessSecurityConfig:\n\"\"\"Load an ACF file from a file object.\"\"\"\n    filename = filename or getattr(fp, \"name\", str(id(fp)))\n    return cls.from_string(fp.read(), filename=filename)\n</code></pre> <code>whatrecord.access_security.AccessSecurityConfig.from_string(contents: str, filename: Optional[str] = None) -&gt; AccessSecurityConfig</code> <code>classmethod</code> <p>Load access security configuration from a string.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>The access security file contents.</p> required <p>filename : str, optional     The access security filename to use for LoadContext.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/access_security.py</code> <pre><code>@classmethod\ndef from_string(cls, contents: str, filename: Optional[str] = None) -&gt; AccessSecurityConfig:\n\"\"\"\n    Load access security configuration from a string.\n\n    Parameters\n    ----------\n    contents : str\n        The access security file contents.\n\n    filename : str, optional\n        The access security filename to use for LoadContext.\n    \"\"\"\n    contents_hash = get_bytes_sha256(contents.encode(\"utf-8\"))\n    comments = []\n\n    def add_comment(comment: lark.Token):\n        comments.append(\n            StringWithContext(\n                str(comment).lstrip(\"# \"),\n                context=context_from_lark_token(filename, comment),\n            )\n        )\n\n    grammar = lark.Lark.open_from_package(\n        \"whatrecord\",\n        \"access_security.lark\",\n        search_paths=(\"grammar\", ),\n        parser=\"lalr\",\n        lexer_callbacks={\"COMMENT\": add_comment},\n        transformer=_AcfTransformer(filename, contents_hash, comments),\n        maybe_placeholders=False,\n    )\n\n    return grammar.parse(contents)\n</code></pre> <code>whatrecord.access_security.AccessSecurityConfig.get_group_from_record(record: RecordInstance) -&gt; Optional[AccessSecurityGroup]</code> <p>Get the appropriate access security group for the given record.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/access_security.py</code> <pre><code>def get_group_from_record(self, record: RecordInstance) -&gt; Optional[AccessSecurityGroup]:\n\"\"\"Get the appropriate access security group for the given record.\"\"\"\n    if record.is_pva:\n        return\n\n    return self.groups.get(record.access_security_group, None)\n</code></pre>"},{"location":"parsers/#whatrecord.access_security.AccessSecurityGroup","title":"<code>whatrecord.access_security.AccessSecurityGroup</code>  <code>dataclass</code>","text":"<p>An access security group.</p>"},{"location":"parsers/#whatrecord.access_security.AccessSecurityRule","title":"<code>whatrecord.access_security.AccessSecurityRule</code>  <code>dataclass</code>","text":"<p>Access Security Configuration rule, which defines access permissions.</p> <p> must be 0 or 1. Permission for a level 1 field implies permission for level 0 fields. <p>The permissions are NONE, READ, and WRITE. WRITE permission implies READ permission. The standard EPICS record types have all fields set to level 1 except for VAL, CMD (command), and RES (reset). An optional argument specifies if writes should be trapped. See the section below on trapping Channel Access writes for how this is used. If not given the default is NOTRAPWRITE.</p> <p>UAG specifies a list of user access groups that can have the access privilege. If UAG is not defined then all users are allowed.</p> <p>HAG specifies a list of host access groups that have the access privilege. If HAG is not defined then all hosts are allowed.</p> <p>CALC is just like the CALC field of a calculation record except that the result must evaluate to TRUE or FALSE. The rule only applies if the calculation result is TRUE, where the actual test for TRUE is (0.99 &lt; result &lt; 1.01).</p> <p>Anything else is regarded as FALSE and will cause the rule to be ignored. Assignment statements are not permitted in CALC expressions here.</p>"},{"location":"parsers/#whatrecord.access_security.AccessSecurityState","title":"<code>whatrecord.access_security.AccessSecurityState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ShellStateHandler</code></p> <p>Access Security IOC shell state handler / container.</p> <p>Contains hooks for as-related commands and state information.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>AccessSecurityState</code> <p>The access security configuration.</p> <code>filename</code> <code>Path</code> <p>The access security filename.</p> <code>macros</code> <code>Dict[str, str]</code> <p>Macros used when expanding the access security file.</p>"},{"location":"parsers/#whatrecord.access_security.AccessSecurityState-functions","title":"Functions","text":"<code>whatrecord.access_security.AccessSecurityState.annotate_record(record: RecordInstance) -&gt; Optional[Dict[str, Any]]</code> <p>Annotate record with access security information.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/access_security.py</code> <pre><code>def annotate_record(self, record: RecordInstance) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Annotate record with access security information.\"\"\"\n    if self.config is not None:\n        asg = self.config.get_group_from_record(record)\n        if asg is not None:\n            return apischema.serialize(asg)\n</code></pre>"},{"location":"parsers/#whatrecord.access_security.HostAccessGroup","title":"<code>whatrecord.access_security.HostAccessGroup</code>  <code>dataclass</code>","text":"<p>Host Access Group.</p> <p>This is a list of host names. It may be empty. The same host name can appear in multiple HAGs. To match, a host name must match the host name read by the CA client library running on the client machine; both names are converted to lower case before comparison however. For vxWorks clients, the host name is usually taken from the target name of the boot parameters.</p>"},{"location":"parsers/#whatrecord.access_security.UserAccessGroup","title":"<code>whatrecord.access_security.UserAccessGroup</code>  <code>dataclass</code>","text":"<p>User Access Group.</p> <p>This is a list of user names. The list may be empty. A user name may appear in more than one UAG. To match, a user name must be identical to the user name read by the CA client library running on the client machine. For vxWorks clients, the user name is usually taken from the user field of the boot parameters.</p>"},{"location":"parsers/#whatrecord.access_security-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.autosave","title":"<code>whatrecord.autosave</code>","text":""},{"location":"parsers/#whatrecord.autosave-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.autosave.AutosaveRestoreFile","title":"<code>whatrecord.autosave.AutosaveRestoreFile</code>  <code>dataclass</code>","text":"<p>Representation of an autosave restore (.sav) file.</p>"},{"location":"parsers/#whatrecord.autosave.AutosaveRestoreFile-functions","title":"Functions","text":"<code>whatrecord.autosave.AutosaveRestoreFile.from_file(filename: AnyPath, macros: Optional[Dict[str, str]] = None) -&gt; AutosaveRestoreFile</code> <code>classmethod</code> <p>Load an autosave restore (.sav) file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path or str</code> <p>The filename.</p> required <p>Returns:</p> Name Type Description <code>file</code> <code>AutosaveRestoreFile</code> <p>The resulting parsed file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@classmethod\ndef from_file(\n    cls, filename: AnyPath, macros: Optional[Dict[str, str]] = None\n) -&gt; AutosaveRestoreFile:\n\"\"\"\n    Load an autosave restore (.sav) file.\n\n    Parameters\n    ----------\n    filename : pathlib.Path or str\n        The filename.\n\n    Returns\n    -------\n    file : AutosaveRestoreFile\n        The resulting parsed file.\n    \"\"\"\n    with open(filename, \"rt\") as fp:\n        return cls.from_string(fp.read(), filename=filename, macros=macros)\n</code></pre> <code>whatrecord.autosave.AutosaveRestoreFile.from_file_obj(fp, filename: AnyPath, macros: Optional[Dict[str, str]] = None) -&gt; AutosaveRestoreFile</code> <code>classmethod</code> <p>Load an autosave file given a file object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@classmethod\ndef from_file_obj(\n    cls, fp, filename: AnyPath, macros: Optional[Dict[str, str]] = None\n) -&gt; AutosaveRestoreFile:\n\"\"\"Load an autosave file given a file object.\"\"\"\n    return cls.from_string(\n        fp.read(),\n        filename=getattr(fp, \"name\", filename),\n        macros=macros,\n    )\n</code></pre> <code>whatrecord.autosave.AutosaveRestoreFile.from_string(contents: str, filename: AnyPath = '', macros: Optional[Dict[str, str]] = None) -&gt; AutosaveRestoreFile</code> <code>classmethod</code> <p>Load an autosave file given its string contents.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    contents: str,\n    filename: AnyPath = \"\",\n    macros: Optional[Dict[str, str]] = None\n) -&gt; AutosaveRestoreFile:\n\"\"\"Load an autosave file given its string contents.\"\"\"\n    grammar = lark.Lark.open_from_package(\n        \"whatrecord\",\n        \"autosave_save.lark\",\n        search_paths=(\"grammar\", ),\n        parser=\"earley\",\n        maybe_placeholders=False,\n        propagate_positions=True,\n    )\n\n    if macros:\n        contents = MacroContext(macros=macros).expand_by_line(contents)\n\n    return _AutosaveRestoreTransformer(cls, filename).transform(\n        grammar.parse(contents)\n    )\n</code></pre>"},{"location":"parsers/#whatrecord.autosave.AutosaveRestorePassFile","title":"<code>whatrecord.autosave.AutosaveRestorePassFile</code>  <code>dataclass</code>","text":""},{"location":"parsers/#whatrecord.autosave.AutosaveRestorePassFile-functions","title":"Functions","text":"<code>whatrecord.autosave.AutosaveRestorePassFile.update(save_path: pathlib.Path) -&gt; AutosaveRestoreFile</code> <p>Update the autosave .sav file from disk.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>def update(self, save_path: pathlib.Path) -&gt; AutosaveRestoreFile:\n\"\"\"Update the autosave .sav file from disk.\"\"\"\n    fn = save_path / self.save_filename\n    file_timestamp = datetime.datetime.fromtimestamp(fn.stat().st_mtime)\n    if self.file_timestamp is not None and file_timestamp == self.file_timestamp:\n        if self.data is not None:\n            return self.data\n\n    if self.load_timestamp is not None and self.data is not None:\n        dt = datetime.datetime.now() - self.load_timestamp\n        if dt.total_seconds() &lt; settings.AUTOSAVE_RELOAD_PERIOD:\n            return self.data\n\n    self.file_timestamp = file_timestamp\n    self.load_timestamp = datetime.datetime.now()\n    self.data = AutosaveRestoreFile.from_file(\n        fn,\n        macros=self.macros,\n    )\n    return self.data\n</code></pre>"},{"location":"parsers/#whatrecord.autosave.AutosaveState","title":"<code>whatrecord.autosave.AutosaveState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ShellStateHandler</code></p> <p>The state of autosave in an IOC.</p>"},{"location":"parsers/#whatrecord.autosave.AutosaveState-attributes","title":"Attributes","text":"<code>whatrecord.autosave.AutosaveState.save_name_pv: Optional[str]</code> <code>property</code> <p>The save name PV, derived from the macro context.</p> <code>whatrecord.autosave.AutosaveState.save_path_pv: Optional[str]</code> <code>property</code> <p>The save path PV, derived from the macro context.</p>"},{"location":"parsers/#whatrecord.autosave.AutosaveState-functions","title":"Functions","text":"<code>whatrecord.autosave.AutosaveState.handle_appendToFile(filename: str = '', line: str = '')</code> <p>Append line to a file.</p> <p>For example, to add a line to built_settings.req yourself:</p> <p>appendToFile(\"built_settings.req\", '$(P)userStringSeqEnable')</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_appendToFile(self, filename: str = \"\", line: str = \"\"):\n\"\"\"\n    Append line to a file.\n\n    For example, to add a line to built_settings.req yourself:\n\n    appendToFile(\"built_settings.req\", '$(P)userStringSeqEnable')\n    \"\"\"\n    ...\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_asVerify(filename: str = '', verbose: int = 0, restoreFileName: str = '', *_: str)</code> <p>Compare PV values in the IOC with values written in filename (which should be an autosave restore file, or at least look like one). If restoreFileName is not empty, write a new restore file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_asVerify(\n    self, filename: str = \"\", verbose: int = 0, restoreFileName: str = \"\", *_\n):\n\"\"\"\n    Compare PV values in the IOC with values written in filename\n    (which should be an autosave restore file, or at least look like one).\n    If restoreFileName is not empty, write a new restore file.\n    \"\"\"\n    ...\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_autosaveBuild(filename: str = '', reqFileSuffix: str = '', on: int = 0, *_: int)</code> <p>It's tedious and error prone to have these entries separately maintained, so autosave can do the request-file part for you. To do this, you tell autosave to arrange to be called whenever dbLoadRecords() is called (note that dbLoadTemplate() calls dbLoadRecords()), you tell it how to make a request-file name from a database-file name, and you give it the name of the request file you want it to build. You can do this with the following command:</p> <pre><code>autosaveBuild(\"built_settings.req\", \"_settings.req\", 1)\n</code></pre> <p>This tells autosave to do the following:</p> <pre><code>1. Begin building the file built_settings.req. If this is the first\n   call that mentions built_settings.req, erase the file.\n2. Generate request-file names by stripping \".db\", or \".vdb\", or\n   \".template\" from database-file names, and adding the suffix\n   \"_settings.req\".\n3. Enable (disable) automated building if the third argument is 1\n   (0).\n</code></pre> <p>While automated building is enabled, autosave will generate request-file names and search for those files in its request-file path. If it finds a request file, it will add the appropriate line to built_settings.req.</p> <p>All this does is get the file built_settings.req built. If you want it to be used, you must add the following line to auto_settings.req:</p> <pre><code>file built_settings.req P=$(P)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_autosaveBuild(\n    self, filename: str = \"\", reqFileSuffix: str = \"\", on: int = 0, *_\n):\n\"\"\"\n    It's tedious and error prone to have these entries separately\n    maintained, so autosave can do the request-file part for you. To do\n    this, you tell autosave to arrange to be called whenever\n    dbLoadRecords() is called\n    (note that dbLoadTemplate() calls dbLoadRecords()), you tell it how to\n    make a request-file name from a database-file name, and you give it the\n    name of the request file you want it to build. You can do this with the\n    following command:\n\n        autosaveBuild(\"built_settings.req\", \"_settings.req\", 1)\n\n    This tells autosave to do the following:\n\n        1. Begin building the file built_settings.req. If this is the first\n           call that mentions built_settings.req, erase the file.\n        2. Generate request-file names by stripping \".db\", or \".vdb\", or\n           \".template\" from database-file names, and adding the suffix\n           \"_settings.req\".\n        3. Enable (disable) automated building if the third argument is 1\n           (0).\n\n    While automated building is enabled, autosave will generate\n    request-file names and search for those files in its request-file path.\n    If it finds a request file, it will add the appropriate line to\n    built_settings.req.\n\n    All this does is get the file built_settings.req built. If you want it\n    to be used, you must add the following line to auto_settings.req:\n\n        file built_settings.req P=$(P)\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_create_manual_set(filename: str = '', macro_string: str = '')</code> <p>Create a save set for the request file. The save file will be written when the function manual_save() is called with the same request-file name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_create_manual_set(self, filename: str = \"\", macro_string: str = \"\"):\n\"\"\"\n    Create a save set for the request file. The save file will be written\n    when the function manual_save() is called with the same request-file\n    name.\n    \"\"\"\n    self.sets[filename] = AutosaveSet(\n        context=self.get_load_context(),\n        request_filename=filename,\n        save_filename=\"{}.sav\".format(pathlib.Path(filename).stem),\n        period=None,\n        trigger_channel=None,\n        macros=macros_from_string(macro_string),\n        method=\"manual\",\n    )\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_create_monitor_set(filename: Optional[str] = None, period: int = 0, macro_string: str = '', *_: str)</code> <p>Create a save set for the request file. The save file will be written every period seconds, if any PV in the save set was posted (changed value) since the last write.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_create_monitor_set(\n    self, filename: Optional[str] = None, period: int = 0, macro_string: str = \"\", *_\n):\n\"\"\"\n    Create a save set for the request file. The save file will be written\n    every period seconds, if any PV in the save set was posted\n    (changed value) since the last write.\n    \"\"\"\n    if filename is None:\n        # An indicator to \"start the save task\"\n        return\n\n    self.sets[filename] = AutosaveSet(\n        context=self.get_load_context(),\n        request_filename=filename,\n        save_filename=\"{}.sav\".format(pathlib.Path(filename).stem),\n        period=int(period),\n        trigger_channel=None,\n        macros=macros_from_string(macro_string),\n        method=\"monitor\",\n    )\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_create_periodic_set(filename: str = '', period: int = 0, macro_string: str = '', *_: str)</code> <p>Create a save set for the request file. The save file will be written every period seconds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_create_periodic_set(\n    self, filename: str = \"\", period: int = 0, macro_string: str = \"\", *_\n):\n\"\"\"\n    Create a save set for the request file. The save file will be written\n    every period seconds.\n    \"\"\"\n    self.sets[filename] = AutosaveSet(\n        context=self.get_load_context(),\n        request_filename=filename,\n        save_filename=\"{}.sav\".format(pathlib.Path(filename).stem),\n        period=period,\n        trigger_channel=None,\n        macros=macros_from_string(macro_string),\n        method=\"periodic\",\n    )\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_create_triggered_set(filename: str = '', trigger_channel: str = '', macro_string: str = '', *_: str)</code> <p>Create a save set for the request file. The save file will be written whenever the PV specified by trigger_channel is posted. Normally this occurs when the PV's value changes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_create_triggered_set(\n    self, filename: str = \"\", trigger_channel: str = \"\", macro_string: str = \"\", *_\n):\n\"\"\"\n    Create a save set for the request file. The save file will be written\n    whenever the PV specified by trigger_channel is posted. Normally this\n    occurs when the PV's value changes.\n    \"\"\"\n    self.sets[filename] = AutosaveSet(\n        context=self.get_load_context(),\n        request_filename=filename,\n        save_filename=\"{}.sav\".format(pathlib.Path(filename).stem),\n        period=None,\n        trigger_channel=trigger_channel,\n        macros=macros_from_string(macro_string),\n        method=\"triggered\",\n    )\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_dbrestoreShow()</code> <p>List all the save sets currently being managed by the save_restore task. If (verbose != 0), lists the PV's as well.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_dbrestoreShow(self):\n\"\"\"\n    List all the save sets currently being managed by the save_restore\n    task. If (verbose != 0), lists the PV's as well.\n    \"\"\"\n    ...\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_eraseFile(filename: str = '')</code> <p>Erase (empty) an autosave file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_eraseFile(self, filename: str = \"\"):\n\"\"\"Erase (empty) an autosave file.\"\"\"\n    ...\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_fdbrestore(filename: str = '')</code> <p>If save_file refers to a save set that exists in memory, then PV's in the save set will be restored from values in memory. Otherwise, this functions restores the PV's in / and creates a new backup file \"/.bu\". The effect probably will not be the same as a boot-time restore, because caput() calls are used instead of static database access dbPutX() calls. Record processing will result from caput()'s to inherently process- passive fields. Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_fdbrestore(self, filename: str = \"\"):\n\"\"\"\n    If save_file refers to a save set that exists in memory, then PV's in\n    the save set will be restored from values in memory. Otherwise, this\n    functions restores the PV's in &lt;saveRestorePath&gt;/&lt;save_file&gt; and\n    creates a new backup file \"&lt;saveRestorePath&gt;/&lt;save_file&gt;.bu\". The\n    effect probably will not be the same as a boot-time restore, because\n    caput() calls are used instead of static database access dbPutX()\n    calls. Record processing will result from caput()'s to inherently\n    process- passive fields.\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_fdbrestoreX(filename = '', macrostring = '')</code> <p>This function restores from the file /, which can look just like a save file, but which needn't end with . No backup file will be written. The effect probably will not be the same as a boot-time restore, because caput() calls are used instead of static database access dbPut*() calls. Record processing will result from caput()'s to inherently process-passive fields. Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_fdbrestoreX(self, filename=\"\", macrostring=\"\"):\n\"\"\"\n    This function restores from the file &lt;saveRestorePath&gt;/&lt;save_file&gt;,\n    which can look just like a save file, but which needn't end with &lt;END&gt;.\n    No backup file will be written. The effect probably will not be the\n    same as a boot-time restore, because caput() calls are used instead of\n    static database access dbPut*() calls. Record processing will result\n    from caput()'s to inherently process-passive fields.\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_makeAutosaveFileFromDbInfo(filename: str = '', info_name: str = '', *_: str)</code> <p>Search through the EPICS database (that is, all EPICS records loaded into an IOC) for 'info' nodes named info_name; construct a list of PV names from the associated info_values found, and write the PV names to the file fileBaseName. If fileBaseName does not contain the string '.req', this string will be appended to it. See makeAutosaveFiles() for more information.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_makeAutosaveFileFromDbInfo(\n    self, filename: str = \"\", info_name: str = \"\", *_\n):\n\"\"\"\n    Search through the EPICS database\n    (that is, all EPICS records loaded into an IOC) for 'info' nodes named\n    info_name; construct a list of PV names from the associated info_values\n    found, and write the PV names to the file fileBaseName. If fileBaseName\n    does not contain the string '.req', this string will be appended to it.\n    See makeAutosaveFiles() for more information.\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_makeAutosaveFiles()</code> <p>Search through the EPICS database (that is, all EPICS records loaded into an IOC) for info nodes named 'autosaveFields' and 'autosaveFields_pass0'; construct lists of PV names from the associated info values, and write the PV names to the files 'info_settings.req' and 'info_positions.req', respectively.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_makeAutosaveFiles(self):\n\"\"\"\n    Search through the EPICS database\n    (that is, all EPICS records loaded into an IOC) for info nodes named\n    'autosaveFields' and 'autosaveFields_pass0'; construct lists of PV\n    names from the associated info values, and write the PV names to the\n    files 'info_settings.req' and 'info_positions.req', respectively.\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_manual_save(request_file: str = '')</code> <p>Cause current PV values for the request file to be saved. Any request file named in a create_xxx_set() command can be saved manually.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_manual_save(self, request_file: str = \"\"):\n\"\"\"\n    Cause current PV values for the request file to be saved. Any request\n    file named in a create_xxx_set() command can be saved manually.\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_reload_manual_set(filename: str = '', macrostring: str = '')</code> <p>This function allows you to change the PV's associated with a save set created by create_manual_set().</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_reload_manual_set(self, filename: str = \"\", macrostring: str = \"\"):\n\"\"\"\n    This function allows you to change the PV's associated with a save set\n    created by create_manual_set().\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_reload_monitor_set(filename: str = '', period: int = 0, macro_string: str = '', *_: str)</code> <p>This function allows you to change the PV's and the period associated with a save set created by create_monitor_set().</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_reload_monitor_set(\n    self, filename: str = \"\", period: int = 0, macro_string: str = \"\", *_\n):\n\"\"\"\n    This function allows you to change the PV's and the period associated\n    with a save set created by create_monitor_set().\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_reload_periodic_set(filename: str = '', period: int = 0, macro_string: str = '', *_: str)</code> <p>This function allows you to change the PV's and the period associated with a save set created by create_periodic_set().</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_reload_periodic_set(\n    self, filename: str = \"\", period: int = 0, macro_string: str = \"\", *_\n):\n\"\"\"\n    This function allows you to change the PV's and the period associated\n    with a save set created by create_periodic_set().\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_reload_triggered_set(filename: str = '', trigger_channel: str = '', macro_string: str = '', *_: str)</code> <p>This function allows you to change the PV's and the trigger channel associated with a save set created by create_triggered_set().</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_reload_triggered_set(\n    self, filename: str = \"\", trigger_channel: str = \"\", macro_string: str = \"\", *_\n):\n\"\"\"\n    This function allows you to change the PV's and the trigger channel\n    associated with a save set created by create_triggered_set().\n    \"\"\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_remove_data_set(filename: str = '')</code> <p>If a save set has been created for request_file, this function will delete it.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_remove_data_set(self, filename: str = \"\"):\n\"\"\"If a save set has been created for request_file, this function will delete it.\"\"\"\n    ...\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_CAReconnect(ok: int = 0)</code> <p>Specify whether autosave should periodically retry connecting to PVs whose initial connection attempt failed. Currently, the connection-retry interval is hard-wired at 60 seconds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_CAReconnect(self, ok: int = 0):\n\"\"\"\n    Specify whether autosave should periodically retry connecting to PVs\n    whose initial connection attempt failed. Currently, the\n    connection-retry interval is hard-wired at 60 seconds.\n    \"\"\"\n    self.ca_reconnect = bool(ok)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_CallbackTimeout(timeout: int = 0)</code> <p>Specify the time interval in seconds between forced save-file writes. (-1 means forever). This is intended to get save files written even if the normal trigger mechanism is broken.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_CallbackTimeout(self, timeout: int = 0):\n\"\"\"\n    Specify the time interval in seconds between forced save-file writes.\n    (-1 means forever). This is intended to get save files written even if\n    the normal trigger mechanism is broken.\n    \"\"\"\n    self.callback_timeout = int(timeout)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_DatedBackupFiles(ok: int = 0)</code> <p>Sets the value of (int) save_restoreDatedBackupFiles (initially 1). If zero, the backup file written at reboot time (a copy of the file from which PV values are restored) will have the suffix '.bu', and will be overwritten every reboot. If nonzero, each reboot will leave behind its own backup file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_DatedBackupFiles(self, ok: int = 0):\n\"\"\"\n    Sets the value of (int) save_restoreDatedBackupFiles (initially 1). If\n    zero, the backup file written at reboot time\n    (a copy of the file from which PV values are restored) will have the\n    suffix '.bu', and will be overwritten every reboot. If nonzero, each\n    reboot will leave behind its own backup file.\n    \"\"\"\n    self.dated_backups = bool(ok)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_Debug(level: int = 0)</code> <p>Sets the value (int) save_restoreDebug (initially 0). Increase to get more informational messages printed to the console.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_Debug(self, level: int = 0):\n\"\"\"\n    Sets the value (int) save_restoreDebug (initially 0). Increase to get\n    more informational messages printed to the console.\n    \"\"\"\n    self.debug = int(level)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_FilePermissions(permissions: int = 0)</code> <p>Specify the file permissions used to create new .sav files. This integer value will be supplied, exactly as given, to the system call, open(), and to the call fchmod(). Typically, file permissions are set with an octal number, such as 0640, and save_restoreSet_FilePermissions() will confirm any number given to it by echoing it to the console as an octal number.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_FilePermissions(self, permissions: int = 0):\n\"\"\"\n    Specify the file permissions used to create new .sav files. This\n    integer value will be supplied, exactly as given, to the system call,\n    open(), and to the call fchmod(). Typically, file permissions are set\n    with an octal number, such as 0640, and\n    save_restoreSet_FilePermissions() will confirm any number given to it\n    by echoing it to the console as an octal number.\n    \"\"\"\n    self.file_permissions = int(permissions)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_IncompleteSetsOk(ok: int = 0)</code> <p>Sets the value of (int) save_restoreIncompleteSetsOk (initially 1). If set to zero, save files will not be restored at boot time unless they are perfect, and they will not be overwritten at save time unless a valid CA connection and value exists for every PV in the list.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_IncompleteSetsOk(self, ok: int = 0):\n\"\"\"\n    Sets the value of (int) save_restoreIncompleteSetsOk (initially 1). If\n    set to zero, save files will not be restored at boot time unless they\n    are perfect, and they will not be overwritten at save time unless a\n    valid CA connection and value exists for every PV in the list.\n    \"\"\"\n    self.incomplete_sets_ok = bool(ok)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_NFSHost(hostname: str = '', address: str = '', mntpoint: str = '', *_: str)</code> <p>Specifies the name and IP address of the NFS host. If both have been specified, and set_savefile_path() has been called to specify the file path, save_restore will manage its own NFS mount. This allows save_restore to recover from a reboot of the NFS host (that is, a stale file handle) and from some kinds of tampering with the save_restore directory.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_NFSHost(\n    self, hostname: str = \"\", address: str = \"\", mntpoint: str = \"\", *_\n):\n\"\"\"\n    Specifies the name and IP address of the NFS host. If both have been\n    specified, and set_savefile_path() has been called to specify the file\n    path, save_restore will manage its own NFS mount. This allows\n    save_restore to recover from a reboot of the NFS host\n    (that is, a stale file handle) and from some kinds of tampering with\n    the save_restore directory.\n    \"\"\"\n    self.nfs_host = f\"nfs://{hostname}/{mntpoint} ({address})\"\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_NumSeqFiles(numSeqFiles: int = 0)</code> <p>Sets the value of (int) save_restoreNumSeqFiles (initially 3). This is the number of sequenced backup files to be maintained.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_NumSeqFiles(self, numSeqFiles: int = 0):\n\"\"\"\n    Sets the value of (int) save_restoreNumSeqFiles (initially 3). This is\n    the number of sequenced backup files to be maintained.\n    \"\"\"\n    self.num_seq_files = int(numSeqFiles)\n    if not (0 &lt;= self.num_seq_files &lt;= 10):\n        raise ValueError(\"numSeqFiles must be between 0 and 10 inclusive.\")\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_RetrySeconds(seconds: int = 0)</code> <p>Specify the time delay between a failed .sav-file write and the retry of that write. The default delay is 60 seconds. If list-PV's change during the delay, the new values will be written.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_RetrySeconds(self, seconds: int = 0):\n\"\"\"\n    Specify the time delay between a failed .sav-file write and the retry\n    of that write. The default delay is 60 seconds. If list-PV's change\n    during the delay, the new values will be written.\n    \"\"\"\n    self.retry_seconds = int(seconds)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_SeqPeriodInSeconds(period: int = 0)</code> <p>Sets the value of (int) save_restoreSeqPeriodInSeconds (initially 60). Sequenced backup files will be written with this period.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_SeqPeriodInSeconds(self, period: int = 0):\n\"\"\"\n    Sets the value of (int) save_restoreSeqPeriodInSeconds (initially 60).\n    Sequenced backup files will be written with this period.\n    \"\"\"\n    self.seq_period = int(period)\n    if self.seq_period &lt; 10:\n        raise ValueError(\"period must be 10 or greater.\")\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_UseStatusPVs(ok: int = 0)</code> <p>Specifies whether save_restore should report its status to a preloaded set of EPICS PV's (contained in the database save_restoreStatus.db). If the argument is '0', then status PV's will not be used.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_UseStatusPVs(self, ok: int = 0):\n\"\"\"\n    Specifies whether save_restore should report its status to a preloaded\n    set of EPICS PV's (contained in the database save_restoreStatus.db). If\n    the argument is '0', then status PV's will not be used.\n    \"\"\"\n    self.use_status_pvs = bool(ok)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_periodicDatedBackups(periodMinutes: int = 0)</code> <p>Sets the value of (int) save_restoreDatedBackupFiles (initially 1). If zero, the backup file written at reboot time (a copy of the file from which PV values are restored) will have the suffix '.bu', and will be overwritten every reboot. If nonzero, each reboot will leave behind its own backup file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_periodicDatedBackups(self, periodMinutes: int = 0):\n\"\"\"\n    Sets the value of (int) save_restoreDatedBackupFiles (initially 1). If\n    zero, the backup file written at reboot time\n    (a copy of the file from which PV values are restored) will have the\n    suffix '.bu', and will be overwritten every reboot. If nonzero, each\n    reboot will leave behind its own backup file.\n    \"\"\"\n    self.dated_backups = True\n    self.date_period_minutes = int(periodMinutes)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreSet_status_prefix(prefix: str = '')</code> <p>Specifies the prefix to be used to construct the names of PV's with which save_restore reports its status. If you want autosave to update status PVs as it operates, you must call this function and load the database save_restoreStatus.db, specifying the same prefix in both commands.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreSet_status_prefix(self, prefix: str = \"\"):\n\"\"\"\n    Specifies the prefix to be used to construct the names of PV's with\n    which save_restore reports its status. If you want autosave to update\n    status PVs as it operates, you must call this function and load the\n    database save_restoreStatus.db, specifying the same prefix in both\n    commands.\n    \"\"\"\n    self.status_prefix = prefix\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_save_restoreShow(verbose: int = 0)</code> <p>Show the save restore status.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_save_restoreShow(self, verbose: int = 0):\n\"\"\"Show the save restore status.\"\"\"\n    return self.sets\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_set_pass0_restoreFile(file: str = '', macro_string: str = '')</code> <p>This function specifies a save file to be restored during iocInit, before record initialization. An unlimited number of files can be specified using calls to this function. If the file name begins with \"/\", autosave will use it as specified; otherwise, autosave will prepend the file path specified to set_savefile_path(). The second argument is optional.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_set_pass0_restoreFile(self, file: str = \"\", macro_string: str = \"\"):\n\"\"\"\n    This function specifies a save file to be restored during iocInit,\n    before record initialization. An unlimited number of files can be\n    specified using calls to this function. If the file name begins with\n    \"/\", autosave will use it as specified; otherwise, autosave will\n    prepend the file path specified to set_savefile_path(). The second\n    argument is optional.\n    \"\"\"\n    self.restore_files[file] = AutosaveRestorePassFile(\n        context=self.get_load_context(),\n        save_filename=file,\n        macros=macros_from_string(macro_string),\n        pass_number=0,\n    )\n    return {\n        \"autosave\": f\"Added pass 0 restore file {self.save_path}/{file}\"\n    }\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_set_pass1_restoreFile(file: str = '', macro_string: str = '')</code> <p>This function specifies a save file to be restored during iocInit, after record initialization. An unlimited number of files can be specified using calls to this function. If the file name begins with \"/\", autosave will use it as specified; otherwise, autosave will prepend the file path specified to set_savefile_path(). The second argument is optional.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_set_pass1_restoreFile(self, file: str = \"\", macro_string: str = \"\"):\n\"\"\"\n    This function specifies a save file to be restored during iocInit,\n    after record initialization. An unlimited number of files can be\n    specified using calls to this function. If the file name begins with\n    \"/\", autosave will use it as specified; otherwise, autosave will\n    prepend the file path specified to set_savefile_path(). The second\n    argument is optional.\n    \"\"\"\n    self.restore_files[file] = AutosaveRestorePassFile(\n        context=self.get_load_context(),\n        save_filename=file,\n        macros=macros_from_string(macro_string),\n        pass_number=1,\n    )\n    return {\n        \"autosave\": f\"Added pass 1 restore file {self.save_path}/{file}\"\n    }\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_set_saveTask_priority(priority: int = 0)</code> <p>Set the priority of the save_restore task.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_set_saveTask_priority(self, priority: int = 0):\n\"\"\"Set the priority of the save_restore task.\"\"\"\n    self.task_priority = int(priority)\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_set_savefile_name(request_file: str = '', save_filename: str = '')</code> <p>If a save set has already been created for the request file, this function will change the save file name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_set_savefile_name(self, request_file: str = \"\", save_filename: str = \"\"):\n\"\"\"\n    If a save set has already been created for the request file, this\n    function will change the save file name.\n    \"\"\"\n    try:\n        set_ = self.sets[request_file]\n    except KeyError:\n        raise ValueError(\"Request file not configured\")\n\n    set_.save_filename = save_filename\n</code></pre> <code>whatrecord.autosave.AutosaveState.handle_set_savefile_path(path: str = '', subpath: str = '')</code> <p>Called before iocInit(), this function specifies the path to be prepended to save-file and restore-file names. pathsub, if present, will be appended to path, if present, with a separating '/', whether or not path ends or pathsub begins with '/'. If the result does not end in '/', one will be appended to it.</p> <p>If save_restore is managing its own NFS mount, this function specifies the mount point, and calling it will result in an NFS mount if all other requirements have already been met. If a valid NFS mount already exists, the file system will be dismounted and then mounted with the new path name. This function can be called at any time.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/autosave.py</code> <pre><code>@_handler\ndef handle_set_savefile_path(self, path: str = \"\", subpath: str = \"\"):\n\"\"\"\n    Called before iocInit(), this function specifies the path to be\n    prepended to save-file and restore-file names. pathsub, if present,\n    will be appended to path, if present, with a separating '/', whether or\n    not path ends or pathsub begins with '/'. If the result does not end in\n    '/', one will be appended to it.\n\n    If save_restore is managing its own NFS mount, this function specifies\n    the mount point, and calling it will result in an NFS mount if all\n    other requirements have already been met. If a valid NFS mount already\n    exists, the file system will be dismounted and then mounted with the\n    new path name. This function can be called at any time.\n    \"\"\"\n    path = pathlib.Path(path) / subpath\n    if self.primary_handler is not None:\n        path = self.primary_handler._fix_path(path)\n    self.save_path = path.resolve()\n</code></pre>"},{"location":"parsers/#whatrecord.autosave-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.db","title":"<code>whatrecord.db</code>","text":""},{"location":"parsers/#whatrecord.db-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.db.Database","title":"<code>whatrecord.db.Database</code>","text":"<p>Representation of an EPICS database, database definition, or both.</p> <p>Attributes:</p> Name Type Description <code>standalone_aliases</code> <code>Dict[str, str]</code> <p>Standalone aliases are those defined outside of the record body; this may only be useful for faithfully reconstructing the Database according to its original source code.  Keyed on alias to actual record name.</p> <p>aliases : Dict[str, str]     Alias name to record name.</p> <p>paths : List[str]     The path command specifies the current search path for use when loading     database and database definition files. The addpath appends directory     names to the current path. The path is used to locate the initial     database file and included files. An empty dir at the beginning,     middle, or end of a non-empty path string means the current directory.</p> <p>addpaths : List[str]     See 'paths' above.</p> <p>breaktables : Dict[str, List[str]]     Breakpoint table (look-up table) of raw-to-engineering values.</p> <p>comments : List[str]     Comments encountered while parsing the database.</p> <p>devices : List[DatabaseDevice]     Device support declarations (dset).</p> <p>drivers : List[str]     Driver declarations (drvet).</p> <p>functions : List[str]     Exported C function names.</p> <p>includes : List[str]     Inline inclusion. Not supported just yet.</p> <p>links : Dict[str, str]     Links.</p> <p>menus : Dict[str, DatabaseMenu]     Named value enumerations (enums).</p> <p>records : Dict[str, RecordInstance]     Record name to RecordInstance.</p> <p>record_types : Dict[str, RecordType]     Record type name to RecordType.</p> <p>registrars : List[str]     Exported registrar function name.</p> <p>variables : Dict[str, Optional[str]]     IOC shell variables.</p> <p>lint : DatabaseLint     Any lint found when loading the database.</p>"},{"location":"parsers/#whatrecord.db.Database-attributes","title":"Attributes","text":"<code>whatrecord.db.Database.all_aliases: Dict[str, str]</code> <code>property</code> <p>All aliases: top-level-defined and per-instance-defined.</p> <code>whatrecord.db.Database.non_aliased_records: Dict[str, RecordInstance]</code> <code>property</code> <p>Get unique and non-aliased record instances.</p> <p>This can be used to ignore records included by the <code>include_aliases</code> setting.</p>"},{"location":"parsers/#whatrecord.db.Database-functions","title":"Functions","text":"<code>whatrecord.db.Database.add_or_update_record(record: RecordInstance)</code> <p>Update (or add) records given a dictionary of records.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>def add_or_update_record(self, record: RecordInstance):\n\"\"\"\n    Update (or add) records given a dictionary of records.\n    \"\"\"\n    if record.is_pva:\n        existing_record = self.pva_groups.get(record.name, None)\n    else:\n        existing_record = self.records.get(record.name, None)\n\n    if not existing_record:\n        self.records[record.name] = record\n    else:\n        existing_record.update(record)\n</code></pre> <code>whatrecord.db.Database.append(other: Database)</code> <p>Append the other database, best-effort updating existing entries.</p> <p>This is not likely to do everything correctly (TODO).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>def append(self, other: Database):\n\"\"\"\n    Append the other database, best-effort updating existing entries.\n\n    This is not likely to do everything correctly (TODO).\n    \"\"\"\n    for instance in other.records.values():\n        self.add_or_update_record(instance)\n\n    for instance in other.pva_groups.values():\n        self.add_or_update_record(instance)\n\n    def _update_list(this, other):\n        this.extend([v for v in other if v not in this])\n\n    _update_list(self.addpaths, other.addpaths)\n    _update_list(self.comments, other.comments)\n    _update_list(self.devices, other.devices)\n    _update_list(self.drivers, other.drivers)\n    _update_list(self.functions, other.functions)\n    _update_list(self.includes, other.includes)\n    _update_list(self.paths, other.paths)\n    _update_list(self.registrars, other.registrars)\n    self.aliases.update(other.aliases)\n    self.breaktables.update(other.breaktables)\n    self.links.update(other.links)\n    self.menus.update(other.menus)\n    self.record_types.update(other.record_types or {})\n    self.standalone_aliases.update(other.standalone_aliases)\n    self.variables.update(other.variables)\n</code></pre> <code>whatrecord.db.Database.field_names_by_type(field_types: List[str]) -&gt; Dict[str, FrozenSet[str]]</code> <p>Generate dictionary of record type to frozenset of field names.</p> <p>This can be used in scenarios where database definition files are unavailable and link information is requested.</p> <p>Parameters:</p> Name Type Description Default <code>field_types</code> <code>list of str</code> <p>Field types to look for.</p> required Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>def field_names_by_type(\n    self, field_types: List[str]\n) -&gt; Dict[str, FrozenSet[str]]:\n\"\"\"\n    Generate dictionary of record type to frozenset of field names.\n\n    This can be used in scenarios where database definition files are\n    unavailable and link information is requested.\n\n    Parameters\n    ----------\n    field_types : list of str\n        Field types to look for.\n    \"\"\"\n    by_rtype = {}\n    for rtype, info in sorted(self.record_types.items()):\n        by_rtype[rtype] = frozenset(\n            field.name\n            for field in info.fields.values()\n            if field.type in field_types\n        )\n    return by_rtype\n</code></pre> <code>whatrecord.db.Database.from_file(fn: Union[str, pathlib.Path], dbd: Optional[Union[Database, str, pathlib.Path]] = None, macro_context: Optional[MacroContext] = None, version: int = 4, include_aliases: bool = True) -&gt; Database</code> <code>classmethod</code> <p>Load a database [definition] from a filename.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>str or Path</code> <p>The path to the database file.</p> required <code>dbd</code> <code>Union[Database, str, Path]</code> <p>The database definition (.dbd) path, if applicable and available.</p> <code>None</code> <code>macro_context</code> <code>MacroContext</code> <p>A macro context to use for expanding macros while loading the database.</p> <code>None</code> <code>version</code> <code>int</code> <p>The epics-base version to assume when loading.  Use 3 for R3.15 and under, 4 for more recent versions.</p> <code>4</code> <code>include_aliases</code> <code>bool</code> <p>Include aliases as top-level records.</p> <code>True</code> <p>Returns:</p> Type Description <code>Database</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    fn: Union[str, pathlib.Path],\n    dbd: Optional[Union[Database, str, pathlib.Path]] = None,\n    macro_context: Optional[MacroContext] = None,\n    version: int = 4,\n    include_aliases: bool = True,\n) -&gt; Database:\n\"\"\"\n    Load a database [definition] from a filename.\n\n    Parameters\n    ----------\n    fn : str or pathlib.Path\n        The path to the database file.\n    dbd : Union[Database, str, pathlib.Path], optional\n        The database definition (.dbd) path, if applicable and available.\n    macro_context : MacroContext, optional\n        A macro context to use for expanding macros while loading the\n        database.\n    version : int, optional\n        The epics-base version to assume when loading.  Use 3 for R3.15 and under,\n        4 for more recent versions.\n    include_aliases : bool, optional\n        Include aliases as top-level records.\n\n    Returns\n    -------\n    Database\n    \"\"\"\n    with open(fn, \"rt\") as fp:\n        return cls.from_string(\n            fp.read(),\n            filename=fn,\n            dbd=dbd,\n            macro_context=macro_context,\n            version=version,\n            include_aliases=include_aliases,\n        )\n</code></pre> <code>whatrecord.db.Database.from_file_obj(fp, dbd: Optional[Union[Database, str, pathlib.Path]] = None, filename: Optional[Union[str, pathlib.Path]] = None, macro_context: Optional[MacroContext] = None, version: int = 4, include_aliases: bool = True) -&gt; Database</code> <code>classmethod</code> <p>Load a database [definition] from a file object.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>file or file-like object</code> <p>The file object to read from.</p> required <code>dbd</code> <code>Union[Database, str, Path]</code> <p>The database definition (.dbd) path, if applicable and available.</p> <code>None</code> <code>filename</code> <code>Union[str, Path]</code> <p>The filename to associate with the contents.  Defaults to <code>fp.name</code>, if available.</p> <code>None</code> <code>macro_context</code> <code>MacroContext</code> <p>A macro context to use for expanding macros while loading the database.</p> <code>None</code> <code>version</code> <code>int</code> <p>The epics-base version to assume when loading.  Use 3 for R3.15 and under, 4 for more recent versions.</p> <code>4</code> <code>include_aliases</code> <code>bool</code> <p>Include aliases as top-level records.</p> <code>True</code> <p>Returns:</p> Type Description <code>Database</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>@classmethod\ndef from_file_obj(\n    cls,\n    fp,\n    dbd: Optional[Union[Database, str, pathlib.Path]] = None,\n    filename: Optional[Union[str, pathlib.Path]] = None,\n    macro_context: Optional[MacroContext] = None,\n    version: int = 4,\n    include_aliases: bool = True,\n) -&gt; Database:\n\"\"\"\n    Load a database [definition] from a file object.\n\n    Parameters\n    ----------\n    fp : file or file-like object\n        The file object to read from.\n    dbd : Union[Database, str, pathlib.Path], optional\n        The database definition (.dbd) path, if applicable and available.\n    filename : Union[str, pathlib.Path], optional\n        The filename to associate with the contents.  Defaults to\n        ``fp.name``, if available.\n    macro_context : MacroContext, optional\n        A macro context to use for expanding macros while loading the\n        database.\n    version : int, optional\n        The epics-base version to assume when loading.  Use 3 for R3.15 and under,\n        4 for more recent versions.\n    include_aliases : bool, optional\n        Include aliases as top-level records.\n\n    Returns\n    -------\n    Database\n    \"\"\"\n    return cls.from_string(\n        fp.read(),\n        filename=filename or getattr(fp, \"name\", None),\n        dbd=dbd,\n        macro_context=macro_context,\n        version=version,\n        include_aliases=include_aliases,\n    )\n</code></pre> <code>whatrecord.db.Database.from_multiple(*items: _DatabaseSource) -&gt; Database</code> <code>classmethod</code> <p>Create a Database instance from multiple sources, including:</p> <ul> <li>Other Database instances</li> <li>LoadedIoc</li> <li>ShellState</li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>@classmethod\ndef from_multiple(cls, *items: _DatabaseSource) -&gt; Database:\n\"\"\"\n    Create a Database instance from multiple sources, including:\n\n    * Other Database instances\n    * LoadedIoc\n    * ShellState\n    \"\"\"\n    from .shell import LoadedIoc, ShellState\n\n    db = cls()\n\n    for item in items:\n        if isinstance(item, Database):\n            db.append(item)\n        elif isinstance(item, (LoadedIoc, ShellState)):\n            state = item.shell_state if isinstance(item, LoadedIoc) else item\n            new_records = list(state.database.values()) + list(state.pva_database.values())\n            for record in new_records:\n                db.add_or_update_record(record)\n            db.aliases.update(state.aliases)\n        else:\n            raise ValueError(f\"Expected {_DatabaseSource}, got {type(item)}\")\n\n    return db\n</code></pre> <code>whatrecord.db.Database.from_string(contents: str, dbd: Optional[Union[Database, str, pathlib.Path]] = None, filename: Optional[Union[str, pathlib.Path]] = None, macro_context: Optional[MacroContext] = None, version: int = 4, include_aliases: bool = True) -&gt; Database</code> <code>classmethod</code> <p>Load a database [definition] from a string.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>The contents of the database file.</p> required <code>dbd</code> <code>Union[Database, str, Path]</code> <p>The database definition (.dbd) path, if applicable and available.</p> <code>None</code> <code>filename</code> <code>Union[str, Path]</code> <p>The filename to associate with the contents.</p> <code>None</code> <code>macro_context</code> <code>MacroContext</code> <p>A macro context to use for expanding macros while loading the database.</p> <code>None</code> <code>version</code> <code>int</code> <p>The epics-base version to assume when loading.  Use 3 for R3.15 and under, 4 for more recent versions.</p> <code>4</code> <code>include_aliases</code> <code>bool</code> <p>Include aliases as top-level records.</p> <code>True</code> <p>Returns:</p> Type Description <code>Database</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    contents: str,\n    dbd: Optional[Union[Database, str, pathlib.Path]] = None,\n    filename: Optional[Union[str, pathlib.Path]] = None,\n    macro_context: Optional[MacroContext] = None,\n    version: int = 4,\n    include_aliases: bool = True,\n) -&gt; Database:\n\"\"\"\n    Load a database [definition] from a string.\n\n    Parameters\n    ----------\n    contents : str\n        The contents of the database file.\n    dbd : Union[Database, str, pathlib.Path], optional\n        The database definition (.dbd) path, if applicable and available.\n    filename : Union[str, pathlib.Path], optional\n        The filename to associate with the contents.\n    macro_context : MacroContext, optional\n        A macro context to use for expanding macros while loading the\n        database.\n    version : int, optional\n        The epics-base version to assume when loading.  Use 3 for R3.15 and under,\n        4 for more recent versions.\n    include_aliases : bool, optional\n        Include aliases as top-level records.\n\n    Returns\n    -------\n    Database\n    \"\"\"\n    if dbd is not None and not isinstance(dbd, Database):\n        dbd = Database.from_file(dbd, version=version)\n\n    comments = []\n    grammar = lark.Lark.open_from_package(\n        \"whatrecord\",\n        f\"db.v{version}.lark\",\n        search_paths=(\"grammar\", ),\n        parser=\"lalr\",\n        lexer_callbacks={\"COMMENT\": comments.append},\n        transformer=_DatabaseTransformer(filename, dbd=dbd),\n        maybe_placeholders=False,\n        # Per-user `gettempdir` caching of the LALR grammar analysis way of\n        # passing ``True`` here:\n        cache=True,\n    )\n    if macro_context is not None:\n        contents = macro_context.expand_by_line(contents).rstrip() + \"\\n\"\n\n    db = cast(Database, grammar.parse(contents))\n    db.comments = comments\n\n    if include_aliases:\n        for record_name, record in list(db.records.items()):\n            for alias in record.aliases:\n                db.records[alias] = record\n\n    return db\n</code></pre> <code>whatrecord.db.Database.from_vendored_dbd(version: int = 3) -&gt; Database</code> <code>classmethod</code> <p>Load the vendored database definition file from whatrecord.</p> <p>This is a good fallback when you have a database file without a corresponding database definition file.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>int</code> <p>Use the old V3 style or new V3 style database grammar by specifying 3 or 4, respectively.  Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>db</code> <code>Database</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>@classmethod\ndef from_vendored_dbd(cls, version: int = 3) -&gt; Database:\n\"\"\"\n    Load the vendored database definition file from whatrecord.\n\n    This is a good fallback when you have a database file without a\n    corresponding database definition file.\n\n    Parameters\n    ----------\n    version : int, optional\n        Use the old V3 style or new V3 style database grammar by specifying\n        3 or 4, respectively.  Defaults to 3.\n\n    Returns\n    -------\n    db : Database\n    \"\"\"\n    if version &lt;= 3:\n        return cls.from_file(\n            util.MODULE_PATH / \"tests\" / \"iocs/v3_softIoc.dbd\",\n            version=version,\n        )\n    return cls.from_file(\n        util.MODULE_PATH / \"tests\" / \"iocs\" / \"softIoc.dbd\",\n        version=version,\n    )\n</code></pre> <code>whatrecord.db.Database.get_links_for_record(record: RecordInstance) -&gt; Generator[Tuple[RecordField, str, List[str]], None, None]</code> <p>Get all links - in, out, and forward links.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>RecordInstance</code> <p>Additional information, if the database definition wasn't loaded with this instance.</p> required <p>Yields:</p> Name Type Description <code>field</code> <code>RecordField</code> <code>link_text</code> <code>str</code> <code>link_info</code> <code>str</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>def get_links_for_record(\n    self,\n    record: RecordInstance,\n) -&gt; Generator[Tuple[RecordField, str, List[str]], None, None]:\n\"\"\"\n    Get all links - in, out, and forward links.\n\n    Parameters\n    ----------\n    record : RecordInstance\n        Additional information, if the database definition wasn't loaded\n        with this instance.\n\n    Yields\n    ------\n    field : RecordField\n    link_text: str\n    link_info: str\n    \"\"\"\n    record_info = self.record_types.get(record.record_type, None)\n    if not record_info:\n        return\n\n    yield from record_info.get_links_for_record(record)\n</code></pre> <code>whatrecord.db.Database.shallow_copy() -&gt; Database</code> <p>A shallow copy of the database with new dictionaries/lists.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>def shallow_copy(self) -&gt; Database:\n\"\"\"A shallow copy of the database with new dictionaries/lists.\"\"\"\n\n    return type(self)(\n        addpaths=list(self.addpaths),\n        aliases=dict(self.aliases),\n        breaktables=dict(self.breaktables),\n        comments=list(self.comments),\n        devices=list(self.devices),\n        drivers=list(self.drivers),\n        functions=list(self.functions),\n        includes=list(self.includes),\n        links=dict(self.links),\n        menus=dict(self.menus),\n        paths=list(self.paths),\n        pva_groups=dict(self.pva_groups),\n        record_types=dict(self.record_types),\n        records=dict(self.records),\n        registrars=list(self.registrars),\n        standalone_aliases=dict(self.standalone_aliases),\n        variables=dict(self.variables),\n        lint=DatabaseLint(\n            warnings=list(self.lint.warnings),\n            errors=list(self.lint.errors),\n        )\n    )\n</code></pre>"},{"location":"parsers/#whatrecord.db.DatabaseLint","title":"<code>whatrecord.db.DatabaseLint</code>","text":"<p>Container for dbdlint results, with easier-to-access attributes.</p> <p>Reimplementation of <code>pyPDB.dbdlint.Results</code>.</p> <p>Each error or warning has dictionary keys::</p> <pre><code>{name, message, file, line, raw_message, format_args}\n</code></pre> <p>Attributes:</p> Name Type Description <code>errors</code> <code>list</code> <p>List of errors found</p> <code>warnings</code> <code>list</code> <p>List of warnings found</p>"},{"location":"parsers/#whatrecord.db.DatabaseLoadFailure","title":"<code>whatrecord.db.DatabaseLoadFailure</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Database load failure.</p>"},{"location":"parsers/#whatrecord.db-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.db.split_record_and_field","title":"<code>whatrecord.db.split_record_and_field(pvname) -&gt; Tuple[str, str]</code>","text":"<p>Split REC.FLD into REC and FLD.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/db.py</code> <pre><code>def split_record_and_field(pvname) -&gt; Tuple[str, str]:\n\"\"\"Split REC.FLD into REC and FLD.\"\"\"\n    record, *field = pvname.split(\".\", 1)\n    return record, field[0] if field else \"\"\n</code></pre>"},{"location":"parsers/#whatrecord.dbtemplate","title":"<code>whatrecord.dbtemplate</code>","text":"<p>dbLoadTemplate and msi -S substitution grammar helpers.</p>"},{"location":"parsers/#whatrecord.dbtemplate-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.dbtemplate.GlobalDefinitions","title":"<code>whatrecord.dbtemplate.GlobalDefinitions</code>  <code>dataclass</code>","text":"<p>             Bases: <code>VariableDefinitions</code></p> <p>Global variable definitions.</p>"},{"location":"parsers/#whatrecord.dbtemplate.PatternHeader","title":"<code>whatrecord.dbtemplate.PatternHeader</code>  <code>dataclass</code>","text":"<p>Pattern header.</p>"},{"location":"parsers/#whatrecord.dbtemplate.PatternValues","title":"<code>whatrecord.dbtemplate.PatternValues</code>  <code>dataclass</code>","text":"<p>Pattern values.</p>"},{"location":"parsers/#whatrecord.dbtemplate.Substitution","title":"<code>whatrecord.dbtemplate.Substitution</code>  <code>dataclass</code>","text":"<p>Single database template file from a full template.</p> <p>Represents approximately one line of a .substitutions file. For example, in this substitution file,</p> <pre><code>    file template.txt {\n        pattern {a, b, c}\n        {A, B, C}\n    }\n</code></pre> <p>The resulting Substitution would be</p> <p><code>Substitution(macros={\"a\": \"A\", \"b\": \"B\", \"c\": \"C\"}, filename=\"template.txt\")</code>.</p> <p>Global macro values will be aggregated into this dictionary.</p> <p>Inside of the template file - <code>template.txt</code> above: * \"include\" is a supported command for the template file. * \"substitute\" is optionally supported (set <code>allow_substitute</code>)</p>"},{"location":"parsers/#whatrecord.dbtemplate.Substitution-attributes","title":"Attributes","text":"<code>whatrecord.dbtemplate.Substitution.macro_context: MacroContext</code> <code>property</code> <p>The macro context to be used when expanding the template.</p>"},{"location":"parsers/#whatrecord.dbtemplate.Substitution-functions","title":"Functions","text":"<code>whatrecord.dbtemplate.Substitution.expand(source: str, search_paths: Optional[List[AnyPath]] = None)</code> <p>Expand the provided substitution template, using the macro environment.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The source substitution template.  May contain \"include\" or \"substitute\" lines.</p> required <p>search_paths : list of str or pathlib.Path, optional     List of paths to search for template files.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>def expand(self, source: str, search_paths: Optional[List[AnyPath]] = None):\n\"\"\"\n    Expand the provided substitution template, using the macro environment.\n\n    Parameters\n    ----------\n    source : str\n        The source substitution template.  May contain \"include\" or\n        \"substitute\" lines.\n\n    search_paths : list of str or pathlib.Path, optional\n        List of paths to search for template files.\n    \"\"\"\n    ctx = self.macro_context\n    search_paths = search_paths or [pathlib.Path(\".\")]\n    results = []\n    source_stack = collections.deque(source.splitlines())\n    while source_stack:\n        line = source_stack.popleft()\n        logger.debug(\"line %r\", line)\n        line = ctx.expand(line)\n        command, *command_args = line.strip().split(\" \", 1)\n        if command == \"include\":  # case sensitive\n            args = shlex.split(command_args[0])\n            if len(args) != 1:\n                raise ValueError(\n                    f\"Include command takes one argument; got: {args} \"\n                    f\"where line={line!r}\"\n                )\n            include_file = args[0]\n            logger.debug(\"Including file from %s\", include_file)\n            include_source = self.handle_include(include_file, search_paths)\n            source_stack.extendleft(reversed(include_source.splitlines()))\n            logger.debug(\"stack %r\", source_stack)\n        elif command == \"substitute\" and self.allow_substitute:\n            # Note that dbLoadTemplate does not support substitute, but msi\n            # does.\n            macro_string = command_args[0].strip()\n            # Strip only single beginning and end quotes\n            macro_string = _strip_double_quote(macro_string).strip()\n            logger.debug(\"Substituting additional macros %s\", macro_string)\n            ctx.define_from_string(macro_string)\n        else:\n            results.append(line)\n\n    return \"\\n\".join(results)\n</code></pre> <code>whatrecord.dbtemplate.Substitution.expand_file(*, filename: Optional[str] = None, search_paths: Optional[List[AnyPath]] = None) -&gt; str</code> <p>Expand the given file, looking in <code>search_paths</code> for template files.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Expand this file or fall back to the instance-defined filename.</p> <code>None</code> <p>search_paths : list of str or pathlib.Path, optional     List of paths to search for template files.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>def expand_file(\n    self,\n    *,\n    filename: Optional[str] = None,\n    search_paths: Optional[List[AnyPath]] = None\n) -&gt; str:\n\"\"\"\n    Expand the given file, looking in ``search_paths`` for template files.\n\n    Parameters\n    ----------\n    filename : str, optional\n        Expand this file or fall back to the instance-defined filename.\n\n    search_paths : list of str or pathlib.Path, optional\n        List of paths to search for template files.\n    \"\"\"\n    filename = filename or self.filename\n    if filename is None:\n        raise ValueError(\"This substitution does not have a file defined\")\n\n    filename = pathlib.Path(filename)\n    search_paths = search_paths or [filename.resolve().parent]\n    with open(filename, \"rt\") as fp:\n        return self.expand(fp.read(), search_paths=search_paths)\n</code></pre> <code>whatrecord.dbtemplate.Substitution.handle_include(filename: str, search_paths: List[AnyPath]) -&gt; str</code> <code>staticmethod</code> <p>Expand include files from the given search path.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>@staticmethod\ndef handle_include(filename: str, search_paths: List[AnyPath]) -&gt; str:\n\"\"\"Expand include files from the given search path.\"\"\"\n    for path in search_paths:\n        option = pathlib.Path(path) / filename\n        if option.exists():\n            with open(option, \"rt\") as fp:\n                return fp.read()\n\n    friendly_paths = \" or \".join(f'\"{path}\"' for path in search_paths)\n    raise FileNotFoundError(f\"{filename} not found in {friendly_paths}\")\n</code></pre>"},{"location":"parsers/#whatrecord.dbtemplate.TemplateSubstitution","title":"<code>whatrecord.dbtemplate.TemplateSubstitution</code>  <code>dataclass</code>","text":"<p>Database substitutions, containing zero or more template files.</p>"},{"location":"parsers/#whatrecord.dbtemplate.TemplateSubstitution-functions","title":"Functions","text":"<code>whatrecord.dbtemplate.TemplateSubstitution.expand_files(search_paths: Optional[List[AnyPath]] = None, delimiter: str = '\\n') -&gt; str</code> <p>Expands and combines all contained substitution files.</p> <p>Parameters:</p> Name Type Description Default <code>delimiter</code> <code>str</code> <p>Delimiter to join individual substitutions.</p> <code>'\\n'</code> <p>search_paths : list of str or pathlib.Path, optional     List of paths to search for template files.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>def expand_files(\n    self,\n    search_paths: Optional[List[AnyPath]] = None,\n    delimiter: str = \"\\n\"\n) -&gt; str:\n\"\"\"\n    Expands and combines all contained substitution files.\n\n    Parameters\n    ----------\n    delimiter : str, optional\n        Delimiter to join individual substitutions.\n\n    search_paths : list of str or pathlib.Path, optional\n        List of paths to search for template files.\n    \"\"\"\n    return delimiter.join(\n        sub.expand_file(search_paths=search_paths)\n        for sub in self.substitutions\n    )\n</code></pre> <code>whatrecord.dbtemplate.TemplateSubstitution.expand_template(template: str, search_paths: Optional[List[AnyPath]] = None, delimiter: str = '\\n') -&gt; str</code> <p>Expands all substitutions for the given string.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>The template text.</p> required <p>delimiter : str, optional     Delimiter to join individual substitutions.</p> <p>search_paths : list of str or pathlib.Path, optional     List of paths to search for template files.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>def expand_template(\n    self,\n    template: str,\n    search_paths: Optional[List[AnyPath]] = None,\n    delimiter: str = \"\\n\",\n) -&gt; str:\n\"\"\"\n    Expands all substitutions for the given string.\n\n    Parameters\n    ----------\n    template : str\n        The template text.\n\n    delimiter : str, optional\n        Delimiter to join individual substitutions.\n\n    search_paths : list of str or pathlib.Path, optional\n        List of paths to search for template files.\n    \"\"\"\n    return delimiter.join(\n        sub.expand(template, search_paths=search_paths)\n        for sub in self.substitutions\n    )\n</code></pre> <code>whatrecord.dbtemplate.TemplateSubstitution.from_file(fn) -&gt; TemplateSubstitution</code> <code>classmethod</code> <p>Load a template file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path or str</code> <p>The filename.</p> required <p>Returns:</p> Name Type Description <code>template</code> <code>TemplateSubstitution</code> <p>The template file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>@classmethod\ndef from_file(cls, fn) -&gt; TemplateSubstitution:\n\"\"\"\n    Load a template file.\n\n    Parameters\n    ----------\n    filename : pathlib.Path or str\n        The filename.\n\n    Returns\n    -------\n    template : TemplateSubstitution\n        The template file.\n    \"\"\"\n    with open(fn, \"rt\") as fp:\n        return cls.from_string(fp.read(), filename=fn)\n</code></pre> <code>whatrecord.dbtemplate.TemplateSubstitution.from_file_obj(fp, filename = None) -&gt; TemplateSubstitution</code> <code>classmethod</code> <p>Load a template file given a file object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>@classmethod\ndef from_file_obj(cls, fp, filename=None) -&gt; TemplateSubstitution:\n\"\"\"Load a template file given a file object.\"\"\"\n    return cls.from_string(\n        fp.read(),\n        filename=getattr(fp, \"name\", filename),\n    )\n</code></pre> <code>whatrecord.dbtemplate.TemplateSubstitution.from_string(contents, filename = None, msi_format = False, all_global_scope = False) -&gt; TemplateSubstitution</code> <code>classmethod</code> <p>Load a template substitutions file given its string contents.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/dbtemplate.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    contents,\n    filename=None,\n    msi_format=False,\n    all_global_scope=False,\n) -&gt; TemplateSubstitution:\n\"\"\"Load a template substitutions file given its string contents.\"\"\"\n    comments = []\n    grammar_filename = \"msi-sub.lark\" if msi_format else \"dbtemplate.lark\"\n\n    grammar = lark.Lark.open_from_package(\n        \"whatrecord\",\n        grammar_filename,\n        search_paths=(\"grammar\",),\n        parser=\"earley\",\n        # TODO: This is unsupported in lark:\n        # lexer_callbacks={\"COMMENT\": comments.append},\n        maybe_placeholders=False,\n        propagate_positions=True,\n    )\n\n    if msi_format:\n        tr = _TemplateMsiTransformer(\n            cls, filename, all_global_scope=all_global_scope\n        )\n    else:\n        tr = _TemplateTransformer(cls, filename)\n\n    subs = tr.transform(grammar.parse(contents))\n    subs.comments = comments\n    return subs\n</code></pre>"},{"location":"parsers/#whatrecord.dbtemplate.VariableDefinitions","title":"<code>whatrecord.dbtemplate.VariableDefinitions</code>  <code>dataclass</code>","text":"<p>Variable definitions.</p>"},{"location":"parsers/#whatrecord.dbtemplate-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.gateway","title":"<code>whatrecord.gateway</code>","text":""},{"location":"parsers/#whatrecord.gateway-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.gateway.AccessSecurity","title":"<code>whatrecord.gateway.AccessSecurity</code>  <code>dataclass</code>","text":"<p>A PVList rule access security settings.</p>"},{"location":"parsers/#whatrecord.gateway.AliasRule","title":"<code>whatrecord.gateway.AliasRule</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Rule</code></p> <p>Rule to alias the pattern to a PV (or PVs).</p>"},{"location":"parsers/#whatrecord.gateway.AllowRule","title":"<code>whatrecord.gateway.AllowRule</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Rule</code></p> <p>Rule to allow access to a PV pattern.</p>"},{"location":"parsers/#whatrecord.gateway.DenyRule","title":"<code>whatrecord.gateway.DenyRule</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Rule</code></p> <p>Rule to deny access to a PV pattern.</p>"},{"location":"parsers/#whatrecord.gateway.GatewayConfig","title":"<code>whatrecord.gateway.GatewayConfig(path: Union[str, pathlib.Path], glob_str: str = '*.pvlist', pvlists: Optional[Dict[pathlib.Path, PVList]] = None)</code>  <code>dataclass</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>def __init__(\n    self,\n    path: Union[str, pathlib.Path],\n    glob_str: str = \"*.pvlist\",\n    pvlists: Optional[Dict[pathlib.Path, PVList]] = None,\n):\n    self.path = pathlib.Path(path).resolve()\n    self.glob_str = glob_str\n    if pvlists is not None:\n        self.pvlists = pvlists\n    else:\n        self.pvlists = self._load_from_files()\n</code></pre>"},{"location":"parsers/#whatrecord.gateway.GatewayConfig-functions","title":"Functions","text":"<code>whatrecord.gateway.GatewayConfig.get_matches(name: str, remove_any: bool = True) -&gt; PVListMatches</code> <p>Get matches from any PVList given a PV name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>def get_matches(self, name: str, remove_any: bool = True) -&gt; PVListMatches:\n\"\"\"Get matches from any PVList given a PV name.\"\"\"\n    matches = [\n        PVListMatch(\n            filename=str(fn),\n            rule=rule,\n            groups=groups,\n        )\n        for fn, pvlist in self.pvlists.items()\n        for rule, groups in pvlist.match(name)\n        if rule.pattern != \".*\" or not remove_any\n    ]\n\n    return PVListMatches(\n        name=name,\n        matches=matches,\n    )\n</code></pre> <code>whatrecord.gateway.GatewayConfig.update_changed()</code> <p>Update any changed files.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>def update_changed(self):\n\"\"\"Update any changed files.\"\"\"\n    for filename, pvlist in self.pvlists.items():\n        if get_file_sha256(filename) != pvlist.hash:\n            logger.info(\"Updating changed gateway file: %s\", filename)\n            self._update(filename)\n</code></pre>"},{"location":"parsers/#whatrecord.gateway.PVList","title":"<code>whatrecord.gateway.PVList</code>  <code>dataclass</code>","text":"<p>A PVList container.</p>"},{"location":"parsers/#whatrecord.gateway.PVList-functions","title":"Functions","text":"<code>whatrecord.gateway.PVList.find(cls: typing.Type) -&gt; Generator[Rule, None, None]</code> <p>Yield matching rule types.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>def find(\n    self, cls: typing.Type\n) -&gt; Generator[Rule, None, None]:\n\"\"\"Yield matching rule types.\"\"\"\n    for rule in self.rules:\n        if isinstance(rule, cls):\n            yield rule\n</code></pre> <code>whatrecord.gateway.PVList.from_file(fn: Union[str, pathlib.Path])</code> <code>classmethod</code> <p>Load a PVList from a filename.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>@classmethod\ndef from_file(cls, fn: Union[str, pathlib.Path]):\n\"\"\"Load a PVList from a filename.\"\"\"\n    with open(fn, \"rt\") as fp:\n        return cls.from_file_obj(fp, filename=str(fn))\n</code></pre> <code>whatrecord.gateway.PVList.from_file_obj(fp, filename: Optional[str] = None)</code> <code>classmethod</code> <p>Load a PVList from a file object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>@classmethod\ndef from_file_obj(cls, fp, filename: Optional[str] = None):\n\"\"\"Load a PVList from a file object.\"\"\"\n    filename = filename or getattr(fp, \"name\", str(id(fp)))\n    return cls.from_string(fp.read(), filename=filename)\n</code></pre> <code>whatrecord.gateway.PVList.match(name: str) -&gt; Generator[Tuple[Rule, List[str]], None, None]</code> <p>Yield matching rules.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>def match(\n    self, name: str\n) -&gt; Generator[Tuple[Rule, List[str]], None, None]:\n\"\"\"Yield matching rules.\"\"\"\n    for rule in self.rules:\n        m = rule.match(name)\n        if m:\n            yield rule, list(m.groups())\n</code></pre>"},{"location":"parsers/#whatrecord.gateway.Rule","title":"<code>whatrecord.gateway.Rule</code>  <code>dataclass</code>","text":"<p>A PVList rule (base class).</p>"},{"location":"parsers/#whatrecord.gateway.Rule-functions","title":"Functions","text":"<code>whatrecord.gateway.Rule.match(name)</code> <p>Match a pv name against this rule.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>def match(self, name):\n\"\"\"Match a pv name against this rule.\"\"\"\n    if self.regex is not None:\n        return self.regex.fullmatch(name)\n</code></pre>"},{"location":"parsers/#whatrecord.gateway-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.gateway.create_arg_parser","title":"<code>whatrecord.gateway.create_arg_parser()</code>","text":"<p>Create the argument parser.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/gateway.py</code> <pre><code>def create_arg_parser():\n\"\"\"Create the argument parser.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"pvlist name matching and linting tool\",\n    )\n    parser.add_argument(\"--lint\", action=\"store_true\", help=\"Lint regular expressions\")\n    parser.add_argument(\n        \"--pvlists\",\n        type=str,\n        nargs=\"*\",\n        help=\"Specific pvlists to check (empty for all)\",\n    )\n    parser.add_argument(\n        \"--hide-context\", action=\"store_true\", help=\"Hide comment context\"\n    )\n    parser.add_argument(\n        \"--remove-any\", action=\"store_true\", help=\"Remove '.*' from results\"\n    )\n    parser.add_argument(\"names\", nargs=\"*\", type=str, help=\"PV names to match\")\n    return parser\n</code></pre>"},{"location":"parsers/#whatrecord.snl","title":"<code>whatrecord.snl</code>","text":""},{"location":"parsers/#whatrecord.snl-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.snl.InitExpression","title":"<code>whatrecord.snl.InitExpression</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Expression</code></p> <p>Of the form:     ( type ) { init_exprs }     { init_exprs }     expr</p>"},{"location":"parsers/#whatrecord.snl.SequencerProgram","title":"<code>whatrecord.snl.SequencerProgram</code>  <code>dataclass</code>","text":"<p>Representation of a state notation language (snl seq) program.</p>"},{"location":"parsers/#whatrecord.snl.SequencerProgram-functions","title":"Functions","text":"<code>whatrecord.snl.SequencerProgram.as_graph(**kwargs) -&gt; SequencerProgramGraph</code> <p>Create a graphviz digraph of the state notation diagram.</p> <p>Returns:</p> Name Type Description <code>graph</code> <code>SequencerProgramGraph</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>def as_graph(self, **kwargs) -&gt; SequencerProgramGraph:\n\"\"\"\n    Create a graphviz digraph of the state notation diagram.\n\n    Returns\n    -------\n    graph : SequencerProgramGraph\n    \"\"\"\n    return SequencerProgramGraph(self, **kwargs)\n</code></pre> <code>whatrecord.snl.SequencerProgram.from_file(fn: AnyPath) -&gt; SequencerProgram</code> <code>classmethod</code> <p>Load a state notation language file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path or str</code> <p>The filename.</p> required <p>Returns:</p> Name Type Description <code>program</code> <code>SequencerProgram</code> <p>The parsed program.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>@classmethod\ndef from_file(cls, fn: AnyPath) -&gt; SequencerProgram:\n\"\"\"\n    Load a state notation language file.\n\n    Parameters\n    ----------\n    filename : pathlib.Path or str\n        The filename.\n\n    Returns\n    -------\n    program : SequencerProgram\n        The parsed program.\n    \"\"\"\n    with open(fn, \"rt\") as fp:\n        return cls.from_string(fp.read(), filename=fn)\n</code></pre> <code>whatrecord.snl.SequencerProgram.from_file_obj(fp, filename: Optional[AnyPath] = None) -&gt; SequencerProgram</code> <code>classmethod</code> <p>Load a state notation language program given a file object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>@classmethod\ndef from_file_obj(cls, fp, filename: Optional[AnyPath] = None) -&gt; SequencerProgram:\n\"\"\"Load a state notation language program given a file object.\"\"\"\n    return cls.from_string(\n        fp.read(),\n        filename=getattr(fp, \"name\", filename),\n    )\n</code></pre> <code>whatrecord.snl.SequencerProgram.from_string(contents: str, filename: Optional[AnyPath] = None, debug: bool = False) -&gt; SequencerProgram</code> <code>classmethod</code> <p>Load a state notation language file given its string contents.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    contents: str,\n    filename: Optional[AnyPath] = None,\n    debug: bool = False,\n) -&gt; SequencerProgram:\n\"\"\"Load a state notation language file given its string contents.\"\"\"\n    comments = []\n    grammar = lark.Lark.open_from_package(\n        \"whatrecord\",\n        \"snl.lark\",\n        search_paths=(\"grammar\",),\n        parser=\"earley\",\n        # TODO: alternative comment finding method\n        # lexer_callbacks={\"COMMENT\": comments.append},\n        maybe_placeholders=True,\n        propagate_positions=True,\n        debug=debug,\n    )\n\n    search_path = None\n    if filename:\n        search_path = pathlib.Path(filename).resolve().parent\n\n    preprocessed = cls.preprocess(contents, search_path=search_path)\n    proto = _ProgramTransformer(cls, filename).transform(\n        grammar.parse(preprocessed)\n    )\n    proto.comments = comments\n    return proto\n</code></pre> <code>whatrecord.snl.SequencerProgram.preprocess(code: str, search_path: Optional[AnyPath] = None) -&gt; str</code> <code>staticmethod</code> <p>Preprocess the given sequencer code, expanding #include.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>@staticmethod\ndef preprocess(code: str, search_path: Optional[AnyPath] = None) -&gt; str:\n\"\"\"Preprocess the given sequencer code, expanding #include.\"\"\"\n    # Line numbers will be off with this, sadly\n    # The sequencer itself gets around this by using LINE_MARKER tokens\n    # to indicate what file and line the code came from.  This could\n    # be something we support in the future, but it might not be easy\n    # with lark...\n    search_path = pathlib.Path(\".\" if search_path is None else search_path)\n    result = []\n    stack = collections.deque([(search_path, line) for line in code.splitlines()])\n    while stack:\n        search_path, line = stack.popleft()\n        if line.startswith(\"#include\"):\n            _, include_file, *_ = shlex.split(line)\n            include_file = (search_path / include_file).resolve()\n            with open(include_file, \"rt\") as fp:\n                stack.extendleft(\n                    [\n                        (include_file.parent, line)\n                        for line in reversed(fp.read().splitlines())\n                    ]\n                )\n        elif line.startswith(\"#if\"):\n            ...  # sorry; this may break things\n        elif line.startswith(\"#else\"):\n            ...  # sorry; this may break things\n        elif line.startswith(\"#elif\"):\n            ...  # sorry; this may break things\n        elif line.startswith(\"#endif\"):\n            ...  # sorry; this may break things\n        elif line.startswith(\"#define\"):\n            while stack and line.endswith(\"\\\\\"):\n                search_path, line = stack.popleft()\n\n            ...  # sorry; I think we can do better\n        else:\n            result.append(line)\n\n    return \"\\n\".join(result)\n</code></pre>"},{"location":"parsers/#whatrecord.snl.SequencerProgramGraph","title":"<code>whatrecord.snl.SequencerProgramGraph(program: Optional[SequencerProgram] = None, highlight_states: Optional[List[str]] = None, include_code: bool = False)</code>","text":"<p>             Bases: <code>_GraphHelper</code></p> <p>A graph for a SequencerProgram.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>SequencerProgram</code> <p>A program to add.</p> <code>None</code> <p>highlight_states : list of str, optional     List of state names to highlight.</p> <p>include_code : bool, optional     Include code, where relevant, in nodes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>def __init__(\n    self,\n    program: Optional[SequencerProgram] = None,\n    highlight_states: Optional[List[str]] = None,\n    include_code: bool = False,\n):\n    super().__init__()\n    self.include_code = include_code\n    self.highlight_states = highlight_states or []\n    if program is not None:\n        self.add_program(program)\n</code></pre>"},{"location":"parsers/#whatrecord.snl.SequencerProgramGraph-functions","title":"Functions","text":"<code>whatrecord.snl.SequencerProgramGraph.add_program(program: SequencerProgram)</code> <p>Add a program to the graph.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>def add_program(self, program: SequencerProgram):\n\"\"\"Add a program to the graph.\"\"\"\n    for state_set in program.state_sets:\n        for state in state_set.states:\n            self._add_state(program, state_set, state)\n\n    # Only add entry/exit labels if there's an edge\n    if self._entry_label in self.nodes:\n        self.get_node(\n            self._entry_label,\n            self.get_code(program.entry, \"(Startup)\")\n        )\n\n    if self._exit_label in self.nodes:\n        self.get_node(\n            self._exit_label,\n            self.get_code(program.exit, \"(Exit)\")\n        )\n</code></pre> <code>whatrecord.snl.SequencerProgramGraph.get_code(obj, default: str = '')</code> <p>Get code for a node/edge.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/snl.py</code> <pre><code>def get_code(self, obj, default: str = \"\"):\n\"\"\"Get code for a node/edge.\"\"\"\n    if self.include_code and obj is not None:\n        return self.clean_code(str(obj)) or default\n    return default\n</code></pre>"},{"location":"parsers/#whatrecord.snl-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.streamdevice","title":"<code>whatrecord.streamdevice</code>","text":""},{"location":"parsers/#whatrecord.streamdevice-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.streamdevice.StreamDeviceState","title":"<code>whatrecord.streamdevice.StreamDeviceState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ShellStateHandler</code></p> <p>StreamDevice IOC shell state handler / container.</p> <p>Contains hooks for StreamDevice-related commands and state information.</p> <p>Attributes:</p> Name Type Description <code>protocols</code> <code>Dict[str, StreamProtocol]</code> <p>Loaded StreamDevice protocols by name.</p>"},{"location":"parsers/#whatrecord.streamdevice.StreamDeviceState-functions","title":"Functions","text":"<code>whatrecord.streamdevice.StreamDeviceState.annotate_record(record: RecordInstance) -&gt; Optional[Dict[str, Any]]</code> <p>Hook to annotate a record after being loaded.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/streamdevice.py</code> <pre><code>def annotate_record(self, record: RecordInstance) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Hook to annotate a record after being loaded.\"\"\"\n    dtype = record.fields.get(\"DTYP\", None)\n    if not dtype or getattr(dtype, \"value\", None) != \"stream\":\n        return\n\n    info_field = record.fields.get(\"INP\", record.fields.get(\"OUT\", None))\n    if not info_field or isinstance(info_field, PVAFieldReference):\n        return {\n            \"error\": \"INP/OUT not defined correctly\"\n        }\n    if not isinstance(info_field.value, str):\n        return {\n            \"error\": \"INP/OUT not defined correctly (JSON)\"\n        }\n\n    info_field = info_field.value.strip()\n    results = {}\n    try:\n        proto_file, proto_name, *proto_args = split_iocsh_line(info_field).argv\n        proto_file = proto_file.lstrip(\"@ \")\n    except Exception:\n        results[\"error\"] = (\n            f\"Invalid StreamDevice input/output field: {info_field!r}\"\n        )\n        proto_file = None\n        proto_name = None\n        proto_args = []\n    else:\n        try:\n            protocol = self.load_streamdevice_protocol(proto_file)\n        except Exception as ex:\n            results[\"error\"] = f\"{ex.__class__.__name__}: {ex}\"\n        else:\n            if proto_name in protocol.protocols:\n                results[\"protocol\"] = protocol.protocols[proto_name]\n            else:\n                results[\"error\"] = (\n                    f\"Unknown protocol {proto_name!r} in {proto_file}; \"\n                    f\"options are: {list(protocol.protocols)}\"\n                )\n\n    return {\n        \"protocol_file\": proto_file,\n        \"protocol_name\": proto_name,\n        \"protocol_args\": proto_args,\n        **results,\n    }\n</code></pre> <code>whatrecord.streamdevice.StreamDeviceState.load_streamdevice_protocol(filename: AnyPath) -&gt; StreamProtocol</code> <p>Load a StreamDevice protocol file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/streamdevice.py</code> <pre><code>def load_streamdevice_protocol(\n    self,\n    filename: AnyPath,\n) -&gt; StreamProtocol:\n\"\"\"Load a StreamDevice protocol file.\"\"\"\n    filename = self.find_streamdevice_protocol(filename)\n    key = str(filename)\n    if key not in self.protocols:\n        shell_state = self.primary_handler\n        fn, contents = shell_state.load_file(filename)\n        self.protocols[key] = StreamProtocol.from_string(\n            contents,\n            filename=fn\n        )\n    return self.protocols[key]\n</code></pre>"},{"location":"parsers/#whatrecord.streamdevice.StreamProtocol","title":"<code>whatrecord.streamdevice.StreamProtocol</code>  <code>dataclass</code>","text":"<p>Representation of a StreamDevice protocol.</p>"},{"location":"parsers/#whatrecord.streamdevice.StreamProtocol-functions","title":"Functions","text":"<code>whatrecord.streamdevice.StreamProtocol.from_file(fn) -&gt; StreamProtocol</code> <code>classmethod</code> <p>Load a StreamDevice protocol file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path or str</code> <p>The filename.</p> required <p>Returns:</p> Name Type Description <code>protocol</code> <code>StreamProtocol</code> <p>The StreamDevice protocol.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/streamdevice.py</code> <pre><code>@classmethod\ndef from_file(cls, fn) -&gt; StreamProtocol:\n\"\"\"\n    Load a StreamDevice protocol file.\n\n    Parameters\n    ----------\n    filename : pathlib.Path or str\n        The filename.\n\n    Returns\n    -------\n    protocol : StreamProtocol\n        The StreamDevice protocol.\n    \"\"\"\n    with open(fn, \"rt\") as fp:\n        return cls.from_string(fp.read(), filename=fn)\n</code></pre> <code>whatrecord.streamdevice.StreamProtocol.from_file_obj(fp, filename = None) -&gt; StreamProtocol</code> <code>classmethod</code> <p>Load a protocol file given a file object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/streamdevice.py</code> <pre><code>@classmethod\ndef from_file_obj(cls, fp, filename=None) -&gt; StreamProtocol:\n\"\"\"Load a protocol file given a file object.\"\"\"\n    return cls.from_string(\n        fp.read(),\n        filename=getattr(fp, \"name\", filename),\n    )\n</code></pre> <code>whatrecord.streamdevice.StreamProtocol.from_string(contents, filename = None) -&gt; StreamProtocol</code> <code>classmethod</code> <p>Load a protocol file given its string contents.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/streamdevice.py</code> <pre><code>@classmethod\ndef from_string(\n    cls, contents, filename=None,\n) -&gt; StreamProtocol:\n\"\"\"Load a protocol file given its string contents.\"\"\"\n    comments = []\n    grammar = lark.Lark.open_from_package(\n        \"whatrecord\",\n        \"streamdevice.lark\",\n        search_paths=(\"grammar\", ),\n        parser=\"earley\",\n        maybe_placeholders=False,\n        # lexer_callbacks={\"COMMENT\": comments.append},\n    )\n\n    proto = _ProtocolTransformer(cls, filename).transform(\n        grammar.parse(contents)\n    )\n    proto.comments = comments\n    return proto\n</code></pre>"},{"location":"parsers/#whatrecord.streamdevice-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.transformer","title":"<code>whatrecord.transformer</code>","text":"<p>Helpers for writing lark transformers.</p>"},{"location":"parsers/#whatrecord.transformer-classes","title":"Classes","text":""},{"location":"parsers/#whatrecord.transformer-functions","title":"Functions","text":""},{"location":"parsers/#whatrecord.transformer.context_from_token","title":"<code>whatrecord.transformer.context_from_token(fn: str, token: lark.Token) -&gt; FullLoadContext</code>","text":"<p>Get a LoadContext from a lark Token.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>def context_from_token(fn: str, token: lark.Token) -&gt; FullLoadContext:\n\"\"\"Get a LoadContext from a lark Token.\"\"\"\n    return (LoadContext(name=fn, line=token.line), )\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.context_from_tree","title":"<code>whatrecord.transformer.context_from_tree(fn: str, tree: lark.Tree) -&gt; FullLoadContext</code>","text":"<p>Get a LoadContext from a lark Tree.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>def context_from_tree(fn: str, tree: lark.Tree) -&gt; FullLoadContext:\n\"\"\"Get a LoadContext from a lark Tree.\"\"\"\n    return (LoadContext(name=fn, line=tree.meta.line), )\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.dictify","title":"<code>whatrecord.transformer.dictify(*tuples: Tuple[Any, Any]) -&gt; dict</code>  <code>staticmethod</code>","text":"<p>Transformer helper to stringify a single argument.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>@staticmethod\ndef dictify(*tuples: Tuple[Any, Any]) -&gt; dict:\n\"\"\"Transformer helper to stringify a single argument.\"\"\"\n    return dict(tuples)\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.ignore","title":"<code>whatrecord.transformer.ignore(*args: Any) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Transformer helper to drop the subtree.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>@staticmethod\ndef ignore(*args: Any) -&gt; None:\n\"\"\"Transformer helper to drop the subtree.\"\"\"\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.listify","title":"<code>whatrecord.transformer.listify(*objects: Any)</code>  <code>staticmethod</code>","text":"<p>Transformer helper to listify *args.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>@staticmethod\ndef listify(*objects: Any):\n\"\"\"Transformer helper to listify *args.\"\"\"\n    return list(objects)\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.listify_strings","title":"<code>whatrecord.transformer.listify_strings(*objects: Union[str, lark.Token])</code>  <code>staticmethod</code>","text":"<p>Transformer helper to listify *args and stringify each arg.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>@staticmethod\ndef listify_strings(*objects: Union[str, lark.Token]):\n\"\"\"Transformer helper to listify *args and stringify each arg.\"\"\"\n    return list(str(obj) for obj in objects)\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.pass_through","title":"<code>whatrecord.transformer.pass_through(obj: Optional[T] = None) -&gt; Optional[T]</code>  <code>staticmethod</code>","text":"<p>Transformer helper to pass through an optional single argument.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>@staticmethod\ndef pass_through(obj: Optional[T] = None) -&gt; Optional[T]:\n\"\"\"Transformer helper to pass through an optional single argument.\"\"\"\n    return obj\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.stringify","title":"<code>whatrecord.transformer.stringify(obj: lark.Token) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Transformer helper to stringify a single argument.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>@staticmethod\ndef stringify(obj: lark.Token) -&gt; str:\n\"\"\"Transformer helper to stringify a single argument.\"\"\"\n    return str(obj)\n</code></pre>"},{"location":"parsers/#whatrecord.transformer.tuple_args","title":"<code>whatrecord.transformer.tuple_args(*objects: T) -&gt; Tuple[T, ...]</code>  <code>staticmethod</code>","text":"<p>Transformer helper to get back the *args tuple.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/transformer.py</code> <pre><code>@staticmethod\ndef tuple_args(*objects: T) -&gt; Tuple[T, ...]:\n\"\"\"Transformer helper to get back the *args tuple.\"\"\"\n    return objects\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":""},{"location":"plugins/#usage","title":"Usage","text":""},{"location":"plugins/#api","title":"API","text":""},{"location":"plugins/#whatrecord.plugins.happi","title":"<code>whatrecord.plugins.happi</code>","text":"<p>happi whatrecord plugin</p> <p>Match your happi devices to IOCs and records.</p>"},{"location":"plugins/#whatrecord.plugins.happi-classes","title":"Classes","text":""},{"location":"plugins/#whatrecord.plugins.happi-functions","title":"Functions","text":""},{"location":"plugins/#whatrecord.plugins.happi.find_signal_metadata_pairs","title":"<code>whatrecord.plugins.happi.find_signal_metadata_pairs(criteria: CriteriaDict) -&gt; Generator[Tuple[OphydObject, str, EpicsSignalBase], None, None]</code>","text":"<p>Find all signal metadata that match the given criteria.</p> <p>Yields:</p> Name Type Description <code>root</code> <code>OphydObject</code> <p>The root OphydObject - may be the same as signal.  This is guaranteed to have happi metadata on it as the <code>md</code> attribute.</p> <p>pvname : str     The PV name.</p> <p>signal : EpicsSignal, EpicsSignalRO, ...     The signal instance, one of <code>SIGNAL_CLASSES</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/happi.py</code> <pre><code>def find_signal_metadata_pairs(\n    criteria: CriteriaDict,\n) -&gt; Generator[Tuple[OphydObject, str, EpicsSignalBase], None, None]:\n\"\"\"\n    Find all signal metadata that match the given criteria.\n\n    Yields\n    ------\n    root : OphydObject\n        The root OphydObject - may be the same as signal.  This is guaranteed\n        to have happi metadata on it as the ``md`` attribute.\n\n    pvname : str\n        The PV name.\n\n    signal : EpicsSignal, EpicsSignalRO, ...\n        The signal instance, one of ``SIGNAL_CLASSES``.\n    \"\"\"\n\n    attributes = [\n        \"pvname\",\n        \"setpoint_pvname\",\n    ]\n\n    for root, sig in find_signals(criteria, signal_class=SIGNAL_CLASSES):\n        found_pvs = set()\n        for attr in attributes:\n            pvname = getattr(sig, attr, None)\n            if pvname is not None and isinstance(pvname, str):\n                found_pvs.add(pvname)\n\n        if found_pvs:\n            for pvname in sorted(found_pvs):\n                yield root, pvname, sig\n        else:\n            # Then it's the prefix - possibly\n            pvname = getattr(sig, \"prefix\", None)\n            if pvname is not None:\n                yield root, pvname, sig\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.happi.find_signals","title":"<code>whatrecord.plugins.happi.find_signals(criteria: CriteriaDict, signal_class: Type[T]) -&gt; Generator[Tuple[OphydObject, T], None, None]</code>","text":"<p>Find all signal metadata that match the given criteria.</p> <p>Yields:</p> Name Type Description <code>root</code> <code>OphydObject</code> <p>The root OphydObject - may be the same as signal.  This is guaranteed to have happi metadata on it as the <code>md</code> attribute.</p> <p>sig : signal_class     Signals of type <code>signal_class</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/happi.py</code> <pre><code>def find_signals(\n    criteria: CriteriaDict,\n    signal_class: Type[T],\n) -&gt; Generator[Tuple[OphydObject, T], None, None]:\n\"\"\"\n    Find all signal metadata that match the given criteria.\n\n    Yields\n    ------\n    root : OphydObject\n        The root OphydObject - may be the same as signal.  This is guaranteed\n        to have happi metadata on it as the ``md`` attribute.\n\n    sig : signal_class\n        Signals of type `signal_class`.\n    \"\"\"\n\n    patch_and_use_dummy_shim()\n\n    def is_of_class(obj):\n        return isinstance(obj, signal_class)\n\n    if not criteria:\n        devices = get_all_devices()\n    else:\n        devices = get_devices_by_criteria(criteria)\n\n    for dev in devices:\n        if not hasattr(dev, \"md\"):\n            # This should be a guarantee, but check just in case.\n            continue\n\n        for sig in get_components_matching(dev, predicate=is_of_class):\n            yield dev, sig\n        # Top-level devices are OK too\n        if isinstance(dev, signal_class):\n            yield dev, dev\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.happi.get_all_devices","title":"<code>whatrecord.plugins.happi.get_all_devices(client: happi.Client = None) -&gt; Generator[ophyd.Device, None, None]</code>","text":"<p>Get all devices from a given happi client.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The happi client to use.  Defaults to using one from the environment configuration.</p> <code>None</code> <p>Yields:</p> Type Description <code>Device</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/happi.py</code> <pre><code>def get_all_devices(\n    client: happi.Client = None,\n) -&gt; Generator[ophyd.Device, None, None]:\n\"\"\"\n    Get all devices from a given happi client.\n\n    Parameters\n    ----------\n    client : happi.Client, optional\n        The happi client to use.  Defaults to using one from the environment\n        configuration.\n\n    Yields\n    ------\n    ophyd.Device\n    \"\"\"\n    if client is None:\n        client = happi.Client.from_config()\n\n    if hasattr(client.backend, \"_load_or_initialize\"):\n        # HACK: TODO: avoid re-re-re-reading the JSON database; happi needs\n        # some work.\n        loaded_database = client.backend._load_or_initialize()\n        client.backend._load_or_initialize = lambda: loaded_database\n\n    for dev in client:\n        try:\n            obj = client[dev].get()\n        except Exception:\n            logger.exception(\"Failed to instantiate device: %s\", dev)\n        else:\n            yield obj\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.happi.get_all_happi_items","title":"<code>whatrecord.plugins.happi.get_all_happi_items(client: happi.Client) -&gt; Generator[happi.SearchResult, None, None]</code>","text":"<p>Get all happi search results from the given client.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The happi client instance.</p> required <p>Yields:</p> Type Description <code>SearchResult</code> <p>The happi item wrapped in a SearchResult.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/happi.py</code> <pre><code>def get_all_happi_items(client: happi.Client) -&gt; Generator[happi.SearchResult, None, None]:\n\"\"\"\n    Get all happi search results from the given client.\n\n    Parameters\n    ----------\n    client : happi.Client\n        The happi client instance.\n\n    Yields\n    ------\n    SearchResult\n        The happi item wrapped in a SearchResult.\n    \"\"\"\n    for name in client:\n        try:\n            yield client[name]\n        except Exception:\n            logger.debug(\"Failed to get happi item: %s\", name, exc_info=True)\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.happi.get_components_matching","title":"<code>whatrecord.plugins.happi.get_components_matching(obj: ophyd.Device, predicate: callable) -&gt; Generator[OphydObject, None, None]</code>","text":"<p>Find signals of a specific type from a given ophyd Device.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Device</code> <p>The ophyd Device.</p> required <p>predicate : callable     Callable that should return True on a match.</p> <p>Yields:</p> Name Type Description <code>obj</code> <code>OphydObject</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/happi.py</code> <pre><code>def get_components_matching(\n    obj: ophyd.Device,\n    predicate: callable,\n) -&gt; Generator[OphydObject, None, None]:\n\"\"\"\n    Find signals of a specific type from a given ophyd Device.\n\n    Parameters\n    ----------\n    obj : ophyd.Device\n        The ophyd Device.\n\n    predicate : callable\n        Callable that should return True on a match.\n\n    Yields\n    ------\n    obj : OphydObject\n    \"\"\"\n    for name, dev in obj.walk_subdevices(include_lazy=True):\n        try:\n            included = predicate(dev)\n        except Exception:\n            logger.exception(\"Failed to check predicate against %s %s\", name, dev)\n        else:\n            if included:\n                yield dev\n\n    for walk in obj.walk_signals(include_lazy=True):\n        try:\n            included = predicate(walk.item)\n        except Exception:\n            logger.exception(\"Failed to check predicate against %s\", walk)\n        else:\n            if included:\n                yield walk.item\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.happi.get_devices_by_criteria","title":"<code>whatrecord.plugins.happi.get_devices_by_criteria(search_criteria: CriteriaDict, *, client: happi.Client = None, regex: bool = True) -&gt; Generator[ophyd.Device, None, None]</code>","text":"<p>Get all devices from a given happi client.</p> <p>Parameters:</p> Name Type Description Default <code>search_criteria</code> <code>dict</code> <p>Dictionary of <code>{'happi_key': 'search_value'}</code>.</p> required <p>client : happi.Client, optional     The happi client to use.  Defaults to using one from the environment     configuration.</p> <p>Yields:</p> Type Description <code>Device</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/happi.py</code> <pre><code>def get_devices_by_criteria(\n    search_criteria: CriteriaDict,\n    *,\n    client: happi.Client = None,\n    regex: bool = True,\n) -&gt; Generator[ophyd.Device, None, None]:\n\"\"\"\n    Get all devices from a given happi client.\n\n    Parameters\n    ----------\n    search_criteria : dict\n        Dictionary of ``{'happi_key': 'search_value'}``.\n\n    client : happi.Client, optional\n        The happi client to use.  Defaults to using one from the environment\n        configuration.\n\n    Yields\n    ------\n    ophyd.Device\n    \"\"\"\n    if client is None:\n        client = happi.Client.from_config()\n\n    search_method = client.search_regex if regex else client.search\n    for item in search_method(**search_criteria):\n        try:\n            obj = item.get()\n        except Exception:\n            logger.exception(\"Failed to instantiate device: %s\", obj)\n        else:\n            yield obj\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.happi.patch_and_use_dummy_shim","title":"<code>whatrecord.plugins.happi.patch_and_use_dummy_shim()</code>","text":"<p>Hack ophyd and its dummy shim.  We don't want any control-layer connections being made while we're looking for signals.</p>"},{"location":"plugins/#whatrecord.plugins.happi.patch_and_use_dummy_shim--warning","title":"Warning","text":"<p>Under no circumstances should this be used in a production environment where you intend to actually use ophyd for its intended purpose.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/happi.py</code> <pre><code>def patch_and_use_dummy_shim():\n\"\"\"\n    Hack ophyd and its dummy shim.  We don't want _any_ control-layer\n    connections being made while we're looking for signals.\n\n    Warning\n    -------\n    Under no circumstances should this be used in a production environment\n    where you intend to actually _use_ ophyd for its intended purpose.\n    \"\"\"\n    ophyd.Device.lazy_wait_for_connection = False\n\n    def _no_op(*args, **kwargs):\n        ...\n\n    class _PVStandIn:\n        _reference_count = 0\n\n        def __init__(self, pvname, *args, **kwargs):\n            self.pvname = pvname\n            self.connected = True\n\n        add_callback = _no_op\n        remove_callback = _no_op\n        clear_callbacks = _no_op\n        get = _no_op\n        put = _no_op\n        get_with_metadata = _no_op\n        wait_for_connection = _no_op\n\n    def get_pv(pvname, *args, **kwargs):\n        return _PVStandIn(pvname)\n\n    from ophyd import _dummy_shim\n\n    _dummy_shim.get_pv = get_pv\n    _dummy_shim.release_pvs = _no_op\n    ophyd.set_cl(\"dummy\")\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.netconfig","title":"<code>whatrecord.plugins.netconfig</code>","text":"<p>LDAP Configuration summary plugin</p>"},{"location":"plugins/#whatrecord.plugins.netconfig-classes","title":"Classes","text":""},{"location":"plugins/#whatrecord.plugins.netconfig-functions","title":"Functions","text":""},{"location":"plugins/#whatrecord.plugins.netconfig.decode_ldap_attrs","title":"<code>whatrecord.plugins.netconfig.decode_ldap_attrs(attrs: Dict[str, List[bytes]], encoding: Dict[str, List[bytes]] = LDAP_ENCODING) -&gt; Dict[str, List[str]]</code>","text":"<p>Decode byte-filled LDAP attrs dictionary.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/plugins/netconfig.py</code> <pre><code>def decode_ldap_attrs(\n    attrs: Dict[str, List[bytes]], encoding=LDAP_ENCODING\n) -&gt; Dict[str, List[str]]:\n\"\"\"Decode byte-filled LDAP attrs dictionary.\"\"\"\n    def decode_value(key: str, value: List[bytes]):\n        return [part.decode(encoding, \"replace\") for part in value]\n\n    return {key: decode_value(key, value) for key, value in attrs.items()}\n</code></pre>"},{"location":"plugins/#whatrecord.plugins.util","title":"<code>whatrecord.plugins.util</code>","text":""},{"location":"plugins/#whatrecordpluginsgdb_binary_info","title":"whatrecord.plugins.gdb_binary_info","text":"<p>A GDB script to get useful information out of IOC binaries.</p>"},{"location":"server_client/","title":"Server / client","text":""},{"location":"server_client/#starting-the-backend-api-server","title":"Starting the backend API server","text":"<p>With the provided test-suite IOCs:</p> <pre><code>$ whatrecord server --scripts whatrecord/tests/iocs/*/st.cmd\n</code></pre> <p>Gateway configuration among others can be specified separately, if available.</p>"},{"location":"server_client/#starting-the-frontend","title":"Starting the frontend","text":"<p>Install dependencies:</p> <pre><code>$ conda install -c conda-forge nodejs\n$ cd frontend\n$ yarn install\n</code></pre> <p>Compile and reload automatically when frontend files change:</p> <pre><code>$ yarn serve\n</code></pre> <p>Or alternatively compile and minify for production:</p> <pre><code>$ yarn build\n</code></pre>"},{"location":"server_client/#tweaking-frontend-settings","title":"Tweaking frontend settings","text":"<p>In <code>frontend/.env.local</code>:</p> <pre><code>API_HOST=localhost\nAPI_PORT=8898\nFRONTEND_PORT=8899\nWHATRECORD_PLUGINS=happi twincat_pytmc\n\n# The following is accessible in the vue frontend:\nVUE_APP_WHATRECORD_PLUGINS=$WHATRECORD_PLUGINS\n</code></pre>"},{"location":"server_client/#general-flow","title":"General flow","text":"<p>Using the core tools: * Load up all EPICS IOCs listed in IOC manager     - Load the startup scripts     - Load all the databases and supported files * Provide a backend service for querying the information * Based on the backend server, provide a frontend for easy access to that information     - vue.js-based frontend single-page application     - Search for records/IOCs/etc by name and dig into the details...</p>"},{"location":"server_client/#api","title":"API","text":""},{"location":"server_client/#whatrecord.ioc_finder","title":"<code>whatrecord.ioc_finder</code>","text":""},{"location":"server_client/#whatrecord.ioc_finder-classes","title":"Classes","text":""},{"location":"server_client/#whatrecord.ioc_finder.IocScriptExternalLoader","title":"<code>whatrecord.ioc_finder.IocScriptExternalLoader</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_IocInfoFinder</code></p> <p>An IOC information \"finder\" that utilizes an external executable script.</p> <p>That script must return a JSON object that is compatible with <code>IocMetadata.from_dict</code>.</p>"},{"location":"server_client/#whatrecord.ioc_finder.IocScriptStaticInfoList","title":"<code>whatrecord.ioc_finder.IocScriptStaticInfoList</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_IocInfoFinder</code></p> <p>An IOC information \"finder\" that is provided a list of IOC information dictionaries.</p> <p>This is mainly LCLS-specific as it integrates with their \"IOC Manager\" utility.</p>"},{"location":"server_client/#whatrecord.ioc_finder.IocScriptStaticList","title":"<code>whatrecord.ioc_finder.IocScriptStaticList</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_IocInfoFinder</code></p> <p>An IOC finder that does not do much finding; it expects a static list of scripts to load at startup.</p>"},{"location":"server_client/#whatrecord.ioc_finder-functions","title":"Functions","text":""},{"location":"server_client/#whatrecord.client","title":"<code>whatrecord.client</code>","text":""},{"location":"server_client/#whatrecord.client-functions","title":"Functions","text":""},{"location":"server_client/#whatrecord.client.get_iocs","title":"<code>whatrecord.client.get_iocs(pattern: str = '*', server: Optional[str] = None, regex: bool = False) -&gt; IocGetMatchesResponse</code>  <code>async</code>","text":"<p>Get record information from the server.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/client.py</code> <pre><code>async def get_iocs(\n    pattern: str = \"*\", server: Optional[str] = None, regex: bool = False\n) -&gt; IocGetMatchesResponse:\n\"\"\"Get record information from the server.\"\"\"\n    response = await make_query(\n        \"/api/ioc/matches\", server=server, params=dict(pattern=pattern, regex=str(regex))\n    )\n    return apischema.deserialize(IocGetMatchesResponse, response)\n</code></pre>"},{"location":"server_client/#whatrecord.client.get_record_info","title":"<code>whatrecord.client.get_record_info(*records, server: Optional[str] = None) -&gt; Dict[str, PVGetInfo]</code>  <code>async</code>","text":"<p>Get record information from the server.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/client.py</code> <pre><code>async def get_record_info(*records, server: Optional[str] = None) -&gt; Dict[str, PVGetInfo]:\n\"\"\"Get record information from the server.\"\"\"\n    response = await make_query(\"/api/pv/info\", server=server, params=dict(pv=list(records)))\n    return apischema.deserialize(Dict[str, PVGetInfo], response)\n</code></pre>"},{"location":"server_client/#whatrecord.server","title":"<code>whatrecord.server</code>","text":""},{"location":"server_client/#whatrecord.server.common","title":"<code>whatrecord.server.common</code>","text":""},{"location":"server_client/#whatrecord.server.common-classes","title":"Classes","text":""},{"location":"server_client/#whatrecord.server.common.PluginResults","title":"<code>whatrecord.server.common.PluginResults</code>  <code>dataclass</code>","text":""},{"location":"server_client/#whatrecord.server.common.PluginResults-functions","title":"Functions","text":"<code>whatrecord.server.common.PluginResults.find_by_key(key: str) -&gt; Generator[Tuple[str, Any], None, None]</code> <p>Find all metadata for the given record name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/common.py</code> <pre><code>def find_by_key(self, key: str) -&gt; Generator[Tuple[str, Any], None, None]:\n\"\"\"Find all metadata for the given record name.\"\"\"\n    md = self.metadata_by_key.get(key, None)\n    if md is not None:\n        yield key, md\n\n    for nest_key, nested in (self.nested or {}).items():\n        for sub_key, info in nested.find_by_key(key):\n            yield f\"{nest_key}:{sub_key}\", info\n</code></pre> <code>whatrecord.server.common.PluginResults.find_record_metadata(record: str) -&gt; Generator[Any, None, None]</code> <p>Find all metadata for the given record name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/common.py</code> <pre><code>def find_record_metadata(self, record: str) -&gt; Generator[Any, None, None]:\n\"\"\"Find all metadata for the given record name.\"\"\"\n    for key in self.record_to_metadata_keys.get(record) or []:\n        try:\n            yield self.metadata_by_key[key]\n        except KeyError:\n            logger.debug(\n                \"Consistency error in plugin: missing metadata key(s) %r \"\n                \"for record %s\",\n                key, record\n            )\n\n    for nested in (self.nested or {}).values():\n        yield from nested.find_record_metadata(record)\n</code></pre> <code>whatrecord.server.common.PluginResults.is_loaded_file(fn: str) -&gt; bool</code> <p>Is the given file one that was loaded in the plugin?</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/common.py</code> <pre><code>def is_loaded_file(self, fn: str) -&gt; bool:\n\"\"\"Is the given file one that was loaded in the plugin?\"\"\"\n    if fn in self.files_to_monitor:\n        return True\n    return any(\n        nested.is_loaded_file(fn)\n        for nested in (self.nested or {}).values()\n    )\n</code></pre>"},{"location":"server_client/#whatrecord.server.common.ServerPluginSpec","title":"<code>whatrecord.server.common.ServerPluginSpec</code>  <code>dataclass</code>","text":""},{"location":"server_client/#whatrecord.server.common.ServerPluginSpec-attributes","title":"Attributes","text":"<code>whatrecord.server.common.ServerPluginSpec.script: str</code> <code>property</code> <p>The script and arguments to run for the plugin.</p>"},{"location":"server_client/#whatrecord.server.common.ServerPluginSpec-functions","title":"Functions","text":"<code>whatrecord.server.common.ServerPluginSpec.update() -&gt; Optional[PluginResults]</code> <code>async</code> <p>Call the plugin and get new information, storing it in results.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/common.py</code> <pre><code>async def update(self) -&gt; Optional[PluginResults]:\n\"\"\"Call the plugin and get new information, storing it in results.\"\"\"\n    self.results_json = (\n        await util.run_script_with_json_output(self.script)\n    ) or {}\n    self.files_to_monitor = self.results_json.get(\"files_to_monitor\", {})\n    self.results = apischema.deserialize(PluginResults, self.results_json)\n    if self.results:\n        self.files_to_monitor = self.results.files_to_monitor\n    return self.results\n</code></pre>"},{"location":"server_client/#whatrecord.server.server","title":"<code>whatrecord.server.server</code>","text":""},{"location":"server_client/#whatrecord.server.server-classes","title":"Classes","text":""},{"location":"server_client/#whatrecord.server.server.ServerHandler","title":"<code>whatrecord.server.server.ServerHandler(state: ServerState)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def __init__(self, state: ServerState):\n    self.state = state\n</code></pre>"},{"location":"server_client/#whatrecord.server.server.ServerHandler-functions","title":"Functions","text":"<code>whatrecord.server.server.ServerHandler.api_pv_get_duplicates(request: web.Request)</code> <code>async</code> <p>Get record names duplicated among two or more IOCs.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>@routes.get(\"/api/pv/duplicates\")\nasync def api_pv_get_duplicates(self, request: web.Request):\n\"\"\"Get record names duplicated among two or more IOCs.\"\"\"\n    use_regex, patterns = get_patterns(request.query)\n    return serialized_response(\n        IocGetDuplicatesResponse(\n            patterns=patterns,\n            regex=use_regex,\n            duplicates=self.state.get_duplicates(patterns, use_regex=use_regex),\n        )\n    )\n</code></pre>"},{"location":"server_client/#whatrecord.server.server.ServerState","title":"<code>whatrecord.server.server.ServerState(startup_scripts: Optional[List[str]] = None, script_loaders: Optional[List[str]] = None, standin_directories: Optional[Dict[str, str]] = None, gateway_config: Optional[str] = None, plugins: Optional[List[ServerPluginSpec]] = None)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def __init__(\n    self,\n    startup_scripts: Optional[List[str]] = None,\n    script_loaders: Optional[List[str]] = None,\n    standin_directories: Optional[Dict[str, str]] = None,\n    gateway_config: Optional[str] = None,\n    plugins: Optional[List[ServerPluginSpec]] = None,\n):\n    self.running = False\n    self.container = ScriptContainer()\n    self.gateway_config = None\n    self.gateway_config_path = gateway_config\n    self.ioc_metadata = []\n    self.plugins = plugins or []\n    self.plugins_by_name = {\n        plugin.name: plugin\n        for plugin in plugins or []\n    }\n    self.script_relations = {}\n    self.standin_directories = standin_directories or {}\n    self.tasks = TaskHandler()\n    self.script_loaders = [\n        ioc_finder.IocScriptStaticList(startup_scripts or [])\n    ] + [\n        ioc_finder.IocScriptExternalLoader(loader)\n        for loader in script_loaders or []\n    ]\n    self._update_count = 0\n</code></pre>"},{"location":"server_client/#whatrecord.server.server.ServerState-attributes","title":"Attributes","text":"<code>whatrecord.server.server.ServerState.aliases: Dict[str, str]</code> <code>property</code> <p>The CA/V3 aliases.</p> <code>whatrecord.server.server.ServerState.database: Dict[str, RecordInstance]</code> <code>property</code> <p>The CA/V3 Database of records.</p> <code>whatrecord.server.server.ServerState.iocs_by_name: Dict[str, IocMetadata]</code> <code>property</code> <p>Dictionary of IOC name to IocMetadata.</p> <code>whatrecord.server.server.ServerState.pva_database: Dict[str, RecordInstance]</code> <code>property</code> <p>The pvAccess Database of groups/records.</p> <code>whatrecord.server.server.ServerState.update_count: int</code> <code>property</code> <p>The number of times IOCs have been updated.</p>"},{"location":"server_client/#whatrecord.server.server.ServerState-functions","title":"Functions","text":"<code>whatrecord.server.server.ServerState.add_or_update_ioc_metadata(md: IocMetadata)</code> <p>Add a new IOC to monitor by its metadata.</p> <p>Note: an assumption is made here that an IOC name is unique among all those loaded.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def add_or_update_ioc_metadata(self, md: IocMetadata):\n\"\"\"\n    Add a new IOC to monitor by its metadata.\n\n    Note: an assumption is made here that an IOC name is unique among all\n    those loaded.\n    \"\"\"\n    try:\n        existing = self.iocs_by_name[md.name]\n    except KeyError:\n        self.ioc_metadata.append(md)\n    else:\n        existing.update(md)\n</code></pre> <code>whatrecord.server.server.ServerState.annotate_whatrec(ioc: LoadedIoc, what: WhatRecord) -&gt; WhatRecord</code> <p>Annotate WhatRecord instances with things ServerState knows about.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def annotate_whatrec(self, ioc: LoadedIoc, what: WhatRecord) -&gt; WhatRecord:\n\"\"\"\n    Annotate WhatRecord instances with things ServerState knows about.\n    \"\"\"\n    matches = [\n        (what.record.instance if what.record else None),\n        what.pva_group\n    ]\n    for instance in matches:\n        if instance is None:\n            continue\n\n        md = self.get_record_annnotations(ioc, instance)\n        instance.metadata.update(md)\n\n    return what\n</code></pre> <code>whatrecord.server.server.ServerState.get_duplicates(patterns: Tuple[str, ...], use_regex: bool = False) -&gt; Dict[str, List[str]]</code> <code>cached</code> <p>Get duplicate PVs from the matching IOC(s).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>@functools.lru_cache(maxsize=20)\ndef get_duplicates(\n    self, patterns: Tuple[str, ...], use_regex: bool = False\n) -&gt; Dict[str, List[str]]:\n\"\"\"Get duplicate PVs from the matching IOC(s).\"\"\"\n    iocs = self.get_matching_iocs(patterns, use_regex=use_regex)\n    seen = collections.defaultdict(list)\n    for ioc in iocs:\n        shell_state: ShellState = ioc.shell_state\n        for record in set(shell_state.database).union(shell_state.pva_database):\n            seen[record].append(ioc.name)\n    return {\n        record: iocs\n        for record, iocs in seen.items()\n        if len(iocs) &gt; 1\n    }\n</code></pre> <code>whatrecord.server.server.ServerState.get_gateway_matches(pvname: str) -&gt; Optional[gateway.PVListMatches]</code> <code>cached</code> <p>Get gateway matches for the given pvname.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>@functools.lru_cache(maxsize=2048)\ndef get_gateway_matches(self, pvname: str) -&gt; Optional[gateway.PVListMatches]:\n\"\"\"Get gateway matches for the given pvname.\"\"\"\n    if self.gateway_config is None:\n        return None\n    return self.gateway_config.get_matches(pvname)\n</code></pre> <code>whatrecord.server.server.ServerState.get_graph_rendered(pv_names: Tuple[str, ...], format: str, graph_type: str) -&gt; bytes</code> <code>async</code> <p>Get a rendered PV relationship graph of the provided PVs.</p> <p>Parameters:</p> Name Type Description Default <code>pv_names</code> <code>tuple of str</code> <p>PV names.</p> required <p>format : str     The format of the graph (e.g., pdf, png).</p> <p>graph_type : { \"record\", \"script\" }     The type of graph to generate.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>async def get_graph_rendered(\n    self, pv_names: Tuple[str, ...], format: str, graph_type: str\n) -&gt; bytes:\n\"\"\"\n    Get a rendered PV relationship graph of the provided PVs.\n\n    Parameters\n    ----------\n    pv_names : tuple of str\n        PV names.\n\n    format : str\n        The format of the graph (e.g., pdf, png).\n\n    graph_type : { \"record\", \"script\" }\n        The type of graph to generate.\n    \"\"\"\n    graph = self.get_graph(pv_names, graph_type=graph_type)\n\n    with tempfile.NamedTemporaryFile(suffix=f\".{format}\") as source_file:\n        rendered_filename = await graph.async_render(\n            source_file.name, format=format\n        )\n\n    with open(rendered_filename, \"rb\") as fp:\n        return fp.read()\n</code></pre> <code>whatrecord.server.server.ServerState.get_matching_iocs(patterns: Tuple[str, ...], use_regex: bool = False) -&gt; List[LoadedIoc]</code> <code>cached</code> <p>Get matching IOCs given pattern(s).</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>list of str</code> <p>List of patterns in glob or regex format.</p> required <p>use_regex : bool, optional     Interpret patterns as glob (False) or regex (True).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>@functools.lru_cache(maxsize=2048)\ndef get_matching_iocs(\n    self, patterns: Tuple[str, ...], use_regex: bool = False\n) -&gt; List[LoadedIoc]:\n\"\"\"\n    Get matching IOCs given pattern(s).\n\n    Parameters\n    ----------\n    patterns : list of str\n        List of patterns in glob or regex format.\n\n    use_regex : bool, optional\n        Interpret patterns as glob (False) or regex (True).\n    \"\"\"\n    try:\n        regex = compile_patterns(patterns, use_regex=use_regex)\n    except re.error:\n        return []\n\n    def by_name(ioc: LoadedIoc):\n        return ioc.name\n\n    return [\n        loaded_ioc\n        for loaded_ioc in sorted(self.container.scripts.values(), key=by_name)\n        if regex.match(loaded_ioc.script.path)\n        or regex.match(loaded_ioc.metadata.name)\n    ]\n</code></pre> <code>whatrecord.server.server.ServerState.get_matching_pvs(patterns: Tuple[str, ...], use_regex: bool = False) -&gt; List[str]</code> <code>cached</code> <p>Get matching PV names given pattern(s).</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>list of str</code> <p>List of patterns in glob or regex format.</p> required <p>use_regex : bool, optional     Interpret patterns as glob (False) or regex (True).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>@functools.lru_cache(maxsize=2048)\ndef get_matching_pvs(self, patterns: Tuple[str, ...], use_regex: bool = False) -&gt; List[str]:\n\"\"\"\n    Get matching PV names given pattern(s).\n\n    Parameters\n    ----------\n    patterns : list of str\n        List of patterns in glob or regex format.\n\n    use_regex : bool, optional\n        Interpret patterns as glob (False) or regex (True).\n    \"\"\"\n    try:\n        regex = compile_patterns(patterns, use_regex=use_regex)\n    except re.error:\n        return []\n\n    pv_names = set(self.database) | set(self.pva_database) | set(self.aliases)\n    return [pv_name for pv_name in sorted(pv_names) if regex.match(pv_name)]\n</code></pre> <code>whatrecord.server.server.ServerState.get_plugin_info(allow_list: Optional[List[str]] = None) -&gt; Dict[str, Any]</code> <p>Get plugin information as a dictionary.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def get_plugin_info(self, allow_list: Optional[List[str]] = None) -&gt; Dict[str, Any]:\n\"\"\"Get plugin information as a dictionary.\"\"\"\n    if allow_list is None:\n        allow_list = [plugin.name for plugin in self.plugins]\n\n    return {\n        plugin.name: plugin.results_json\n        for plugin in self.plugins\n        if plugin.name in allow_list and plugin.results\n    }\n</code></pre> <code>whatrecord.server.server.ServerState.get_plugin_nested_info(plugin_name: str, key: str) -&gt; Any</code> <p>Get plugin custom nested metadata info.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def get_plugin_nested_info(self, plugin_name: str, key: str) -&gt; Any:\n\"\"\"Get plugin custom nested metadata info.\"\"\"\n    results = self.plugins_by_name[plugin_name].results\n    return results.nested[key] if results else {}\n</code></pre> <code>whatrecord.server.server.ServerState.get_plugin_nested_keys(plugin_name: str) -&gt; List[str]</code> <p>Get plugin custom nested metadata keys.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def get_plugin_nested_keys(self, plugin_name: str) -&gt; List[str]:\n\"\"\"Get plugin custom nested metadata keys.\"\"\"\n    plugin = self.plugins_by_name[plugin_name]\n    if plugin.results and plugin.results.nested:\n        return list(plugin.results.nested)\n    return []\n</code></pre> <code>whatrecord.server.server.ServerState.get_record_annnotations(ioc: LoadedIoc, instance: RecordInstance) -&gt; Dict[StringWithContext, Any]</code> <p>Get IOC/plugin-provided annotations for the given record.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def get_record_annnotations(\n    self,\n    ioc: LoadedIoc,\n    instance: RecordInstance,\n) -&gt; Dict[StringWithContext, Any]:\n\"\"\"\n    Get IOC/plugin-provided annotations for the given record.\n    \"\"\"\n    md = {}\n\n    if not instance.is_pva:\n        # For now, V3 only\n        gateway_key = StringWithContext(\"gateway\", context=())\n        md[gateway_key] = apischema.serialize(\n            self.get_gateway_matches(instance.name)\n        )\n\n        md.update(ioc.shell_state.annotate_record(instance))\n\n    for plugin in self.plugins:\n        if not plugin.results:\n            continue\n\n        info = list(plugin.results.find_record_metadata(instance.name))\n        if info:\n            plugin_key = StringWithContext(plugin.name, context=())\n            instance.metadata[plugin_key] = info\n\n    return md\n</code></pre> <code>whatrecord.server.server.ServerState.get_updated_iocs() -&gt; List[IocMetadata]</code> <p>Check loaded IOCs for any changes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def get_updated_iocs(self) -&gt; List[IocMetadata]:\n\"\"\"Check loaded IOCs for any changes.\"\"\"\n    updated = [\n        md for md in self.ioc_metadata\n        if not md.is_up_to_date()\n    ]\n    for item in list(updated):\n        if not item.script or not item.script.exists() or item.looks_like_sh:\n            if self.update_count == 0:\n                # Don't attempt another load unless the file exists\n                updated.remove(item)\n\n    return updated\n</code></pre> <code>whatrecord.server.server.ServerState.is_loaded_file(fn) -&gt; bool</code> <p>Is <code>fn</code> a file that was loaded?</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def is_loaded_file(self, fn) -&gt; bool:\n\"\"\"Is ``fn`` a file that was loaded?\"\"\"\n    fn = str(fn)\n    if fn in self.container.loaded_files:\n        return True\n\n    return any(\n        plugin.results.is_loaded_file(fn)\n        for plugin in self.plugins\n        if plugin.results is not None\n    )\n</code></pre> <code>whatrecord.server.server.ServerState.stop()</code> <code>async</code> <p>Stop any background updates.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>async def stop(self):\n\"\"\"Stop any background updates.\"\"\"\n    self.running = False\n    await self.tasks.cancel_all(wait=True)\n</code></pre> <code>whatrecord.server.server.ServerState.trigger_manual_update(annotate_records: bool = True) -&gt; None</code> <code>async</code> <p>Manual re-scan of everything.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>async def trigger_manual_update(self, annotate_records: bool = True) -&gt; None:\n\"\"\"Manual re-scan of everything.\"\"\"\n    updated = await self._update_script_step()\n    logger.debug(\n        \"Manual update trigger. Updates %s\",\n        \"found\" if updated else \"not found\",\n    )\n    for plugin in self.plugins:\n        await self._update_plugin(plugin)\n\n    # self.container.pv_relations = graph.build_database_relations(\n    #     database=self.container.database,\n    #     record_types=self.container.record_types,  # &lt;-- inaccurate?\n    #     aliases=self.container.aliases,\n    # )\n    self.script_relations = graph.build_script_relations(\n        self.container.database,\n        self.container.pv_relations,\n    )\n\n    if not annotate_records:\n        return\n\n    for ioc in self.container.scripts.values():\n        logger.info(\n            \"Annotating %d records for IOC %s\",\n            len(ioc.shell_state.database), ioc.name,\n        )\n        for record in ioc.shell_state.database.values():\n            record.metadata.update(self.get_record_annnotations(ioc, record))\n            for fn, hash_ in ioc.shell_state.loaded_files.items():\n                if fn not in self.container.loaded_files:\n                    logger.info(\n                        \"Record annotation for %s loaded a new file dynamically: %s (%s)\",\n                        ioc.name,\n                        fn,\n                        hash_,\n                    )\n                    self.container.loaded_files[fn] = hash_\n</code></pre> <code>whatrecord.server.server.ServerState.update_iocs(iocs: List[IocMetadata])</code> <code>async</code> <p>Reload the provided IOCs.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>async def update_iocs(self, iocs: List[IocMetadata]):\n\"\"\"Reload the provided IOCs.\"\"\"\n    async for md, loaded in load_startup_scripts_with_metadata(\n        *iocs, standin_directories=self.standin_directories\n    ):\n        self.container.add_loaded_ioc(loaded)\n        self._replace_metadata(md, loaded.metadata)\n\n        # Let plugins update, if possible\n        await asyncio.sleep(0)\n\n    with common.time_context() as ctx:\n        self.script_relations = graph.build_script_relations(\n            self.container.database,\n            self.container.pv_relations,\n        )\n\n    logger.info(\"Updated script relations in %.1f s\", ctx())\n    self._update_count += 1\n</code></pre> <code>whatrecord.server.server.ServerState.update_script_loaders()</code> <code>async</code> <p>Update scripts from the script loader and watch for updates.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>async def update_script_loaders(self):\n\"\"\"Update scripts from the script loader and watch for updates.\"\"\"\n    for loader in self.script_loaders:\n        await loader.update()\n        for _, md in loader.scripts.items():\n            self.add_or_update_ioc_metadata(md)\n</code></pre> <code>whatrecord.server.server.ServerState.whatrec(pvname: str) -&gt; List[WhatRecord]</code> <p>Find WhatRecord matches.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def whatrec(self, pvname: str) -&gt; List[WhatRecord]:\n\"\"\"Find WhatRecord matches.\"\"\"\n    results = []\n    for loaded_ioc in self.container.scripts.values():\n        what = loaded_ioc.whatrec(pvname)\n        if what is not None:\n            self.annotate_whatrec(loaded_ioc, what)\n            results.append(what)\n    return results\n</code></pre>"},{"location":"server_client/#whatrecord.server.server-functions","title":"Functions","text":""},{"location":"server_client/#whatrecord.server.server.compile_patterns","title":"<code>whatrecord.server.server.compile_patterns(patterns: Tuple[str, ...], flags: Tuple[str, ...] = re.IGNORECASE, use_regex: Tuple[str, ...] = False)</code>","text":"<p>Compile regular expression (or glob) patterns with <code>re.compile</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def compile_patterns(patterns: Tuple[str, ...], flags=re.IGNORECASE, use_regex=False):\n\"\"\"Compile regular expression (or glob) patterns with `re.compile`.\"\"\"\n    if use_regex:\n        return re.compile(\"|\".join(patterns), flags=flags)\n\n    return re.compile(\n        \"|\".join(fnmatch.translate(pattern) for pattern in patterns),\n        flags=flags,\n    )\n</code></pre>"},{"location":"server_client/#whatrecord.server.server.get_patterns","title":"<code>whatrecord.server.server.get_patterns(query, key: str = 'pattern', regex_key: str = 'regex') -&gt; Tuple[bool, Tuple[str, ...]]</code>","text":"<p>Get glob/regex patterns from a server query.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def get_patterns(\n    query, key: str = \"pattern\", regex_key: str = \"regex\"\n) -&gt; Tuple[bool, Tuple[str, ...]]:\n\"\"\"Get glob/regex patterns from a server query.\"\"\"\n    use_regex = query.get(regex_key, \"false\").lower() in TRUE_VALUES\n    default = (\".*\" if use_regex else \"*\",)\n    return use_regex, tuple(query.getall(key, default))\n</code></pre>"},{"location":"server_client/#whatrecord.server.server.serialized_response","title":"<code>whatrecord.server.server.serialized_response(obj: Any) -&gt; web.Response</code>","text":"<p>Return an apischema-serialized JSON response of a dataclass instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/server.py</code> <pre><code>def serialized_response(obj: Any) -&gt; web.Response:\n\"\"\"Return an apischema-serialized JSON response of a dataclass instance.\"\"\"\n    return web.json_response(apischema.serialize(obj))\n</code></pre>"},{"location":"server_client/#whatrecord.server.util","title":"<code>whatrecord.server.util</code>","text":""},{"location":"server_client/#whatrecord.server.util-classes","title":"Classes","text":""},{"location":"server_client/#whatrecord.server.util.TaskHandler","title":"<code>whatrecord.server.util.TaskHandler()</code>","text":"<p>Helper to manage asyncio tasks in one spot.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/util.py</code> <pre><code>def __init__(self):\n    self.tasks = []\n    self._lock = threading.Lock()\n</code></pre>"},{"location":"server_client/#whatrecord.server.util.TaskHandler-functions","title":"Functions","text":"<code>whatrecord.server.util.TaskHandler.create(coro)</code> <p>Schedule the execution of a coroutine object in a spawn task.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/server/util.py</code> <pre><code>def create(self, coro):\n\"\"\"Schedule the execution of a coroutine object in a spawn task.\"\"\"\n    task = asyncio.create_task(coro)\n    with self._lock:\n        self.tasks.append(task)\n    task.add_done_callback(self._remove_completed_task)\n    return task\n</code></pre>"},{"location":"tests/","title":"Tests","text":""},{"location":"tests/#api","title":"API","text":""},{"location":"tests/#whatrecord.tests","title":"<code>whatrecord.tests</code>","text":""},{"location":"utilities/","title":"Shared / Utilities","text":""},{"location":"utilities/#macros","title":"Macros","text":""},{"location":"utilities/#whatrecord.macro","title":"<code>whatrecord.macro</code>","text":""},{"location":"utilities/#whatrecord.macro-classes","title":"Classes","text":""},{"location":"utilities/#whatrecord.macro.PassthroughMacroContext","title":"<code>whatrecord.macro.PassthroughMacroContext</code>","text":"<p>             Bases: <code>MacroContext</code></p> <p>A stand-in MacroContext which performs no macro expansion.</p> <p>That is, a pass-through/no-operation macro context.</p>"},{"location":"utilities/#whatrecord.macro-functions","title":"Functions","text":""},{"location":"utilities/#whatrecord.macro.macros_from_string","title":"<code>whatrecord.macro.macros_from_string(macro_string: str, use_environment: bool = False) -&gt; Dict[str, str]</code>","text":"<p>Get a macro dictionary from a macro string.</p> <p>Parameters:</p> Name Type Description Default <code>macro_string</code> <code>str</code> <p>The macro string, in the format A=B,C=D,...</p> required <p>use_environment : bool, optional     Use environment variables as well.  Defaults to False.</p> <p>Returns:</p> Name Type Description <code>macros</code> <code>Dict[str, str]</code> <p>Macro key to value.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/macro.py</code> <pre><code>def macros_from_string(\n    macro_string: str, use_environment: bool = False\n) -&gt; Dict[str, str]:\n\"\"\"\n    Get a macro dictionary from a macro string.\n\n    Parameters\n    ----------\n    macro_string : str\n        The macro string, in the format A=B,C=D,...\n\n    use_environment : bool, optional\n        Use environment variables as well.  Defaults to False.\n\n    Returns\n    -------\n    macros : Dict[str, str]\n        Macro key to value.\n    \"\"\"\n    if not macro_string.strip():\n        return {}\n    macro_context = MacroContext(use_environment=use_environment)\n    return macro_context.define_from_string(macro_string)\n</code></pre>"},{"location":"utilities/#whatrecord.macro.set_serialization_settings","title":"<code>whatrecord.macro.set_serialization_settings(skip: Optional[str] = settings.MACRO_KEY_SKIP)</code>","text":"<p>Update macro serialization settings.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/macro.py</code> <pre><code>def set_serialization_settings(skip: Optional[str] = settings.MACRO_KEY_SKIP):\n\"\"\"Update macro serialization settings.\"\"\"\n    global RE_MACRO_KEY_SKIP\n    if skip:\n        skip_regex = ast.literal_eval(skip)\n    else:\n        skip_regex = MACRO_KEY_SKIP_DEFAULT\n    RE_MACRO_KEY_SKIP = [re.compile(regex) for regex in skip_regex]\n</code></pre>"},{"location":"utilities/#whatrecord.macro.should_serialize_key","title":"<code>whatrecord.macro.should_serialize_key(key: str, value: str) -&gt; bool</code>","text":"<p>Should <code>key</code> be serialized when saving macros?</p> <p>Settings used: * WHATRECORD_MACRO_KEY_SKIP (str) - keys to skip, specified by regular   expressions.  Should be valid Python syntax for a list of strings, as it   will be handed to <code>ast.literal_eval</code>. * WHATRECORD_MACRO_INCLUDE_ENV (bool) - serialize environment variables if   set to 1. * WHATRECORD_MACRO_VALUE_MAX_LENGTH (int) - maximum length of macro values   to serialize. 0 to disable maximum length check.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The macro/environment variable name.</p> required <code>value</code> <code>str</code> <p>The value associated with the macro.</p> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/macro.py</code> <pre><code>def should_serialize_key(key: str, value: str) -&gt; bool:\n\"\"\"\n    Should ``key`` be serialized when saving macros?\n\n    Settings used:\n    * WHATRECORD_MACRO_KEY_SKIP (str) - keys to skip, specified by regular\n      expressions.  Should be valid Python syntax for a list of strings, as it\n      will be handed to ``ast.literal_eval``.\n    * WHATRECORD_MACRO_INCLUDE_ENV (bool) - serialize environment variables if\n      set to 1.\n    * WHATRECORD_MACRO_VALUE_MAX_LENGTH (int) - maximum length of macro values\n      to serialize. 0 to disable maximum length check.\n\n    Parameters\n    ----------\n    key : str\n        The macro/environment variable name.\n    value : str\n        The value associated with the macro.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    # Above the maximum length threshold -&gt; skip\n    if settings.MACRO_VALUE_MAX_LENGTH &gt; 0:\n        if len(value) &gt; settings.MACRO_VALUE_MAX_LENGTH:\n            return False\n\n    # Throw out environment variables if MACRO_INCLUDE_ENV is unset:\n    if not settings.MACRO_INCLUDE_ENV and key in os.environ:\n        return False\n\n    # Bad key or one that matches regular expressions in RE_MACRO_KEY_SKIP\n    # (by way of 'WHATRECORD_MACRO_KEY_SKIP')\n    if not key:\n        return False\n    return not any(regex.fullmatch(key) for regex in RE_MACRO_KEY_SKIP)\n</code></pre>"},{"location":"utilities/#pv-graphing","title":"PV Graphing","text":""},{"location":"utilities/#whatrecord.graph","title":"<code>whatrecord.graph</code>","text":""},{"location":"utilities/#whatrecord.graph-classes","title":"Classes","text":""},{"location":"utilities/#whatrecord.graph.GraphEdge","title":"<code>whatrecord.graph.GraphEdge</code>  <code>dataclass</code>","text":""},{"location":"utilities/#whatrecord.graph.GraphEdge-attributes","title":"Attributes","text":"<code>whatrecord.graph.GraphEdge.destination_with_port: str</code> <code>property</code> <p>Destination name including the port name, for graphviz.</p> <code>whatrecord.graph.GraphEdge.source_with_port: str</code> <code>property</code> <p>Source name including the port name, for graphviz.</p>"},{"location":"utilities/#whatrecord.graph.GraphNode","title":"<code>whatrecord.graph.GraphNode</code>  <code>dataclass</code>","text":""},{"location":"utilities/#whatrecord.graph.GraphNode-functions","title":"Functions","text":"<code>whatrecord.graph.GraphNode.add_text_line(line: str, delimiter: str = '\\n', only_unique: bool = True)</code> <p>Add a line of text to the node.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The line to add.</p> required <p>delimiter : str, optional     The between-line delimiter.</p> <p>only_unique : bool, optional     Only add unique lines to the text.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def add_text_line(self, line: str, delimiter: str = \"\\n\", only_unique: bool = True):\n\"\"\"\n    Add a line of text to the node.\n\n    Parameters\n    ----------\n    line : str\n        The line to add.\n\n    delimiter : str, optional\n        The between-line delimiter.\n\n    only_unique : bool, optional\n        Only add unique lines to the text.\n    \"\"\"\n    if not self.text.strip():\n        self.text = line\n    elif not only_unique or line not in self.text:\n        self.text = delimiter.join((self.text, line))\n</code></pre>"},{"location":"utilities/#whatrecord.graph.RecordLinkGraph","title":"<code>whatrecord.graph.RecordLinkGraph(database: Optional[Union[Database, Dict[str, RecordInstance]]] = None, starting_records: Optional[List[str]] = None, header_format: Optional[str] = None, field_format: Optional[str] = None, text_format: Optional[str] = None, sort_fields: bool = True, show_empty: bool = True, relations: Optional[PVRelations] = None, record_types: Optional[Dict[str, RecordType]] = None)</code>","text":"<p>             Bases: <code>_GraphHelper</code></p> <p>Record link graph.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def __init__(\n    self,\n    database: Optional[Union[Database, Dict[str, RecordInstance]]] = None,\n    starting_records: Optional[List[str]] = None,\n    header_format: Optional[str] = None,\n    field_format: Optional[str] = None,\n    text_format: Optional[str] = None,\n    sort_fields: bool = True,\n    show_empty: bool = True,\n    relations: Optional[PVRelations] = None,\n    record_types: Optional[Dict[str, RecordType]] = None,\n):\n    super().__init__()\n    self._built = False\n    self.database = None\n    self.starting_records = starting_records or []\n    self.header_format = header_format or type(self).header_format\n    self.field_format = field_format or type(self).field_format\n    self.text_format = text_format or type(self).text_format\n    self.sort_fields = sort_fields\n    self.show_empty = show_empty\n    self.relations = relations\n\n    if database is not None:\n        self.add_database(database)\n\n    if record_types is not None:\n        if self.database is None:\n            self.database = Database()\n        self.database.record_types.update(record_types)\n\n    self.relations = relations\n</code></pre>"},{"location":"utilities/#whatrecord.graph.RecordLinkGraph-attributes","title":"Attributes","text":"<code>whatrecord.graph.RecordLinkGraph.graphed_records: List[str]</code> <code>property</code> <p>All graphed record names (i.e., node labels).</p>"},{"location":"utilities/#whatrecord.graph.RecordLinkGraph-functions","title":"Functions","text":"<code>whatrecord.graph.RecordLinkGraph.add_database(database: Union[Dict[str, RecordInstance], Database])</code> <p>Add records from the given database to the graph.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def add_database(self, database: Union[Dict[str, RecordInstance], Database]):\n\"\"\"Add records from the given database to the graph.\"\"\"\n    if self.database is None:\n        if isinstance(database, Database):\n            self.database = database.shallow_copy()\n        else:\n            self.database = Database(\n                records=database,\n            )\n    elif isinstance(database, Database):\n        self.database.append(database)\n    else:\n        for record in database.values():\n            self.database.add_or_update_record(record)\n\n    self._built = False\n    self.relations = None\n</code></pre> <code>whatrecord.graph.RecordLinkGraph.build()</code> <p>Build the graph from the provided databases.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def build(self):\n\"\"\"Build the graph from the provided databases.\"\"\"\n    if self.database is None:\n        raise ValueError(\"No database or records were added\")\n\n    edge_cache = set()\n\n    def add_edge(\n        source: GraphNode,\n        destination: GraphNode,\n        source_port: Optional[str] = None,\n        dest_port: Optional[str] = None,\n        **options\n    ) -&gt; None:\n        key = (source.id, destination.id)\n        if key in edge_cache:\n            return\n        edge_cache.add(key)\n        # Avoid bottleneck of checking the edge list... ?\n        self.edges.append(\n            GraphEdge(\n                source,\n                destination,\n                source_port=source_port,\n                destination_port=dest_port,\n                options=options\n            )\n        )\n\n    edge_color_idx = 0\n    for li in find_record_links(\n        self.database.records, self.starting_records, relations=self.relations\n    ):\n        src = self.get_node(li.record1.name, text=\" \")\n        dest = self.get_node(li.record2.name, text=\" \")\n\n        for field, node in [(li.field1, src), (li.field2, dest)]:\n            if field.name == \"PROC\":\n                ...\n            elif field.value or self.show_empty:\n                node.metadata[\"fields\"][field.name] = (\n                    f'&lt;TR&gt;'\n                    f'&lt;TD PORT=\"{field.name}_name\" BORDER=\"1\"&gt;'\n                    f'&lt;B&gt;{field.name}&lt;/B&gt;'\n                    f'&lt;/TD&gt;'\n                    f'&lt;TD PORT=\"{field.name}_value\" BORDER=\"1\"&gt;'\n                    f'{field.value}'\n                    f'&lt;/TD&gt;'\n                    f'&lt;/TR&gt;'\n                )\n\n        if li.field1.dtype == \"DBF_INLINK\" or li.field2.dtype == \"DBF_OUTLINK\":\n            src, dest = dest, src\n            li.field1, li.field2 = li.field2, li.field1\n\n        logger.debug(\"New edge %s -&gt; %s\", src, dest)\n\n        edge_kw = dict(self.default_edge_kwargs)\n        for key, to_find in self.edge_kwargs.items():\n            for match, value in to_find.items():\n                if match in li.info:\n                    edge_kw[key] = value\n                    break\n\n        if (src.id, dest.id) in edge_cache:\n            continue\n\n        if li.field1.dtype == \"DBF_FWDLINK\":\n            # edge_kw[\"taillabel\"] = \"FLNK\"\n            add_edge(\n                src,\n                dest,\n                color=\"black\",\n                source_port=li.field1.name,\n                **edge_kw\n            )\n        elif li.field2.dtype == \"DBF_FWDLINK\":\n            # edge_kw[\"taillabel\"] = \"FLNK\"\n            add_edge(\n                dest,\n                src,\n                color=\"black\",\n                source_port=li.field2.name,\n                **edge_kw\n            )\n        else:\n            # edge_kw[\"taillabel\"] = f\"{li.field1.name}\"\n            # edge_kw[\"headlabel\"] = f\"{li.field2.name}\"\n            if li.info:\n                edge_kw[\"xlabel\"] = f\"\\n{' '.join(li.info)}\"\n\n            edge_color_idx += 1\n            color = self.edge_colors[edge_color_idx % len(self.edge_colors)]\n\n            add_edge(\n                src,\n                dest,\n                source_port=li.field1.name,\n                dest_port=li.field2.name,\n                color=color,\n                **edge_kw,\n            )\n\n    if not self.nodes:\n        # No relationship found; at least show the records\n        for rec_name in self.starting_records:\n            if rec_name in self.database.records:\n                self.get_node(rec_name)\n\n    for node in self.nodes.values():\n        # if self.sort_fields:\n        #     node.text = \"\\n\".join(sorted(node.text.splitlines()))\n        rec = self.database.records[node.label]\n        if rec.aliases:\n            sub_header = html.escape(f\"\\nAlias: {', '.join(rec.aliases)}\")\n            sub_header = f\"\"\"&lt;TR&gt;&lt;TD&gt;{sub_header}&lt;/TD&gt;&lt;/TR&gt;\"\"\"\n        else:\n            sub_header = \"\"\n\n        fields = list(sorted(node.metadata[\"fields\"].items()))\n        field_text = \"\\n\".join(text for _, text in fields)\n        node.text = self.text_format.format(\n            rtype=html.escape(rec.record_type),\n            name=html.escape(rec.name),\n            field_lines=(sub_header + field_text).strip(),\n        )\n\n    self._built = True\n</code></pre>"},{"location":"utilities/#whatrecord.graph.ScriptLinkGraph","title":"<code>whatrecord.graph.ScriptLinkGraph(database: Optional[Union[Database, Dict[str, RecordInstance]]] = None, limit_to_records: Optional[List[str]] = None, relations: Optional[PVRelations] = None, script_relations: Optional[ScriptPVRelations] = None, record_types: Optional[Dict[str, RecordType]] = None)</code>","text":"<p>             Bases: <code>_GraphHelper</code></p> <p>Script link graph (i.e., inter-IOC record links).</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>dict</code> <p>Dictionary of record name to record instance.</p> <code>None</code> <code>starting_records</code> <code>list of str</code> <p>Record names</p> required <code>sort_fields</code> <code>bool</code> <p>Sort list of fields</p> required <code>show_empty</code> <code>bool</code> <p>Show empty fields</p> required <code>relations</code> <code>dict</code> <p>Pre-built PV relationship dictionary.  Generated from database if not provided.</p> <code>None</code> <code>script_relations</code> <code>dict</code> <p>Pre-built script relationship dictionary.  Generated from database if not provided.</p> <code>None</code> <code>record_types</code> <code>dict</code> <p>The database definitions to use for fields that are not defined in the database file.  Dictionary of record type name to RecordType.  Only used for determining script relations if not specified.</p> <code>None</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def __init__(\n    self,\n    database: Optional[Union[Database, Dict[str, RecordInstance]]] = None,\n    limit_to_records: Optional[List[str]] = None,\n    relations: Optional[PVRelations] = None,\n    script_relations: Optional[ScriptPVRelations] = None,\n    record_types: Optional[Dict[str, RecordType]] = None,\n):\n    super().__init__()\n    self.database = None\n    self.limit_to_records = limit_to_records or []\n    self._built = False\n\n    if database is not None:\n        self.add_database(database)\n\n    if record_types is not None:\n        if self.database is None:\n            self.database = Database()\n        self.database.record_types.update(record_types)\n\n    self.relations = relations\n    self.script_relations = script_relations\n</code></pre>"},{"location":"utilities/#whatrecord.graph.ScriptLinkGraph-functions","title":"Functions","text":"<code>whatrecord.graph.ScriptLinkGraph.add_database(database: Union[Dict[str, RecordInstance], Database])</code> <p>Add records from the given database to the graph.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def add_database(self, database: Union[Dict[str, RecordInstance], Database]):\n\"\"\"Add records from the given database to the graph.\"\"\"\n    if self.database is None:\n        if isinstance(database, Database):\n            self.database = database.shallow_copy()\n        else:\n            self.database = Database(\n                records=database,\n            )\n    elif isinstance(database, Database):\n        self.database.append(database)\n    else:\n        for record in database.values():\n            self.database.add_or_update_record(record)\n\n    self._built = False\n    self.relations = None\n    self.script_relations = None\n</code></pre> <code>whatrecord.graph.ScriptLinkGraph.build()</code> <p>Build the graph from the provided databases.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def build(self):\n\"\"\"Build the graph from the provided databases.\"\"\"\n    if self.database is None:\n        raise ValueError(\"No database or records were added\")\n\n    if self.relations is None:\n        self.relations = build_database_relations(\n            self.database.records,\n            record_types=self.database.record_types,\n        )\n\n    if self.script_relations is None:\n        self.script_relations = build_script_relations(\n            database=self.database.records,\n            by_record=self.relations,\n            limit_to_records=self.limit_to_records,\n        )\n\n    for script_a, script_a_relations in self.script_relations.items():\n        self.get_node(script_a, text=script_a)\n        for script_b in script_a_relations:\n            if script_b in self.nodes:\n                continue\n            self.get_node(script_b, text=script_b)\n\n            inter_lines = (\n                [f\"&lt;b&gt;{script_a}&lt;/b&gt;\", \"\"]\n                + list(sorted(self.script_relations[script_a][script_b]))\n                + [\"\"]\n                + [f\"&lt;b&gt;{script_b}&lt;/b&gt;\", \"\"]\n                + list(sorted(self.script_relations[script_b][script_a]))\n            )\n            inter_node = f\"{script_a}&lt;-&gt;{script_b}\"\n            self.get_node(inter_node, text=\"\\n\".join(inter_lines))\n            self.add_edge(script_a, inter_node)\n            self.add_edge(inter_node, script_b)\n\n    if not self.nodes:\n        # No relationship found; at least show the records\n        for rec_name in self.limit_to_records or []:\n            if rec_name in self.database.records:\n                self.get_node(rec_name)\n\n    self._built = True\n</code></pre>"},{"location":"utilities/#whatrecord.graph-functions","title":"Functions","text":""},{"location":"utilities/#whatrecord.graph.build_database_relations","title":"<code>whatrecord.graph.build_database_relations(database: Dict[str, RecordInstance], record_types: Optional[Dict[str, RecordType]] = None, aliases: Optional[Dict[str, str]] = None, version: int = 3) -&gt; PVRelations</code>","text":"<p>Build a dictionary of PV relationships.</p> <p>This should not be called often for large databases, as it makes no attempt to be computationally efficient.  For repeated usage, cache the result of this function and reuse it in future calls to <code>graph_links</code> and such.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>dict</code> <p>Dictionary of record name to record instance.</p> required <p>record_types : dict, optional     The database definitions to use for fields that are not defined in the     database file.  Dictionary of record type name to RecordType.     If not specified, the whatrecord-vendored database definition files     will be used.</p> <p>version : int, optional     Use the old V3 style or new V3 style database grammar by specifying     3 or 4, respectively.  Defaults to 3.</p> <p>Returns:</p> Name Type Description <code>info</code> <code>dict</code> <p>Such that: <code>info[pv1][pv2] = (field1, field2, info)</code> And in reverse: <code>info[pv2][pv1] = (field2, field1, info)</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def build_database_relations(\n    database: Dict[str, RecordInstance],\n    record_types: Optional[Dict[str, RecordType]] = None,\n    aliases: Optional[Dict[str, str]] = None,\n    version: int = 3,\n) -&gt; PVRelations:\n\"\"\"\n    Build a dictionary of PV relationships.\n\n    This should not be called often for large databases, as it makes no attempt\n    to be computationally efficient.  For repeated usage, cache the result\n    of this function and reuse it in future calls to ``graph_links`` and such.\n\n    Parameters\n    ----------\n    database : dict\n        Dictionary of record name to record instance.\n\n    record_types : dict, optional\n        The database definitions to use for fields that are not defined in the\n        database file.  Dictionary of record type name to RecordType.\n        If not specified, the whatrecord-vendored database definition files\n        will be used.\n\n    version : int, optional\n        Use the old V3 style or new V3 style database grammar by specifying\n        3 or 4, respectively.  Defaults to 3.\n\n    Returns\n    -------\n    info : dict\n        Such that: ``info[pv1][pv2] = (field1, field2, info)``\n        And in reverse: ``info[pv2][pv1] = (field2, field1, info)``\n    \"\"\"\n    if not record_types:\n        dbd = Database.from_vendored_dbd(version=version)\n        record_types = dbd.record_types\n\n    aliases = aliases or {}\n    warned = set()\n    by_record = collections.defaultdict(lambda: collections.defaultdict(list))\n\n    for rec1 in database.values():\n        rec1_rtype = record_types.get(rec1.record_type, None)\n        for field1, link, info in _get_links_for_record(\n            rec1, record_types=record_types\n        ):\n            field1 = copy.deepcopy(field1)\n            # field1.context = rec1.context[:1] + field1.context\n\n            if not rec1.has_dbd_info and rec1_rtype:\n                field1.update_from_record_type(rec1_rtype)\n\n            if \".\" in link:\n                link, field2_name = link.split(\".\", 1)\n            elif field1.name == \"FLNK\":\n                field2_name = \"PROC\"\n            else:\n                field2_name = \"VAL\"\n\n            rec2_name = aliases.get(link, link)\n            rec2 = database.get(rec2_name, None)\n\n            field2 = _field_from_record_relation(\n                record=rec2,\n                field_name=field2_name,\n                link_text=link,\n                record_types=record_types,\n            )\n\n            if field2 is None:\n                continue\n\n            if rec2 is None:\n                warned.add(rec2_name)\n                logger.debug(\n                    \"Linked record from %s.%s not in database: %s\",\n                    rec1.name, field1.name, rec2_name\n                )\n            else:\n                # We may have updated information about the record field;\n                # but it's possible this is entirely unnecessary (TODO)\n                rec2_type = record_types.get(rec2.record_type, None)\n                if rec2_type is not None:\n                    field2.update_from_record_type(rec2_type)\n\n            by_record[rec1.name][rec2_name].append((field1, field2, info))\n            by_record[rec2_name][rec1.name].append((field2, field1, info))\n\n    return dict(\n        (key, dict(inner_dict))\n        for key, inner_dict in by_record.items()\n    )\n</code></pre>"},{"location":"utilities/#whatrecord.graph.build_script_relations","title":"<code>whatrecord.graph.build_script_relations(database: Dict[str, RecordInstance], by_record: PVRelations, limit_to_records: Optional[List[str]] = None) -&gt; ScriptPVRelations</code>","text":"<p>Build a relational map of IOCs that include inter-IOC PV relationships.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>Dict[str, RecordInstance]</code> <p>The full composite database.</p> required <code>by_record</code> <code>PVRelations</code> <p>PV relationships, as generated by <code>build_database_relations</code>. This is a mapping of PV1 to {\"PV2\": [FieldRelation, ...]}.</p> required <code>limit_to_records</code> <code>List[str]</code> <p>Limit the relationships to only the provided records.  If not set, defaults to all records in the composite database.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScriptPVRelations</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def build_script_relations(\n    database: Dict[str, RecordInstance],\n    by_record: PVRelations,\n    limit_to_records: Optional[List[str]] = None\n) -&gt; ScriptPVRelations:\n\"\"\"\n    Build a relational map of IOCs that include inter-IOC PV relationships.\n\n    Parameters\n    ----------\n    database : Dict[str, RecordInstance]\n        The full composite database.\n    by_record : PVRelations\n        PV relationships, as generated by ``build_database_relations``.\n        This is a mapping of PV1 to {\"PV2\": [FieldRelation, ...]}.\n    limit_to_records : List[str], optional\n        Limit the relationships to only the provided records.  If not set,\n        defaults to all records in the composite database.\n\n    Returns\n    -------\n    ScriptPVRelations\n    \"\"\"\n    if not limit_to_records:\n        record_items = by_record.items()\n    else:\n        record_items = [\n            (name, by_record[name]) for name in limit_to_records\n            if name in by_record\n        ]\n\n    def get_owner(rec):\n        if not rec:\n            return \"unknown\"\n\n        if rec.owner and rec.owner != \"unknown\":\n            return rec.owner\n\n        if rec.context:\n            return rec.context[0].name\n\n        return \"unknown\"\n\n    by_script = collections.defaultdict(lambda: collections.defaultdict(set))\n    for rec1_name, list_of_rec2s in record_items:\n        rec1 = database.get(rec1_name, None)\n        for rec2_name in list_of_rec2s:\n            rec2 = database.get(rec2_name, None)\n\n            owner1 = get_owner(rec1)\n            owner2 = get_owner(rec2)\n            if owner1 != owner2:\n                by_script[owner2][owner1].add(rec2_name)\n                by_script[owner1][owner2].add(rec1_name)\n\n    return {\n        owner1: {\n            owner2: list(items)\n            for owner2, items in owner2s.items()\n        }\n        for owner1, owner2s in by_script.items()\n    }\n</code></pre>"},{"location":"utilities/#whatrecord.graph.combine_relations","title":"<code>whatrecord.graph.combine_relations(dest_relations: PVRelations, dest_db: Dict[str, RecordInstance], source_relations: PVRelations, source_db: Dict[str, RecordInstance], record_types: Optional[Dict[str, RecordType]] = None, aliases: Optional[Dict[str, str]] = None)</code>","text":"<p>Combine multiple script relations into one.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def combine_relations(\n    dest_relations: PVRelations,\n    dest_db: Dict[str, RecordInstance],\n    source_relations: PVRelations,\n    source_db: Dict[str, RecordInstance],\n    record_types: Optional[Dict[str, RecordType]] = None,\n    aliases: Optional[Dict[str, str]] = None,\n):\n\"\"\"Combine multiple script relations into one.\"\"\"\n    aliases = aliases or {}\n\n    def get_relation_by_field() -&gt; Tuple[\n        str, str, Dict[Tuple[str, str], Tuple[str, str, List[str]]]\n    ]:\n        for rec1_name, rec2_names in source_relations.items():\n            dest_rec1_dict = dest_relations.setdefault(rec1_name, {})\n            for rec2_name in rec2_names:\n                dest_rec2 = dest_rec1_dict.setdefault(rec2_name, [])\n                relation_by_field = {\n                    (field1.name, field2.name): (field1, field2, link)\n                    for field1, field2, link in dest_rec2\n                }\n                yield rec1_name, rec2_name, relation_by_field\n\n    # Part 1:\n    # Rebuild with new aliases, if available\n    # Either set of relations could have referred to aliased names, actual\n    # names, or even *both*.\n\n    def alias_to_actual(d):\n        # This is kinda expensive, imperfect, and confusing; consider reworking\n        for alias_from, alias_to in aliases.items():\n            # A -&gt; B\n            inner_dict = d.pop(alias_from, None)\n            if not inner_dict:\n                continue\n\n            # Fix up B &lt;- A first, since it's symmetric\n            for inner_name, inner_items in inner_dict.items():\n                # d[inner_name][alias_to] += d[inner_name][alias_from]\n                d[inner_name].setdefault(alias_to, []).extend(\n                    d[inner_name].pop(alias_from)\n                )\n\n            if alias_to not in d:\n                d[alias_to] = inner_dict\n            else:\n                # The actual record name is already in the relation dict\n                for inner_name, inner_items in inner_dict.items():\n                    # d[alias_to][inner_name] += inner_items\n                    d[alias_to].setdefault(inner_name, []).extend(inner_items)\n\n    alias_to_actual(dest_relations)\n    alias_to_actual(source_relations)\n\n    # Part 1:\n    # Merge in new or updated relations from the second set\n    for rec1_name, rec2_name, relation_by_field in get_relation_by_field():\n        for field1, field2, link in source_relations[rec1_name][rec2_name]:\n            key = (field1.name, field2.name)\n            existing_link = relation_by_field.get(key, None)\n            if not existing_link:\n                relation_by_field[key] = (field1, field2, link)\n            else:\n                existing_field1, existing_field2, _ = existing_link\n                existing_field1.update_unknowns(field1)\n                existing_field2.update_unknowns(field2)\n\n        dest_relations[rec1_name][rec2_name] = list(relation_by_field.values())\n\n    def get_record(name) -&gt; RecordInstance:\n\"\"\"Get record from either database.\"\"\"\n        name = aliases.get(name, name)\n        try:\n            return dest_db.get(name, None) or source_db[name]\n        except KeyError:\n            raise\n\n    def get_field_info(record, field):\n\"\"\"Get record definition if available.\"\"\"\n        if field in record.fields:\n            return record.fields[field]\n        if record_types:\n            field_def = record_types[field]\n            return RecordField(\n                dtype=field_def.type,\n                name=field,\n                value=\"\",\n                context=field_def.context,\n            )\n\n        raise KeyError(\"Field not in database or database definition\")\n\n    # Part 2:\n    # Update any existing relations in the destination relations with\n    # information from the source database\n    for rec1_name, rec1 in source_db.items():\n        if rec1_name in dest_relations:\n            for rec2_name, rec2_items in dest_relations[rec1_name].items():\n                # We know rec1 is in the source database, but we don't know\n                # where rec2 might be, so use `get_record`.\n                try:\n                    rec2 = get_record(rec2_name)\n                except KeyError:\n                    # It's not in this IOC...\n                    continue\n\n                def get_items_to_update():\n                    for field1, field2, _ in rec2_items:\n                        yield (rec1, field1)\n                        yield (rec2, field2)\n                    for field1, field2, _ in dest_relations[rec2_name][rec1_name]:\n                        yield (rec2, field1)\n                        yield (rec1, field2)\n\n                for rec, field in get_items_to_update():\n                    try:\n                        field_info = get_field_info(rec, field.name)\n                    except KeyError:\n                        logger.debug(\"Missing field? %s.%s\", rec.name, field.name)\n                    else:\n                        field.update_unknowns(field_info)\n</code></pre>"},{"location":"utilities/#whatrecord.graph.find_record_links","title":"<code>whatrecord.graph.find_record_links(database: Dict[str, RecordInstance], starting_records: List[str], relations: Optional[PVRelations] = None, record_types: Optional[Dict[str, RecordType]] = None) -&gt; Generator[LinkInfo, None, None]</code>","text":"<p>Get all related record links from a set of starting records.</p> <p>All starting records will be included, along with any other records that are linked to from there.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>dict</code> <p>Dictionary of record name to record instance.</p> required <p>starting_records : list of str     Record names</p> <p>relations : dict, optional     Pre-built PV relationship dictionary.  Generated from database     if not provided.</p> <p>record_types : dict, optional     The database definitions to use for fields that are not defined in the     database file.  Dictionary of record type name to RecordType.</p> <p>Yields:</p> Name Type Description <code>link_info</code> <code>LinkInfo</code> <p>Link info</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def find_record_links(\n    database: Dict[str, RecordInstance],\n    starting_records: List[str],\n    relations: Optional[PVRelations] = None,\n    record_types: Optional[Dict[str, RecordType]] = None,\n) -&gt; Generator[LinkInfo, None, None]:\n\"\"\"\n    Get all related record links from a set of starting records.\n\n    All starting records will be included, along with any other records that\n    are linked to from there.\n\n    Parameters\n    ----------\n    database : dict\n        Dictionary of record name to record instance.\n\n    starting_records : list of str\n        Record names\n\n    relations : dict, optional\n        Pre-built PV relationship dictionary.  Generated from database\n        if not provided.\n\n    record_types : dict, optional\n        The database definitions to use for fields that are not defined in the\n        database file.  Dictionary of record type name to RecordType.\n\n    Yields\n    ------\n    link_info : LinkInfo\n        Link info\n    \"\"\"\n    checked = []\n\n    if relations is None:\n        relations = build_database_relations(database, record_types=record_types)\n\n    records_to_check = list(starting_records)\n\n    while records_to_check:\n        rec1 = database.get(records_to_check.pop(), None)\n        if rec1 is None:\n            continue\n\n        checked.append(rec1.name)\n        logger.debug(\"--- record %s ---\", rec1.name)\n\n        for rec2_name, fields in relations.get(rec1.name, {}).items():\n            if rec2_name in checked:\n                continue\n\n            rec2 = database.get(rec2_name, None)\n            if rec2 is None:\n                continue\n\n            for field1, field2, info in fields:\n                if rec2_name not in checked and rec2_name not in records_to_check:\n                    records_to_check.append(rec2_name)\n\n                li = LinkInfo(\n                    record1=rec1,\n                    field1=field1,\n                    record2=rec2,\n                    field2=field2,\n                    info=info,\n                )\n\n                logger.debug(\"Link %s\", li)\n                yield li\n</code></pre>"},{"location":"utilities/#whatrecord.graph.graph_links","title":"<code>whatrecord.graph.graph_links(database: Union[Database, Dict[str, RecordInstance]], starting_records: List[str], header_format: Optional[str] = None, field_format: Optional[str] = None, text_format: Optional[str] = None, sort_fields: bool = True, show_empty: bool = True, relations: Optional[PVRelations] = None, record_types: Optional[Dict[str, RecordType]] = None) -&gt; RecordLinkGraph</code>","text":"<p>Create a graphviz digraph of record links.</p> <p>All starting records will be included, along with any other records that are linked to from there - if available in the database.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>dict</code> <p>Dictionary of record name to record instance.</p> required <code>starting_records</code> <code>list of str</code> <p>Record names</p> required <code>graph</code> <code>Graph</code> <p>Graph instance to use. New one created if not specified.</p> required <code>engine</code> <code>str</code> <p>Graphviz engine (dot, fdp, etc)</p> required <code>field_format</code> <code>str</code> <p>Format string for fields (keys: field, value, attr)</p> <code>None</code> <code>sort_fields</code> <code>bool</code> <p>Sort list of fields</p> <code>True</code> <code>text_format</code> <code>str</code> <p>Text format for full node (keys: header, field_lines)</p> <code>None</code> <code>show_empty</code> <code>bool</code> <p>Show empty fields</p> <code>True</code> <code>font_name</code> <code>str</code> <p>Font name to use for all nodes and edges</p> required <code>relations</code> <code>dict</code> <p>Pre-built PV relationship dictionary.  Generated from database if not provided.</p> <code>None</code> <code>record_types</code> <code>dict</code> <p>The database definitions to use for fields that are not defined in the database file.  Dictionary of record type name to RecordType.  Only used for determining script relations if not specified.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>graph</code> <code>RecordLinkGraph</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def graph_links(\n    database: Union[Database, Dict[str, RecordInstance]],\n    starting_records: List[str],\n    header_format: Optional[str] = None,\n    field_format: Optional[str] = None,\n    text_format: Optional[str] = None,\n    sort_fields: bool = True,\n    show_empty: bool = True,\n    relations: Optional[PVRelations] = None,\n    record_types: Optional[Dict[str, RecordType]] = None,\n) -&gt; RecordLinkGraph:\n\"\"\"\n    Create a graphviz digraph of record links.\n\n    All starting records will be included, along with any other records that\n    are linked to from there - if available in the database.\n\n    Parameters\n    ----------\n    database : dict\n        Dictionary of record name to record instance.\n    starting_records : list of str\n        Record names\n    graph : graphviz.Graph, optional\n        Graph instance to use. New one created if not specified.\n    engine : str, optional\n        Graphviz engine (dot, fdp, etc)\n    field_format : str, optional\n        Format string for fields (keys: field, value, attr)\n    sort_fields : bool, optional\n        Sort list of fields\n    text_format : str, optional\n        Text format for full node (keys: header, field_lines)\n    show_empty : bool, optional\n        Show empty fields\n    font_name : str, optional\n        Font name to use for all nodes and edges\n    relations : dict, optional\n        Pre-built PV relationship dictionary.  Generated from database\n        if not provided.\n    record_types : dict, optional\n        The database definitions to use for fields that are not defined in the\n        database file.  Dictionary of record type name to RecordType.  Only\n        used for determining script relations if not specified.\n\n    Returns\n    -------\n    graph : RecordLinkGraph\n    \"\"\"\n\n    return RecordLinkGraph(\n        database=database,\n        starting_records=starting_records,\n        header_format=header_format,\n        field_format=field_format,\n        text_format=text_format,\n        sort_fields=sort_fields,\n        show_empty=show_empty,\n        relations=relations,\n        record_types=record_types,\n    )\n</code></pre>"},{"location":"utilities/#whatrecord.graph.graph_script_relations","title":"<code>whatrecord.graph.graph_script_relations(database: Dict[str, RecordInstance], limit_to_records: Optional[List[str]] = None, relations: Optional[PVRelations] = None, script_relations: Optional[ScriptPVRelations] = None, record_types: Optional[Dict[str, RecordType]] = None) -&gt; ScriptLinkGraph</code>","text":"<p>Create a graphviz digraph of script links (i.e., inter-IOC record links).</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>dict</code> <p>Dictionary of record name to record instance.</p> required <code>starting_records</code> <code>list of str</code> <p>Record names</p> required <code>relations</code> <code>dict</code> <p>Pre-built PV relationship dictionary.  Generated from database if not provided.</p> <code>None</code> <code>script_relations</code> <code>dict</code> <p>Pre-built script relationship dictionary.  Generated from database if not provided.</p> <code>None</code> <code>record_types</code> <code>dict</code> <p>The database definitions to use for fields that are not defined in the database file.  Dictionary of record type name to RecordType.  Only used for determining script relations if not specified.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>graph</code> <code>ScriptLinkGraph</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/graph.py</code> <pre><code>def graph_script_relations(\n    database: Dict[str, RecordInstance],\n    limit_to_records: Optional[List[str]] = None,\n    relations: Optional[PVRelations] = None,\n    script_relations: Optional[ScriptPVRelations] = None,\n    record_types: Optional[Dict[str, RecordType]] = None,\n) -&gt; ScriptLinkGraph:\n\"\"\"\n    Create a graphviz digraph of script links (i.e., inter-IOC record links).\n\n    Parameters\n    ----------\n    database : dict\n        Dictionary of record name to record instance.\n    starting_records : list of str\n        Record names\n    relations : dict, optional\n        Pre-built PV relationship dictionary.  Generated from database\n        if not provided.\n    script_relations : dict, optional\n        Pre-built script relationship dictionary.  Generated from database if\n        not provided.\n    record_types : dict, optional\n        The database definitions to use for fields that are not defined in the\n        database file.  Dictionary of record type name to RecordType.  Only\n        used for determining script relations if not specified.\n\n    Returns\n    -------\n    graph : ScriptLinkGraph\n    \"\"\"\n    return ScriptLinkGraph(\n        database=database,\n        limit_to_records=limit_to_records,\n        relations=relations,\n        script_relations=script_relations,\n        record_types=record_types,\n    )\n</code></pre>"},{"location":"utilities/#shared","title":"Shared","text":""},{"location":"utilities/#whatrecord.common","title":"<code>whatrecord.common</code>","text":""},{"location":"utilities/#whatrecord.common-classes","title":"Classes","text":""},{"location":"utilities/#whatrecord.common.AsynPortBase","title":"<code>whatrecord.common.AsynPortBase</code>","text":"<p>Base class for general asyn ports.</p> <p>Used in :mod:<code>whatrecord.asyn</code>, but made available here such that apischema can find it more readily.</p>"},{"location":"utilities/#whatrecord.common.DatabaseDevice","title":"<code>whatrecord.common.DatabaseDevice</code>  <code>dataclass</code>","text":"<p>A per-record-type device definition, part of a dbd file.</p>"},{"location":"utilities/#whatrecord.common.DatabaseMenu","title":"<code>whatrecord.common.DatabaseMenu</code>  <code>dataclass</code>","text":"<p>An enumeration (menu) from a dbd file.</p>"},{"location":"utilities/#whatrecord.common.FileFormat","title":"<code>whatrecord.common.FileFormat</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>File type enum that covers all formats supported by whatrecord.</p>"},{"location":"utilities/#whatrecord.common.FileFormat-functions","title":"Functions","text":"<code>whatrecord.common.FileFormat.from_extension(extension: str) -&gt; FileFormat</code> <code>classmethod</code> <p>Get a file format based on a file extension.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@classmethod\ndef from_extension(cls, extension: str) -&gt; FileFormat:\n\"\"\"Get a file format based on a file extension.\"\"\"\n    return {\n        \"cmd\": FileFormat.iocsh,\n        \"db\": FileFormat.database,\n        \"dbd\": FileFormat.database_definition,\n        \"template\": FileFormat.database,\n        \"substitutions\": FileFormat.substitution,\n        \"pvlist\": FileFormat.gateway_pvlist,\n        \"acf\": FileFormat.access_security,\n        \"proto\": FileFormat.stream_protocol,\n        \"st\": FileFormat.state_notation,\n    }[extension.lower()]\n</code></pre> <code>whatrecord.common.FileFormat.from_filename(filename: AnyPath) -&gt; FileFormat</code> <code>classmethod</code> <p>Get a file format based on a full filename.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@classmethod\ndef from_filename(cls, filename: AnyPath) -&gt; FileFormat:\n\"\"\"Get a file format based on a full filename.\"\"\"\n    path = pathlib.Path(filename)\n    extension = path.suffix.lstrip(\".\")\n    if not extension and path.name.startswith(\"Makefile\"):\n        return FileFormat.makefile\n\n    try:\n        return FileFormat.from_extension(extension)\n    except KeyError:\n        raise ValueError(\n            f\"Could not determine file type from extension: {extension}\"\n        ) from None\n</code></pre>"},{"location":"utilities/#whatrecord.common.GdbBinaryInfo","title":"<code>whatrecord.common.GdbBinaryInfo</code>  <code>dataclass</code>","text":"<p>GDB-derived binary information.</p> <p>This is populated by deserializing the output of <code>whatrecord.plugins.gdb_binary_info</code>, which is interpreted by GDB itself.</p>"},{"location":"utilities/#whatrecord.common.IocMetadata","title":"<code>whatrecord.common.IocMetadata</code>  <code>dataclass</code>","text":"<p>Metadata identifying an IOC.</p>"},{"location":"utilities/#whatrecord.common.IocMetadata-attributes","title":"Attributes","text":"<code>whatrecord.common.IocMetadata.cache_filename: pathlib.Path</code> <code>property</code> <p>The cache filename for this metadata.</p> <code>whatrecord.common.IocMetadata.database_version_spec: int</code> <code>property</code> <p>Load databases with this specification.</p> <p>Returns:</p> Name Type Description <code>version_spec</code> <code>int</code> <p>If R3.15 or under, <code>3</code>, otherwise <code>4</code>.</p> <code>whatrecord.common.IocMetadata.ioc_cache_filename: pathlib.Path</code> <code>property</code> <p>The cache filename for the entire interpreted IOC.</p> <code>whatrecord.common.IocMetadata.looks_like_sh: bool</code> <code>property</code> <p>Is the script likely sh/bash/etc?</p>"},{"location":"utilities/#whatrecord.common.IocMetadata-functions","title":"Functions","text":"<code>whatrecord.common.IocMetadata.add_loaded_file(filename: Union[pathlib.Path, str], update: bool = False) -&gt; bool</code> <p>Add filename to the loaded file dictionary, optionally updating an existing hash.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Union[Path, str]</code> <p>The filename.</p> required <code>update</code> <code>bool</code> <p>Update a hash if the filename is already in the loaded_files dictionary.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Set if a hash was updated in the loaded_files dictionary.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def add_loaded_file(\n    self,\n    filename: Union[pathlib.Path, str],\n    update: bool = False,\n) -&gt; bool:\n\"\"\"\n    Add filename to the loaded file dictionary, optionally updating an\n    existing hash.\n\n    Parameters\n    ----------\n    filename : Union[pathlib.Path, str]\n        The filename.\n    update : bool, optional\n        Update a hash if the filename is already in the loaded_files\n        dictionary.\n\n    Returns\n    -------\n    bool\n        Set if a hash was updated in the loaded_files dictionary.\n    \"\"\"\n    filename = pathlib.Path(self.startup_directory) / filename\n    if str(filename) not in self.loaded_files or update:\n        self.loaded_files[str(filename)] = util.get_file_sha256(filename)\n        return True\n    return False\n</code></pre> <code>whatrecord.common.IocMetadata.from_cache() -&gt; Optional[IocMetadata]</code> <p>Load metadata from the cache, if available.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def from_cache(self) -&gt; Optional[IocMetadata]:\n\"\"\"Load metadata from the cache, if available.\"\"\"\n    if not settings.CACHE_PATH:\n        return\n\n    try:\n        with open(self.cache_filename, \"rb\") as fp:\n            return apischema.deserialize(type(self), json.load(fp))\n    except FileNotFoundError:\n        ...\n    except json.decoder.JSONDecodeError:\n        # Truncated output file, perhaps\n        ...\n</code></pre> <code>whatrecord.common.IocMetadata.from_dict(iocdict: IocInfoDict, macros: Optional[Dict[str, str]] = None) -&gt; IocMetadata</code> <code>classmethod</code> <p>Create an IocMetadata instance.</p> <p>Pick apart a given <code>iocdict</code> dictionary, relegating extra info to <code>.metadata</code>.</p> <p>Parameters:</p> Name Type Description Default <code>iocdict</code> <code>dict</code> <p>IOC information dictionary.</p> required <code>macros</code> <code>dict</code> <p>Additional macros to use at startup.</p> <code>None</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls, iocdict: IocInfoDict, macros: Optional[Dict[str, str]] = None\n) -&gt; IocMetadata:\n\"\"\"\n    Create an IocMetadata instance.\n\n    Pick apart a given ``iocdict`` dictionary, relegating extra info to\n    ``.metadata``.\n\n    Parameters\n    ----------\n    iocdict : dict\n        IOC information dictionary.\n    macros : dict, optional\n        Additional macros to use at startup.\n    \"\"\"\n    ioc = dict(iocdict)\n    name = ioc.pop(\"name\")\n    host = ioc.pop(\"host\", None)\n    port = ioc.pop(\"port\", None)\n\n    script = ioc.pop(\"script\")\n    script = pathlib.Path(str(script)).expanduser().resolve()\n    binary = ioc.pop(\"binary\", None)\n    base_version = ioc.pop(\"base_version\", None)\n    return cls(\n        name=name,\n        script=script,\n        startup_directory=script.parent,\n        host=host,\n        port=port,\n        metadata=ioc,\n        macros=macros or {},\n        binary=binary or util.find_binary_from_hashbang(script),\n        base_version=base_version or settings.DEFAULT_BASE_VERSION,\n    )\n</code></pre> <code>whatrecord.common.IocMetadata.from_file(filename: Union[pathlib.Path, str], *, name: Optional[str] = None, host: Optional[str] = None, port: Optional[int] = None, startup_directory: Optional[pathlib.Path] = None, macros: Optional[Dict[str, str]] = None, standin_directories: Optional[Dict[str, str]] = None, binary: Optional[str] = None, base_version: Optional[str] = settings.DEFAULT_BASE_VERSION, **metadata: Optional[str]) -&gt; IocMetadata</code> <code>classmethod</code> <p>Given at minimum a filename, guess the rest of the metadata.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path or str</code> <p>The IOC startup script filename.</p> required <code>name</code> <code>str</code> <p>The name of the IOC.  Defaults to the startup script's parent directory name.</p> <code>None</code> <code>host</code> <code>str</code> <p>The host on which the IOC runs.</p> <code>None</code> <code>port</code> <code>int</code> <p>The port on which the IOC will be accessible from the host.</p> <code>None</code> <code>startup_directory</code> <code>Path</code> <p>The directory in which the script should be started.  Defaults to the parent directory of <code>filename</code>.</p> <code>None</code> <code>macros</code> <code>Dict[str, str]</code> <p>Macros to use when interpreting the startup script.</p> <code>None</code> <code>standin_directories</code> <code>Dict[str, str]</code> <p>Stand-in directories to use when interpreting a script outside of its normal environment.</p> <code>None</code> <code>binary</code> <code>str</code> <p>The binary used to run the startup script normally. That is, an EPICS IOC binary.  If not specified, this will be determined based on the startup script hashbang (if available).</p> <code>None</code> <code>base_version</code> <code>str</code> <p>The epics-base version to use when interpreting the startup script. This may be overridden automatically when interpreting the startup script.</p> <code>DEFAULT_BASE_VERSION</code> <code>**metadata</code> <p>User-specified metadata.</p> <code>{}</code> <p>Returns:</p> Type Description <code>IocMetadata</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    filename: Union[pathlib.Path, str],\n    *,\n    name: Optional[str] = None,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    startup_directory: Optional[pathlib.Path] = None,\n    macros: Optional[Dict[str, str]] = None,\n    standin_directories: Optional[Dict[str, str]] = None,\n    binary: Optional[str] = None,\n    base_version: Optional[str] = settings.DEFAULT_BASE_VERSION,\n    **metadata\n) -&gt; IocMetadata:\n\"\"\"\n    Given at minimum a filename, guess the rest of the metadata.\n\n    Parameters\n    ----------\n    filename : pathlib.Path or str\n        The IOC startup script filename.\n    name : str, optional\n        The name of the IOC.  Defaults to the startup script's parent\n        directory name.\n    host : str, optional\n        The host on which the IOC runs.\n    port : int, optional\n        The port on which the IOC will be accessible from the host.\n    startup_directory : pathlib.Path, optional\n        The directory in which the script should be started.  Defaults\n        to the parent directory of ``filename``.\n    macros : Dict[str, str], optional\n        Macros to use when interpreting the startup script.\n    standin_directories : Dict[str, str], optional\n        Stand-in directories to use when interpreting a script outside of\n        its normal environment.\n    binary : str, optional\n        The binary used to run the startup script normally. That is, an\n        EPICS IOC binary.  If not specified, this will be determined\n        based on the startup script hashbang (if available).\n    base_version : str, optional\n        The epics-base version to use when interpreting the startup script.\n        This may be overridden automatically when interpreting the startup\n        script.\n    **metadata :\n        User-specified metadata.\n\n    Returns\n    -------\n    IocMetadata\n    \"\"\"\n    filename = pathlib.Path(filename).expanduser().resolve()\n    name = name or filename.parts[-2]  # iocBoot/((ioc-something))/st.cmd\n    if \"/\" in name:\n        name = name.replace(\"/\", \"\")\n        if not name:\n            # Sorry, we need something unique here (better ideas welcome)\n            name = util.get_bytes_sha256(bytes(str(filename), \"utf-8\"))[:10]\n\n    return cls(\n        name=name,\n        host=host,\n        port=port,\n        script=filename,\n        startup_directory=startup_directory or filename.parent,\n        metadata=metadata,\n        macros=macros or {},\n        standin_directories=standin_directories or {},\n        binary=binary or util.find_binary_from_hashbang(filename),\n        base_version=base_version,\n    )\n</code></pre> <code>whatrecord.common.IocMetadata.get_binary_information() -&gt; Optional[GdbBinaryInfo]</code> <code>async</code> <p>Get binary information using the GDB plugin.</p> <p>Requires that gdb be available, along with the <code>.binary</code> be set to a valid file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>async def get_binary_information(self) -&gt; Optional[GdbBinaryInfo]:\n\"\"\"\n    Get binary information using the GDB plugin.\n\n    Requires that gdb be available, along with the ``.binary`` be set\n    to a valid file.\n    \"\"\"\n    if not self.binary or not pathlib.Path(self.binary).exists():\n        return\n\n    try:\n        info = await util.run_gdb(\n            \"gdb_binary_info\",\n            self.binary,\n            cls=GdbBinaryInfo,\n        )\n    except apischema.ValidationError:\n        logger.error(\n            \"Failed to get gdb information for %s (%s)\",\n            self.name, self.binary,\n            exc_info=True,\n        )\n        return\n\n    if info.error:\n        logger.error(\n            \"Failed to get gdb information for %s (%s): %s\",\n            self.name, self.binary, info.error\n        )\n        return\n\n    self.base_version = info.base_version or self.base_version\n    self.commands.update(info.commands)\n    self.variables.update(info.variables)\n\n    for command in self.commands.values():\n        for context in command.context or []:\n            try:\n                self.add_loaded_file(context.name)\n            except FileNotFoundError:\n                logger.debug(\n                    \"GDB source file does not exist for command %s (%s)\",\n                    command.name, context\n                )\n    return info\n</code></pre> <code>whatrecord.common.IocMetadata.is_up_to_date() -&gt; bool</code> <p>Is this IOC up-to-date with what is on disk?</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def is_up_to_date(self) -&gt; bool:\n\"\"\"Is this IOC up-to-date with what is on disk?\"\"\"\n    if not self.loaded_files:\n        return False\n    return util.check_files_up_to_date(self.loaded_files)\n</code></pre> <code>whatrecord.common.IocMetadata.save_to_cache() -&gt; bool</code> <p>Save this metadata to the cache, if enabled.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def save_to_cache(self) -&gt; bool:\n\"\"\"Save this metadata to the cache, if enabled.\"\"\"\n    if not settings.CACHE_PATH:\n        return False\n\n    with open(self.cache_filename, \"wt\") as fp:\n        json.dump(apischema.serialize(self), fp=fp)\n    return True\n</code></pre> <code>whatrecord.common.IocMetadata.update(other: IocMetadata, merge: bool = False)</code> <p>Update the metadata with a new set from an IOC Loader.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IocMetadata</code> <p>The other IOC metadata to update this instance with.</p> required <p>merge : bool, optional     Merge in dictionary information, or overwrite it.  Defaults to     'overwrite' (merge=False).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def update(self, other: IocMetadata, merge: bool = False):\n\"\"\"\n    Update the metadata with a new set from an IOC Loader.\n\n    Parameters\n    ----------\n    other : IocMetadata\n        The other IOC metadata to update this instance with.\n\n    merge : bool, optional\n        Merge in dictionary information, or overwrite it.  Defaults to\n        'overwrite' (merge=False).\n    \"\"\"\n    self.name = other.name\n    self.script = other.script\n    self.startup_directory = other.startup_directory\n    self.host = other.host or self.host\n    self.port = other.port or self.port\n    self.binary = other.binary or self.binary\n    self.base_version = (\n        other.base_version\n        if other.base_version != settings.DEFAULT_BASE_VERSION\n        else self.base_version\n    )\n\n    if merge:\n        self.metadata.update(other.metadata)\n        self.macros.update(other.macros)\n        self.standin_directories.update(other.standin_directories)\n        self.commands.update(other.commands)\n        self.variables.update(other.variables)\n    else:\n        self.metadata = dict(other.metadata)\n        self.macros = dict(other.macros)\n        self.standin_directories = dict(other.standin_directories)\n        self.commands = dict(other.commands)\n        self.variables = dict(other.variables)\n</code></pre>"},{"location":"utilities/#whatrecord.common.IocshArgument","title":"<code>whatrecord.common.IocshArgument</code>  <code>dataclass</code>","text":"<p>A single argument in a shell command.</p>"},{"location":"utilities/#whatrecord.common.IocshCmdArgs","title":"<code>whatrecord.common.IocshCmdArgs</code>  <code>dataclass</code>","text":"<p>iocshCmd(...) arguments.</p>"},{"location":"utilities/#whatrecord.common.IocshCommand","title":"<code>whatrecord.common.IocshCommand</code>  <code>dataclass</code>","text":"<p>A registered shell command.</p> <p>Largely used as part of the gdb binary information tool.</p>"},{"location":"utilities/#whatrecord.common.IocshScript","title":"<code>whatrecord.common.IocshScript</code>  <code>dataclass</code>","text":"<p>An IOC Shell script (i.e., st.cmd) that was loaded and interpreted.</p>"},{"location":"utilities/#whatrecord.common.IocshScript-functions","title":"Functions","text":"<code>whatrecord.common.IocshScript.from_general_file(filename: Union[pathlib.Path, str]) -&gt; IocshScript</code> <code>classmethod</code> <p>Create an IocshScript from any given file, even non-startup scripts.</p> <p>This can be used to transfer database files over to the frontend, for example.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Union[Path, str]</code> <p>The filename.</p> required Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@classmethod\ndef from_general_file(cls, filename: Union[pathlib.Path, str]) -&gt; IocshScript:\n\"\"\"\n    Create an IocshScript from any given file, even non-startup scripts.\n\n    This can be used to transfer database files over to the frontend, for\n    example.\n\n    Parameters\n    ----------\n    filename : Union[pathlib.Path, str]\n        The filename.\n\n    Returns\n    -------\n    \"\"\"\n    # For use when shoehorning in a file that's not _really_ an IOC script\n    # TODO: instead rework the api\n    with open(filename, \"rt\") as fp:\n        lines = fp.read().splitlines()\n\n    return cls(\n        path=str(filename),\n        lines=tuple(\n            IocshResult(\n                line=line,\n                context=(LoadContext(str(filename), lineno), )\n            )\n            for lineno, line in enumerate(lines, 1)\n        ),\n    )\n</code></pre> <code>whatrecord.common.IocshScript.from_interpreted_script(filename: Union[pathlib.Path, str], contents: str, sh: ShellState) -&gt; IocshScript</code> <code>classmethod</code> <p>Create an IocshScript provided a filename, its contents, and ShellState.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The script filename.</p> required <code>contents</code> <code>str</code> <p>The decoded string contents of the file.</p> required <code>sh</code> <code>ShellState</code> <p>The state of the shell interpreter after interpreting the IOC startup script.</p> required <p>Returns:</p> Type Description <code>IocshScript</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@classmethod\ndef from_interpreted_script(\n    cls,\n    filename: Union[pathlib.Path, str],\n    contents: str,\n    sh: ShellState\n) -&gt; IocshScript:\n\"\"\"\n    Create an IocshScript provided a filename, its contents, and ShellState.\n\n    Parameters\n    ----------\n    filename : str\n        The script filename.\n    contents : str\n        The decoded string contents of the file.\n    sh : ShellState\n        The state of the shell interpreter after interpreting the IOC\n        startup script.\n\n    Returns\n    -------\n    IocshScript\n    \"\"\"\n    return cls(\n        path=str(filename),\n        lines=tuple(\n            sh.interpret_shell_script_text(\n                contents.splitlines(),\n                name=str(filename)\n            )\n        ),\n    )\n</code></pre> <code>whatrecord.common.IocshScript.from_metadata(md: IocMetadata, sh: ShellState) -&gt; IocshScript</code> <code>classmethod</code> <p>Create an IocshScript provided IocMetadata and ShellState.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>IocMetadata</code> <p>Metadata identifying the IOC.</p> required <code>sh</code> <code>ShellState</code> <p>The state of the shell interpreter after interpreting the IOC startup script.</p> required <p>Returns:</p> Type Description <code>IocshScript</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@classmethod\ndef from_metadata(cls, md: IocMetadata, sh: ShellState) -&gt; IocshScript:\n\"\"\"\n    Create an IocshScript provided IocMetadata and ShellState.\n\n    Parameters\n    ----------\n    md : IocMetadata\n        Metadata identifying the IOC.\n    sh : ShellState\n        The state of the shell interpreter after interpreting the IOC\n        startup script.\n\n    Returns\n    -------\n    IocshScript\n    \"\"\"\n    if md.looks_like_sh:\n        if md.base_version == settings.DEFAULT_BASE_VERSION:\n            md.base_version = \"unknown\"\n        return cls.from_general_file(md.script)\n\n    return cls(\n        path=str(md.script),\n        lines=tuple(\n            sh.interpret_shell_script(\n                md.script\n            )\n        ),\n    )\n</code></pre>"},{"location":"utilities/#whatrecord.common.IocshVariable","title":"<code>whatrecord.common.IocshVariable</code>  <code>dataclass</code>","text":"<p>A registered shell variable.</p> <p>Largely used as part of the gdb binary information tool.</p>"},{"location":"utilities/#whatrecord.common.LoadContext","title":"<code>whatrecord.common.LoadContext</code>  <code>dataclass</code>","text":"<p>File and line context information.</p>"},{"location":"utilities/#whatrecord.common.MutableLoadContext","title":"<code>whatrecord.common.MutableLoadContext</code>  <code>dataclass</code>","text":"<p>A mutable (i.e., changeable) version of :class:<code>LoadContext</code>.</p>"},{"location":"utilities/#whatrecord.common.MutableLoadContext-functions","title":"Functions","text":"<code>whatrecord.common.MutableLoadContext.to_load_context() -&gt; LoadContext</code> <p>Convert this to an immutable LoadContext.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def to_load_context(self) -&gt; LoadContext:\n\"\"\"Convert this to an immutable LoadContext.\"\"\"\n    return LoadContext(self.name, self.line)\n</code></pre>"},{"location":"utilities/#whatrecord.common.PVAFieldReference","title":"<code>whatrecord.common.PVAFieldReference</code>  <code>dataclass</code>","text":"<p>Part of a PVAccess group which references another record.</p>"},{"location":"utilities/#whatrecord.common.RecordDefinitionAndInstance","title":"<code>whatrecord.common.RecordDefinitionAndInstance</code>  <code>dataclass</code>","text":"<p>A pair of V3 record definition and instance.</p>"},{"location":"utilities/#whatrecord.common.RecordField","title":"<code>whatrecord.common.RecordField</code>  <code>dataclass</code>","text":"<p>A field with a value, as part of a EPICS V3 RecordInstance.</p>"},{"location":"utilities/#whatrecord.common.RecordField-functions","title":"Functions","text":"<code>whatrecord.common.RecordField.update_from_record_type(record_type: RecordType)</code> <p>Update field information given dbd-provided information.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def update_from_record_type(\n    self,\n    record_type: RecordType\n):\n\"\"\"Update field information given dbd-provided information.\"\"\"\n    record_type_field = record_type.fields.get(self.name, None)\n    if record_type_field is not None:\n        self.dtype = record_type_field.type\n</code></pre> <code>whatrecord.common.RecordField.update_unknowns(other: RecordField, *, unknown_values: Optional[Sequence[str]] = None)</code> <p>If this RecordField has some missing information (\"unknown\"), fill it in with information from the other field.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def update_unknowns(\n    self,\n    other: RecordField,\n    *,\n    unknown_values: Optional[Sequence[str]] = None,\n):\n\"\"\"\n    If this RecordField has some missing information (\"unknown\"), fill\n    it in with information from the other field.\n    \"\"\"\n    unknown_values = unknown_values or {\"unknown\", \"\", \"(unknown-record)\"}\n    if other.dtype not in unknown_values and self.dtype in unknown_values:\n        self.dtype = other.dtype\n    if other.value not in unknown_values and self.value in unknown_values:\n        self.value = other.value\n    if len(other.context) and len(self.context) == 1:\n        ctx, = self.context\n        if ctx.name in unknown_values:\n            # Even if the other context is unknown, let's take it anyway:\n            self.context = other.context\n</code></pre>"},{"location":"utilities/#whatrecord.common.RecordInstance","title":"<code>whatrecord.common.RecordInstance</code>  <code>dataclass</code>","text":"<p>An instance of a RecordType, loaded from a db file.</p>"},{"location":"utilities/#whatrecord.common.RecordInstance-attributes","title":"Attributes","text":"<code>whatrecord.common.RecordInstance.access_security_group: str</code> <code>property</code> <p>The access security group name for the record.</p>"},{"location":"utilities/#whatrecord.common.RecordInstance-functions","title":"Functions","text":"<code>whatrecord.common.RecordInstance.get_fields_of_type(*types) -&gt; Generator[RecordField, None, None]</code> <p>Get all fields of the matching type(s).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_fields_of_type(self, *types) -&gt; Generator[RecordField, None, None]:\n\"\"\"Get all fields of the matching type(s).\"\"\"\n    if self.is_pva:\n        return\n\n    for fld in self.fields.values():\n        if fld.dtype in types:\n            yield fld\n</code></pre> <code>whatrecord.common.RecordInstance.get_links() -&gt; Generator[Tuple[RecordField, str, List[str]], None, None]</code> <p>Get all links - in, out, and forward links - for this record.</p> <p>Requires that a dbd file was loaded when the record was created. Alternatively, see :func:<code>RecordType.get_links_for_record</code>.</p> <p>Yields:</p> Name Type Description <code>field</code> <code>RecordField</code> <code>link_text</code> <code>str</code> <code>link_info</code> <code>str</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_links(\n    self,\n) -&gt; Generator[Tuple[RecordField, str, List[str]], None, None]:\n\"\"\"\n    Get all links - in, out, and forward links - for this record.\n\n    Requires that a dbd file was loaded when the record was created.\n    Alternatively, see :func:`RecordType.get_links_for_record`.\n\n    Yields\n    ------\n    field : RecordField\n    link_text: str\n    link_info: str\n    \"\"\"\n    for fld in self.get_fields_of_type(*LINK_TYPES):\n        try:\n            link, info = get_link_information(fld.value)\n        except ValueError:\n            continue\n        yield fld, link, info\n</code></pre> <code>whatrecord.common.RecordInstance.to_summary() -&gt; RecordInstanceSummary</code> <p>Return a summarized version of the record instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def to_summary(self) -&gt; RecordInstanceSummary:\n\"\"\"Return a summarized version of the record instance.\"\"\"\n    return RecordInstanceSummary.from_record_instance(self)\n</code></pre> <code>whatrecord.common.RecordInstance.update(other: RecordInstance) -&gt; List[LinterMessage]</code> <p>Update this record instance with another.</p> <p>TODO: This may not do exactly what an IOC would do. TODO: Return type?</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def update(self, other: RecordInstance) -&gt; List[LinterMessage]:\n\"\"\"\n    Update this record instance with another.\n\n    TODO: This may not do exactly what an IOC would do.\n    TODO: Return type?\n    \"\"\"\n    if other.is_pva != self.is_pva:\n        return [\n            LinterError(\n                name=\"combine_pva_and_v3\",\n                context=tuple(self.context) + tuple(other.context),\n                message=\"Cannot combine PVA group with V3 record\"\n            )\n        ]\n    self.context = remove_redundant_context(\n        tuple(self.context) + tuple(other.context)\n    )\n    self.info.update(other.info)\n    self.metadata.update(other.metadata)\n    self.fields.update(other.fields)\n    self.aliases.extend(\n        [alias for alias in other.aliases if alias not in self.aliases]\n    )\n\n    self.has_dbd_info = self.has_dbd_info or other.has_dbd_info\n    if self.record_type != other.record_type:\n        return [\n            LinterError(\n                name=\"record_type_mismatch\",\n                context=self.context,\n                message=(\n                    f\"Record type mismatch in provided database files: \"\n                    f\"{self.name} {self.record_type} {other.record_type}\"\n                ),\n            )\n        ]\n\n    return []\n</code></pre>"},{"location":"utilities/#whatrecord.common.RecordInstanceSummary","title":"<code>whatrecord.common.RecordInstanceSummary</code>  <code>dataclass</code>","text":"<p>An abbreviated form of :class:<code>RecordInstance</code>.</p>"},{"location":"utilities/#whatrecord.common.RecordType","title":"<code>whatrecord.common.RecordType</code>  <code>dataclass</code>","text":"<p>An EPICS V3 record type definition, part of a database definition (dbd).</p>"},{"location":"utilities/#whatrecord.common.RecordType-functions","title":"Functions","text":"<code>whatrecord.common.RecordType.get_fields_of_type(*types: str) -&gt; Generator[RecordTypeField, None, None]</code> <p>Get all fields of the matching type(s).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_fields_of_type(self, *types: str) -&gt; Generator[RecordTypeField, None, None]:\n\"\"\"Get all fields of the matching type(s).\"\"\"\n    for fld in self.fields.values():\n        if fld.type in types:\n            yield fld\n</code></pre> <code>whatrecord.common.RecordType.get_link_fields() -&gt; Generator[RecordTypeField, None, None]</code> <p>Get all link fields - in, out, and forward links.</p> <p>Yields:</p> Name Type Description <code>field</code> <code>RecordTypeField</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_link_fields(self) -&gt; Generator[RecordTypeField, None, None]:\n\"\"\"\n    Get all link fields - in, out, and forward links.\n\n    Yields\n    ------\n    field : RecordTypeField\n    \"\"\"\n    yield from self.get_fields_of_type(*LINK_TYPES)\n</code></pre> <code>whatrecord.common.RecordType.get_links_for_record(record: RecordInstance) -&gt; Generator[Tuple[RecordField, str, List[str]], None, None]</code> <p>Get all links - in, out, and forward links - for the given record.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>RecordInstance</code> <p>Additional information, if the database definition wasn't loaded with this instance.</p> required <p>Yields:</p> Name Type Description <code>field</code> <code>RecordField</code> <code>link_text</code> <code>str</code> <code>link_info</code> <code>str</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_links_for_record(\n    self, record: RecordInstance\n) -&gt; Generator[Tuple[RecordField, str, List[str]], None, None]:\n\"\"\"\n    Get all links - in, out, and forward links - for the given record.\n\n    Parameters\n    ----------\n    record : RecordInstance\n        Additional information, if the database definition wasn't loaded\n        with this instance.\n\n    Yields\n    ------\n    field : RecordField\n    link_text: str\n    link_info: str\n    \"\"\"\n    if record.record_type != self.name:\n        raise ValueError(\"Record types do not match\")\n\n    for field_type_info in self.get_fields_of_type(*LINK_TYPES):\n        field_instance = record.fields.get(field_type_info.name, None)\n        if field_instance is None:\n            continue\n        elif isinstance(field_instance, PVAFieldReference):\n            continue\n\n        try:\n            link, info = get_link_information(field_instance.value)\n        except ValueError:\n            continue\n        yield field_instance, link, info\n</code></pre>"},{"location":"utilities/#whatrecord.common.RecordTypeField","title":"<code>whatrecord.common.RecordTypeField</code>  <code>dataclass</code>","text":"<p>An EPICS V3 RecordType field definition, part of a database definition (dbd).</p>"},{"location":"utilities/#whatrecord.common.RecordTypeField-functions","title":"Functions","text":"<code>whatrecord.common.RecordTypeField.get_all_set_entries() -&gt; Dict[str, str]</code> <p>Get all field entries that have been set in the database definition.</p> <p>Returns:</p> Type Description <code>dict</code> <p>e.g., {\"initial\": \"5\"}</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_all_set_entries(self) -&gt; Dict[str, str]:\n\"\"\"\n    Get all field entries that have been set in the database definition.\n\n    Returns\n    -------\n    dict\n        e.g., {\"initial\": \"5\"}\n    \"\"\"\n    entries = {}\n    for attr in (\n        # Order defined in dbStaticLib.c\n        \"prompt\",\n        \"initial\",\n        \"promptgroup\",\n        \"special\",\n        \"extra\",\n        \"menu\",\n        \"size\",\n        \"pp\",\n        \"prop\",\n        \"base\",\n        \"interest\",\n        \"asl\",\n    ):\n        value = getattr(self, attr)\n        if value is not None:\n            entries[attr] = value\n    entries.update(self.body)\n    return entries\n</code></pre>"},{"location":"utilities/#whatrecord.common.ShellStateHandler","title":"<code>whatrecord.common.ShellStateHandler</code>  <code>dataclass</code>","text":"<p>A helper to work with interpreting commands from shell scripts.</p>"},{"location":"utilities/#whatrecord.common.ShellStateHandler-attributes","title":"Attributes","text":"<code>whatrecord.common.ShellStateHandler.sub_handlers: List[ShellStateHandler]</code> <code>property</code> <p>Handlers which contain their own state.</p>"},{"location":"utilities/#whatrecord.common.ShellStateHandler-functions","title":"Functions","text":"<code>whatrecord.common.ShellStateHandler.annotate_record(instance: RecordInstance) -&gt; Optional[Dict[str, Any]]</code> <p>Annotate the given record's metadata with state-related information.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def annotate_record(self, instance: RecordInstance) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Annotate the given record's metadata with state-related information.\"\"\"\n    ...\n</code></pre> <code>whatrecord.common.ShellStateHandler.find_handlers() -&gt; Generator[Tuple[str, Callable], None, None]</code> <p>Find all IOC shell command handlers by name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def find_handlers(self) -&gt; Generator[Tuple[str, Callable], None, None]:\n\"\"\"Find all IOC shell command handlers by name.\"\"\"\n    for handler_obj in [self] + self.sub_handlers:\n        for attr in dir(handler_obj):\n            if attr.startswith(\"handle_\"):\n                obj = getattr(handler_obj, attr, None)\n                if callable(obj):\n                    name = attr.split(\"_\", 1)[1]\n                    yield name, obj\n\n        if handler_obj is not self:\n            yield from handler_obj.find_handlers()\n</code></pre> <code>whatrecord.common.ShellStateHandler.generic_handler_decorator(func = None, stub = False)</code> <code>staticmethod</code> <p>Decorate a handler method to generically return parameter-to-value information.</p> <p>This can be in addition to or in place of GDB command information.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The <code>handler_</code> method.</p> <code>None</code> <p>stub : bool, optional     Mark this as a stub method.  Variable arguments will be filled in     as necessary, even if defaults are not provided.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@staticmethod\ndef generic_handler_decorator(func=None, stub=False):\n\"\"\"\n    Decorate a handler method to generically return parameter-to-value\n    information.\n\n    This can be in addition to or in place of GDB command information.\n\n    Parameters\n    ----------\n    func : callable\n        The ``handler_`` method.\n\n    stub : bool, optional\n        Mark this as a stub method.  Variable arguments will be filled in\n        as necessary, even if defaults are not provided.\n    \"\"\"\n\n    def wrap(func):\n        params = list(inspect.signature(func).parameters.items())[1:]\n        defaults = list(\n            None if param.default is inspect.Parameter.empty\n            else param.default\n            for _, param in params\n        )\n\n        @functools.wraps(func)\n        def wrapped(self, *args):\n            result = {}\n            if len(args) &lt; len(params) and stub:\n                # Pad unspecified arguments with defaults or \"None\"\n                args = list(args) + defaults[len(args):]\n\n            if len(args) &gt; len(params):\n                result[\"argument_lint\"] = \"Too many arguments\"\n\n            result[\"arguments\"] = [\n                {\n                    \"name\": name,\n                    \"type\": getattr(param.annotation, \"__name__\", param.annotation),\n                    \"value\": value,\n                }\n                for (name, param), value in zip(params, args)\n            ]\n\n            call_result = func(self, *args[:len(params)])\n            if call_result is not None:\n                for key, value in call_result.items():\n                    if key in result:\n                        result[key].update(value)\n                    else:\n                        result[key] = value\n\n            return result\n        return wrapped\n\n    if func is not None:\n        return wrap(func)\n\n    return wrap\n</code></pre> <code>whatrecord.common.ShellStateHandler.get_load_context() -&gt; FullLoadContext</code> <p>Get a FullLoadContext tuple representing where we are now.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_load_context(self) -&gt; FullLoadContext:\n\"\"\"Get a FullLoadContext tuple representing where we are now.\"\"\"\n    if self.primary_handler is None:\n        return tuple()\n    return self.primary_handler.get_load_context()\n</code></pre> <code>whatrecord.common.ShellStateHandler.post_ioc_init()</code> <p>Post-iocInit hook.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def post_ioc_init(self):\n\"\"\"Post-iocInit hook.\"\"\"\n    ...\n</code></pre> <code>whatrecord.common.ShellStateHandler.pre_ioc_init()</code> <p>Pre-iocInit hook.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def pre_ioc_init(self):\n\"\"\"Pre-iocInit hook.\"\"\"\n    ...\n</code></pre>"},{"location":"utilities/#whatrecord.common.StringWithContext","title":"<code>whatrecord.common.StringWithContext</code>","text":"<p>             Bases: <code>str</code></p> <p>A string with LoadContext.</p>"},{"location":"utilities/#whatrecord.common.UnquotedString","title":"<code>whatrecord.common.UnquotedString</code>","text":"<p>             Bases: <code>str</code></p> <p>An unquoted string token found when loading a database file. May be a linter warning.</p>"},{"location":"utilities/#whatrecord.common.WhatRecord","title":"<code>whatrecord.common.WhatRecord</code>  <code>dataclass</code>","text":"<p>WhatRecord - full set of information regarding a specific record.</p> <p>This response is on a per-IOC basis, so at most it can return one V3 record and one V4 record, as these exist in separate namespaces.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The record name.</p> <p>record : RecordDefinitionAndInstance, optional     The V3 record definition (if available) and record instance.</p> <p>pva_group : RecordInstance, optional     The PVAccess group, if available.</p> <p>ioc : IocMetadata, optional     The associated IOC metadata, if available.</p>"},{"location":"utilities/#whatrecord.common-functions","title":"Functions","text":""},{"location":"utilities/#whatrecord.common.context_from_lark_token","title":"<code>whatrecord.common.context_from_lark_token(fn: str, token: lark.Token) -&gt; FullLoadContext</code>","text":"<p>Get a full load context from a given lark Token.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def context_from_lark_token(fn: str, token: lark.Token) -&gt; FullLoadContext:\n\"\"\"Get a full load context from a given lark Token.\"\"\"\n    return (LoadContext(name=fn, line=token.line), )\n</code></pre>"},{"location":"utilities/#whatrecord.common.get_grammar_version_by_base_version","title":"<code>whatrecord.common.get_grammar_version_by_base_version(base_version: str) -&gt; int</code>","text":"<p>Database grammar version to use, provided the epics-base version.</p> <p>Returns:</p> Name Type Description <code>base_version</code> <code>str</code> <p>The epics-base version number.</p> <p>Returns:</p> Type Description <code>int</code> <p>If R3.15 or under, <code>3</code>, otherwise <code>4</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_grammar_version_by_base_version(base_version: str) -&gt; int:\n\"\"\"\n    Database grammar version to use, provided the epics-base version.\n\n    Returns\n    -------\n    base_version : str\n        The epics-base version number.\n\n    Returns\n    -------\n    int\n        If R3.15 or under, ``3``, otherwise ``4``.\n    \"\"\"\n    base_version = base_version.lstrip(\"vRr\")\n    major_minor = tuple(\n        int(v) for v in base_version.split(\".\")[:2]\n    )\n    return 3 if major_minor &lt; (3, 16) else 4\n</code></pre>"},{"location":"utilities/#whatrecord.common.get_link_information","title":"<code>whatrecord.common.get_link_information(link_str: str) -&gt; Tuple[str, List[str]]</code>","text":"<p>Get link information from a DBF_{IN,OUT,FWD}LINK value.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def get_link_information(link_str: str) -&gt; Tuple[str, List[str]]:\n\"\"\"Get link information from a DBF_{IN,OUT,FWD}LINK value.\"\"\"\n    if isinstance(link_str, (dict, list)):\n        raise ValueError(\"JSON and PVAccess links are a TODO (sorry!)\")\n    if not isinstance(link_str, str):\n        raise ValueError(\n            f\"Unexpected and supported type for get_link_information: \"\n            f\"{type(link_str)}\"\n        )\n\n    if \" \" in link_str:\n        # strip off PP/MS/etc (TODO might be useful later)\n        link_str, additional_info = link_str.split(\" \", 1)\n    else:\n        additional_info = \"\"\n\n    if link_str.startswith(\"@\"):\n        # TODO asyn/device links\n        raise ValueError(\"asyn link\")\n    if not link_str:\n        raise ValueError(\"empty link\")\n\n    if link_str.isnumeric():\n        # 0 or 1 usually and not a string\n        raise ValueError(\"integral link\")\n\n    try:\n        float(link_str)\n    except Exception:\n        # Good, we don't want a float\n        ...\n    else:\n        raise ValueError(\"float link\")\n\n    link_details = additional_info.split()\n    return link_str, link_details\n</code></pre>"},{"location":"utilities/#whatrecord.common.remove_redundant_context","title":"<code>whatrecord.common.remove_redundant_context(full_context: FullLoadContext) -&gt; FullLoadContext</code>","text":"<p>Remove redundant context information if it does not add anything.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>def remove_redundant_context(full_context: FullLoadContext) -&gt; FullLoadContext:\n\"\"\"Remove redundant context information if it does not add anything.\"\"\"\n    if not full_context:\n        return full_context\n\n    # Inefficient, but the data set is small here, so meh\n    zero_line_files = set(\n        item.name\n        for item in full_context\n        if item.line == 0\n    )\n\n    for file in set(zero_line_files):\n        for ctx in full_context:\n            if ctx.name == file and ctx.line &gt; 0:\n                break\n        else:\n            zero_line_files.remove(file)\n\n    new_context = []\n    for ctx in full_context:\n        is_specific = ctx.name not in zero_line_files or ctx.line &gt; 0\n        if is_specific and ctx not in new_context:\n            new_context.append(ctx)\n    return tuple(new_context)\n</code></pre>"},{"location":"utilities/#whatrecord.common.time_context","title":"<code>whatrecord.common.time_context()</code>","text":"<p>Return a callable to measure the time since context manager init.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/common.py</code> <pre><code>@contextmanager\ndef time_context():\n\"\"\"Return a callable to measure the time since context manager init.\"\"\"\n    start_count = perf_counter()\n\n    def inner():\n        return perf_counter() - start_count\n\n    yield inner\n</code></pre>"},{"location":"utilities/#miscellaneous","title":"Miscellaneous","text":""},{"location":"utilities/#whatrecord.cache","title":"<code>whatrecord.cache</code>","text":""},{"location":"utilities/#whatrecord.cache-classes","title":"Classes","text":""},{"location":"utilities/#whatrecord.cache.CacheKey","title":"<code>whatrecord.cache.CacheKey</code>  <code>dataclass</code>","text":""},{"location":"utilities/#whatrecord.cache.CacheKey-functions","title":"Functions","text":"<code>whatrecord.cache.CacheKey.to_filename(version: int = 1, class_name: Optional[str] = None) -&gt; str</code> <p>Get the cache filename.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/cache.py</code> <pre><code>def to_filename(self, version: int = 1, class_name: Optional[str] = None) -&gt; str:\n\"\"\"Get the cache filename.\"\"\"\n    def by_name(field):\n        return field.name\n\n    values = \":\".join(\n        field.name + \"=\" + self._to_cache_key_part(getattr(self, field.name))\n        for field in sorted(fields(self), key=by_name)\n    )\n    value_repr = repr(values)\n    sha = get_bytes_sha256(value_repr.encode(\"utf-8\"))\n    class_name = class_name or self.__class__.__name__\n    return f\"{class_name}_v{version}_{sha}.json\"\n</code></pre>"},{"location":"utilities/#whatrecord.cache.Cached","title":"<code>whatrecord.cache.Cached</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_Cached</code></p> <p>A generic dataclass that can be cached in <code>WHATRECORD_CACHE_PATH</code>.</p> <p>Expects to be subclassed and configured with a CacheKey subclass.</p>"},{"location":"utilities/#whatrecord.cache.InlineCached","title":"<code>whatrecord.cache.InlineCached</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_Cached</code></p> <p>A generic dataclass that can be cached in <code>WHATRECORD_CACHE_PATH</code>.</p> <p>Expects to be subclassed and mixed in with a CacheKey subclass.</p>"},{"location":"utilities/#whatrecord.cache.InlineCached-attributes","title":"Attributes","text":"<code>whatrecord.cache.InlineCached.key: CacheKey</code> <code>property</code> <p>An auto-generated CacheKey based on this dataclass's attributes.</p>"},{"location":"utilities/#whatrecord.cache-functions","title":"Functions","text":""},{"location":"utilities/#whatrecord.format","title":"<code>whatrecord.format</code>","text":""},{"location":"utilities/#whatrecord.format-classes","title":"Classes","text":""},{"location":"utilities/#whatrecord.format.FormatContext","title":"<code>whatrecord.format.FormatContext(helpers: Optional[list] = None, options: Optional[FormatOptions] = None, *, trim_blocks: bool = True, lstrip_blocks: bool = False, default_options: str = 'console', **env_kwargs: str)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/format.py</code> <pre><code>def __init__(\n    self,\n    helpers: Optional[list] = None,\n    options: Optional[FormatOptions] = None,\n    *,\n    trim_blocks: bool = True,\n    lstrip_blocks: bool = False,\n    default_options: str = \"console\",\n    **env_kwargs\n):\n    self.helpers = helpers or [self.render_object, type, locals, json]\n    self.default_options = default_options\n    self._template_dict = {}\n    self.env = jinja2.Environment(\n        loader=jinja2.DictLoader(self._template_dict),\n        trim_blocks=trim_blocks,\n        lstrip_blocks=lstrip_blocks,\n        **env_kwargs,\n    )\n\n    self.format_options = options or FormatOptions()\n    self.env.filters.update(self.get_filters())\n    self.default_render_context = self.get_render_context()\n    self._fallback_formats = {}\n</code></pre>"},{"location":"utilities/#whatrecord.format.FormatContext-functions","title":"Functions","text":"<code>whatrecord.format.FormatContext.get_filters(**user_config)</code> <p>All jinja filters.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/format.py</code> <pre><code>def get_filters(self, **user_config):\n\"\"\"All jinja filters.\"\"\"\n\n    @pass_eval_context\n    def title_fill(eval_ctx, text, fill_char):\n        return fill_char * len(text)\n\n    @pass_eval_context\n    def classname(eval_ctx, obj):\n        if inspect.isclass(obj):\n            return obj.__name__\n        return type(obj).__name__\n\n    @pass_eval_context\n    def render_object(eval_ctx, obj, option):\n        return self.render_object(obj, option)\n\n    return {\n        key: value\n        for key, value in locals().items()\n        if not key.startswith(\"_\") and key not in {\"self\"}\n    }\n</code></pre> <code>whatrecord.format.FormatContext.get_render_context() -&gt; dict</code> <p>Jinja template context dictionary - helper functions.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/format.py</code> <pre><code>def get_render_context(self) -&gt; dict:\n\"\"\"Jinja template context dictionary - helper functions.\"\"\"\n    context = {func.__name__: func for func in self.helpers}\n    context[\"_fmt\"] = self.format_options\n    context[\"_json_dump\"] = functools.partial(json.dumps, indent=self.format_options.indent)\n    context[\"_indent\"] = self.format_options.indent * \" \"\n    return context\n</code></pre>"},{"location":"utilities/#whatrecord.graphql","title":"<code>whatrecord.graphql</code>","text":""},{"location":"utilities/#whatrecord.graphql-classes","title":"Classes","text":""},{"location":"utilities/#whatrecord.settings","title":"<code>whatrecord.settings</code>","text":""},{"location":"utilities/#whatrecord.util","title":"<code>whatrecord.util</code>","text":""},{"location":"utilities/#whatrecord.util-functions","title":"Functions","text":""},{"location":"utilities/#whatrecord.util.check_files_up_to_date","title":"<code>whatrecord.util.check_files_up_to_date(file_to_hash: Dict[AnyPath, str]) -&gt; bool</code>","text":"<p>Check if the provided files are up-to-date by way of recorded hash vs current hash.</p> <p>Parameters:</p> Name Type Description Default <code>file_to_hash</code> <code>Dict[Union[str, Path], str]</code> <p>File path to hash.</p> required <p>Returns:</p> Name Type Description <code>up_to_date</code> <code>bool</code> <p>If all files maintain their stored hashes, returns True.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>def check_files_up_to_date(\n    file_to_hash: Dict[AnyPath, str]\n) -&gt; bool:\n\"\"\"\n    Check if the provided files are up-to-date by way of recorded hash vs\n    current hash.\n\n    Parameters\n    ----------\n    file_to_hash : Dict[Union[str, pathlib.Path], str]\n        File path to hash.\n\n    Returns\n    -------\n    up_to_date : bool\n        If all files maintain their stored hashes, returns True.\n    \"\"\"\n    for fn, file_hash in file_to_hash.items():\n        try:\n            if get_file_sha256(fn) != file_hash:\n                return False\n        except FileNotFoundError:\n            return False\n\n    return True\n</code></pre>"},{"location":"utilities/#whatrecord.util.find_binary_from_hashbang","title":"<code>whatrecord.util.find_binary_from_hashbang(startup_script: Optional[Union[str, pathlib.Path]], must_exist: bool = False) -&gt; Optional[str]</code>","text":"<p>Find the binary associated with a given startup script by looking at its shebang.</p> <p>Returns:</p> Name Type Description <code>binary_path</code> <code>str or None</code> <p>The path to the binary, if available.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>def find_binary_from_hashbang(\n    startup_script: Optional[Union[str, pathlib.Path]],\n    must_exist: bool = False,\n) -&gt; Optional[str]:\n\"\"\"\n    Find the binary associated with a given startup script by looking at its\n    shebang.\n\n    Returns\n    -------\n    binary_path : str or None\n        The path to the binary, if available.\n    \"\"\"\n    if startup_script is None:\n        return None\n\n    try:\n        with open(startup_script, \"rt\") as fp:\n            first_line = fp.read().splitlines()[0]\n    except Exception:\n        return None\n\n    if first_line.startswith(\"#!\"):\n        parent_dir = pathlib.Path(startup_script).parent\n        binary = parent_dir / first_line.lstrip(\"#!\").strip()\n        if not must_exist or binary.exists():\n            return str(binary.resolve())\n</code></pre>"},{"location":"utilities/#whatrecord.util.get_bytes_sha256","title":"<code>whatrecord.util.get_bytes_sha256(contents: bytes)</code>","text":"<p>Hash a byte string with the SHA-256 algorithm.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>def get_bytes_sha256(contents: bytes):\n\"\"\"Hash a byte string with the SHA-256 algorithm.\"\"\"\n    return hashlib.sha256(contents).hexdigest()\n</code></pre>"},{"location":"utilities/#whatrecord.util.get_file_sha256","title":"<code>whatrecord.util.get_file_sha256(binary: AnyPath)</code>","text":"<p>Hash a binary with the SHA-256 algorithm.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>def get_file_sha256(binary: AnyPath):\n\"\"\"Hash a binary with the SHA-256 algorithm.\"\"\"\n    # This doesn't do any sort of buffering; but our binaries are pretty small\n    # in comparison to what we're storing as metadata, anyway\n    with open(binary, \"rb\") as fp:\n        return hashlib.sha256(fp.read()).hexdigest()\n</code></pre>"},{"location":"utilities/#whatrecord.util.lines_between","title":"<code>whatrecord.util.lines_between(text: str, start_marker: str, end_marker: str, *, include_blank: bool = False) -&gt; Generator[str, None, None]</code>","text":"<p>From a block of text, yield all lines between <code>start_marker</code> and <code>end_marker</code></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The block of text</p> required <code>start_marker</code> <code>str</code> <p>The block-starting marker to match</p> required <code>end_marker</code> <code>str</code> <p>The block-ending marker to match</p> required <code>include_blank</code> <code>bool</code> <p>Skip yielding blank lines</p> <code>False</code> <p>Yields:</p> Name Type Description <code>line</code> <code>str</code> <p>Line of text found between the markers.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>def lines_between(\n    text: str,\n    start_marker: str,\n    end_marker: str,\n    *,\n    include_blank: bool = False\n) -&gt; Generator[str, None, None]:\n\"\"\"\n    From a block of text, yield all lines between `start_marker` and\n    `end_marker`\n\n    Parameters\n    ----------\n    text : str\n        The block of text\n    start_marker : str\n        The block-starting marker to match\n    end_marker : str\n        The block-ending marker to match\n    include_blank : bool, optional\n        Skip yielding blank lines\n\n    Yields\n    ------\n    line : str\n        Line of text found between the markers.\n    \"\"\"\n    found_start = False\n    start_marker = start_marker.lower()\n    end_marker = end_marker.lower()\n    for line in text.splitlines():\n        line_lowercase = line.strip().lower()\n        if line_lowercase == start_marker:\n            found_start = True\n        elif found_start:\n            if line_lowercase == end_marker:\n                break\n            elif line_lowercase or include_blank:\n                yield line\n</code></pre>"},{"location":"utilities/#whatrecord.util.read_text_file_with_hash","title":"<code>whatrecord.util.read_text_file_with_hash(fn: pathlib.Path, encoding: pathlib.Path = 'latin-1') -&gt; Tuple[str, str]</code>","text":"<p>Hash a binary with the SHA-256 algorithm.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>def read_text_file_with_hash(\n    fn: pathlib.Path,\n    encoding=\"latin-1\",\n) -&gt; Tuple[str, str]:\n\"\"\"Hash a binary with the SHA-256 algorithm.\"\"\"\n    # This doesn't do any sort of buffering; but our binaries are pretty small\n    # in comparison to what we're storing as metadata, anyway\n    with open(fn, \"rb\") as fp:\n        contents = fp.read()\n    sha256 = hashlib.sha256(contents).hexdigest()\n    return sha256, contents.decode(encoding)\n</code></pre>"},{"location":"utilities/#whatrecord.util.run_gdb","title":"<code>whatrecord.util.run_gdb(script: str, binary: Union[pathlib.Path, str], cls: T, args: Optional[List[str]] = None, gdb_path: Optional[str] = None, use_cache: bool = True) -&gt; T</code>  <code>async</code>","text":"<p>Run a script and deserialize its output.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>str</code> <p>The script name to run (whatrecord.script, omitting .py)</p> required <p>binary : str or pathlib.Path     The binary file to load into GDB.</p> <p>cls : type     The dataclass type to deserialize gdb's output to.</p> <p>args : list, optional     List of string arguments to pass to gdb.</p> <p>gdb_path : str, optional     The path to the gdb binary.  Defaults to <code>WHATRECORD_GDB_PATH</code>     from the environment (<code>gdb</code>).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>async def run_gdb(\n    script: str,\n    binary: Union[pathlib.Path, str],\n    cls: T,\n    args: Optional[List[str]] = None,\n    gdb_path: Optional[str] = None,\n    use_cache: bool = True,\n) -&gt; T:\n\"\"\"\n    Run a script and deserialize its output.\n\n    Parameters\n    ----------\n    script : str\n        The script name to run (whatrecord.__script__, omitting .py)\n\n    binary : str or pathlib.Path\n        The binary file to load into GDB.\n\n    cls : type\n        The dataclass type to deserialize gdb's output to.\n\n    args : list, optional\n        List of string arguments to pass to gdb.\n\n    gdb_path : str, optional\n        The path to the gdb binary.  Defaults to ``WHATRECORD_GDB_PATH``\n        from the environment (``gdb``).\n    \"\"\"\n    cache_path = pathlib.Path(settings.CACHE_PATH)\n    binary_hash = get_file_sha256(binary)\n\n    hash_filename = cache_path / f\"{script}_{cls.__name__}_{binary_hash}.json\"\n    if use_cache:\n        if not settings.CACHE_PATH or not cache_path.exists():\n            use_cache = False\n        else:\n            try:\n                with open(hash_filename, \"rt\") as fp:\n                    json_data = json.load(fp)\n                return apischema.deserialize(cls, json_data)\n            except FileNotFoundError:\n                ...\n            except Exception as ex:\n                logger.warning(\n                    \"Failed to load cached gdb information from disk; \"\n                    \"re-running gdb (%s, filename=%s)\",\n                    ex,\n                    hash_filename,\n                    exc_info=True\n                )\n\n    args = \" \".join(f'\"{arg}\"' for arg in args or [])\n    script_path = MODULE_PATH / \"plugins\" / f\"{script}.py\"\n    gdb_path = gdb_path or settings.GDB_PATH\n    to_execute = (\n        f'\"{gdb_path}\" '\n        f\"--batch-silent \"\n        f'--command \"{script_path}\" '\n        f'--args \"{binary}\" {args}'\n    )\n\n    json_data = await run_script_with_json_output(to_execute)\n    json_data = json_data or {}\n\n    if use_cache:\n        with open(hash_filename, \"wt\") as fp:\n            json.dump(json_data, fp, indent=4)\n\n    try:\n        return apischema.deserialize(cls, json_data)\n    except Exception as ex:\n        ex.json_data = json_data\n        raise\n</code></pre>"},{"location":"utilities/#whatrecord.util.run_script_with_json_output","title":"<code>whatrecord.util.run_script_with_json_output(script_line: str, encoding: str = 'utf-8', log_errors: bool = True) -&gt; Optional[dict]</code>  <code>async</code>","text":"<p>Run a script and get its JSON output.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>async def run_script_with_json_output(\n    script_line: str,\n    encoding: str = \"utf-8\",\n    log_errors: bool = True,\n) -&gt; Optional[dict]:\n\"\"\"Run a script and get its JSON output.\"\"\"\n    proc = await asyncio.create_subprocess_shell(\n        script_line,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE\n    )\n\n    (stdout, stderr) = await proc.communicate()\n    if stderr and log_errors:\n        stderr_text = textwrap.indent(stderr.decode(\"utf-8\", \"replace\"), \"    ! \")\n        logger.warning(\n            \"Standard error output while running script (%r):\\n%s\",\n            script_line, stderr_text\n        )\n\n    if stdout:\n        return json.loads(stdout.decode(encoding))\n\n    if log_errors:\n        logger.warning(\n            \"No standard output while running script (%r)\",\n            script_line\n        )\n</code></pre>"},{"location":"utilities/#whatrecord.util.write_to_file","title":"<code>whatrecord.util.write_to_file(obj: Any, filename: Optional[str] = None, format: str = 'json', catch_broken_pipe: bool = True) -&gt; str</code>","text":"<p>Write <code>obj</code> to <code>filename</code> in the specified <code>format</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to write to the file.</p> required <code>filename</code> <code>Optional[str]</code> <p>If None, defaults to standard output.</p> <code>None</code> <code>format</code> <code>str</code> <p>The format to use.  \"json\" is supported for all types. Other types may only support \"console\" or \"file\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>data</code> <code>str</code> <p>The data written to the file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/whatrecord/util.py</code> <pre><code>def write_to_file(\n    obj: Any,\n    filename: Optional[str] = None,\n    format: str = \"json\",\n    catch_broken_pipe: bool = True\n) -&gt; str:\n\"\"\"\n    Write ``obj`` to ``filename`` in the specified ``format``.\n\n    Parameters\n    ----------\n    obj : Any\n        The object to write to the file.\n    filename : Optional[str], optional\n        If None, defaults to standard output.\n    format : str, optional\n        The format to use.  \"json\" is supported for all types. Other types\n        may only support \"console\" or \"file\".\n\n    Returns\n    -------\n    data : str\n        The data written to the file.\n    \"\"\"\n    if format == \"json\":\n        json_info = apischema.serialize(obj)\n        to_write = json.dumps(json_info, indent=settings.INDENT)\n    else:\n        from .format import FormatContext\n        fmt = FormatContext()\n        to_write = fmt.render_object(obj, format)\n\n    if filename is None:\n        try:\n            print(to_write, flush=True)\n        except BrokenPipeError:\n            if not catch_broken_pipe:\n                raise\n\n            # Ref: https://docs.python.org/3/library/signal.html#note-on-sigpipe\n            # Python flushes standard streams on exit; redirect remaining\n            # output to devnull to avoid another BrokenPipeError at shutdown\n            devnull = os.open(os.devnull, os.O_WRONLY)\n            os.dup2(devnull, sys.stdout.fileno())\n            sys.exit(1)  # Python exits with error code 1 on EPIPE\n    else:\n        with open(filename, \"wt\") as fp:\n            fp.write(to_write)\n\n    return to_write\n</code></pre>"}]}